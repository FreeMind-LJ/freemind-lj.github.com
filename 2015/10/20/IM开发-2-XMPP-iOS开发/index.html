<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>IM开发(2)-XMPP iOS开发 | 树下的老男孩</title>
  <meta name="author" content="树下的老男孩">
  
  <meta name="description" content="搭建完本地服务器之后，我们便可以着手客户端的工作，这里我们使用XMPPFramework这个开源库，安卓平台可以使用Smack(最好使用4.1以及之后的版本，支持流管理)，为了简单起见这里只实现登陆、获取好友列表以及聊天等功能，页面如下所示：">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="IM开发(2)-XMPP iOS开发"/>
  <meta property="og:site_name" content="树下的老男孩"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="树下的老男孩" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="/js/jquery.min.js"></script>
  
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45019001-1', 'topdna.org');
  ga('send', 'pageview');

</script>


</head>


<body>
  <!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://storage.ie6countdown.com/assets/100/images/banners/warning_bar_0027_Simplified Chinese.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">树下的老男孩</a></h1>
  <h2><a href="/">工匠之行，在行动中体悟修行的乐趣</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/categories/tech/">技术</a></li>
    
      <li><a href="/categories/others/">其它</a></li>
    
      <li><a href="/archives">归档</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <time datetime="2015-10-20T04:30:46.000Z"><a href="/2015/10/20/IM开发-2-XMPP-iOS开发/">2015-10-20</a></time>
      
      
  
    <h1 class="title">IM开发(2)-XMPP iOS开发</h1>
  

    </header>
    <div class="entry">
      
        <p>搭建完<a href="http://www.jianshu.com/p/f801229de016" target="_blank" rel="external">本地服务器</a>之后，我们便可以着手客户端的工作，这里我们使用<a href="https://github.com/robbiehanson/XMPPFramework" target="_blank" rel="external">XMPPFramework</a>这个开源库，安卓平台可以使用<a href="https://github.com/igniterealtime/Smack" target="_blank" rel="external">Smack</a>(最好使用4.1以及之后的版本，支持流管理)，为了简单起见这里只实现登陆、获取好友列表以及聊天等功能，页面如下所示：</p>
<a id="more"></a>
<center><br><br><img src="http://7xpjm0.com1.z0.glb.clouddn.com/user2%E7%9A%84%E5%A5%BD%E5%8F%8B%E5%88%97%E8%A1%A8.png" alt="user2的好友列表.png"><br><br><img src="http://7xpjm0.com1.z0.glb.clouddn.com/%E8%81%8A%E5%A4%A9.png" alt="聊天.png"><br><br></center>

<h4 id="xmpp初始化"><a href="#xmpp初始化" class="headerlink" title="xmpp初始化"></a>xmpp初始化</h4><p>  在开始使用xmpp进行IM聊天之前，我们需要初始化xmpp流，接入我们需要的模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define JBXMPP_HOST @&#34;lujiangbin.local&#34;&#10;#define JBXMPP_PORT 5222&#10;- (void)setupStream&#10;&#123;&#10;&#160; &#160; if (!_xmppStream) &#123;&#10;&#160; &#160; &#160; &#160; _xmppStream = [[XMPPStream alloc] init];&#10;&#160;&#160; &#160; &#160; &#10;&#160; &#160; &#160; &#160; [self.xmppStream setHostName:JBXMPP_HOST]; //&#35774;&#32622;xmpp&#26381;&#21153;&#22120;&#22320;&#22336;&#10;&#160; &#160; &#160; &#160; [self.xmppStream setHostPort:JBXMPP_PORT]; //&#35774;&#32622;xmpp&#31471;&#21475;&#65292;&#40664;&#35748;5222&#10;&#160; &#160; &#160; &#160; [self.xmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];&#10;&#160; &#160; &#160; &#160; [self.xmppStream setKeepAliveInterval:30]; //&#24515;&#36339;&#21253;&#26102;&#38388;&#10;&#10;        //&#20801;&#35768;xmpp&#22312;&#21518;&#21488;&#36816;&#34892;&#10;&#160; &#160; &#160; &#160; self.xmppStream.enableBackgroundingOnSocket=YES;&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#160; &#160; &#160; &#160; //&#25509;&#20837;&#26029;&#32447;&#37325;&#36830;&#27169;&#22359;&#10;&#160; &#160; &#160; &#160; _xmppReconnect = [[XMPPReconnect alloc] init];&#10;&#160; &#160; &#160; &#160; [_xmppReconnect setAutoReconnect:YES];&#10;&#160; &#160; &#160; &#160; [_xmppReconnect activate:self.xmppStream];&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#160; &#160; &#160; &#160; //&#25509;&#20837;&#27969;&#31649;&#29702;&#27169;&#22359;&#65292;&#29992;&#20110;&#27969;&#24674;&#22797;&#36319;&#28040;&#24687;&#30830;&#35748;&#65292;&#22312;&#31227;&#21160;&#31471;&#24456;&#37325;&#35201;&#10;&#160; &#160; &#160; &#160; _storage = [XMPPStreamManagementMemoryStorage new];&#10;&#160; &#160; &#160; &#160; _xmppStreamManagement = [[XMPPStreamManagement alloc] initWithStorage:_storage];&#10;&#160; &#160; &#160; &#160; _xmppStreamManagement.autoResume = YES;&#10;&#160; &#160; &#160; &#160; [_xmppStreamManagement addDelegate:self delegateQueue:dispatch_get_main_queue()];&#10;&#160; &#160; &#160; &#160; [_xmppStreamManagement activate:self.xmppStream];&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#160; &#160; &#160; &#160; //&#25509;&#20837;&#22909;&#21451;&#27169;&#22359;&#65292;&#21487;&#20197;&#33719;&#21462;&#22909;&#21451;&#21015;&#34920;&#10;&#160; &#160; &#160; &#160; _xmppRosterMemoryStorage = [[XMPPRosterMemoryStorage alloc] init];&#10;&#160; &#160; &#160; &#160; _xmppRoster = [[XMPPRoster alloc] initWithRosterStorage:_xmppRosterMemoryStorage];&#10;&#160; &#160; &#160; &#160; [_xmppRoster activate:self.xmppStream];&#10;&#160; &#160; &#160; &#160; [_xmppRoster addDelegate:self delegateQueue:dispatch_get_main_queue()];&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#160; &#160; &#160; &#160; //&#25509;&#20837;&#28040;&#24687;&#27169;&#22359;&#65292;&#23558;&#28040;&#24687;&#23384;&#20648;&#21040;&#26412;&#22320;&#10;&#160; &#160; &#160; &#160; _xmppMessageArchivingCoreDataStorage = [XMPPMessageArchivingCoreDataStorage sharedInstance];&#10;&#160; &#160; &#160; &#160; _xmppMessageArchiving = [[XMPPMessageArchiving alloc] initWithMessageArchivingStorage:_xmppMessageArchivingCoreDataStorage dispatchQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 9)];&#10;&#160; &#160; &#160; &#160; [_xmppMessageArchiving activate:self.xmppStream];&#10;&#160; &#160; &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h4><p>xmpp的登陆过程比较繁琐，登陆过程包括初始化流、TLS握手和SASL验证等，想要了解各个阶段服务端跟客户端之间交互的内容可以查看<a href="https://github.com/winterSleep/XMPPBlog/blob/master/1-%E5%BB%BA%E7%AB%8Bsocket%E5%88%B0%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F.md" target="_blank" rel="external">这里</a>，就不在详细介绍。XMPPFramework将整个复杂的登陆过程都封装起来了，客户端调用connectWithTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr连接服务器，然后在xmppStreamDidConnect代理方法输入密码验证登陆，这里我们使用在搭建服务器时创建的两个用户，user1和user2。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define JBXMPP_DOMAIN @&#34;lujiangbin.local&#34;&#10;-(void)loginWithName:(NSString *)userName andPassword:(NSString *)password&#10;&#123;&#10;&#160; &#160; _myJID = [XMPPJID jidWithUser:userName domain:JBXMPP_DOMAIN resource:@&#34;iOS&#34;];&#10;&#160; &#160; self.myPassword = password;&#10;&#160; &#160; [self.xmppStream setMyJID:_myJID];&#10;&#160; &#160; NSError *error = nil;&#10;&#160; &#160; [_xmppStream connectWithTimeout:XMPPStreamTimeoutNone error:&#38;error]&#65307;&#10;&#125;&#10;&#10;#pragma mark -- connect delegate&#10;//&#36755;&#20837;&#23494;&#30721;&#39564;&#35777;&#30331;&#38470;&#10;- (void)xmppStreamDidConnect:(XMPPStream *)sender&#10;&#123;&#10;&#160; &#160; NSError *error = nil;&#10;&#160; &#160;[[self xmppStream] authenticateWithPassword:_myPassword error:&#38;error]&#65307;&#10;&#125;&#10;&#10;//&#30331;&#38470;&#25104;&#21151;&#10;- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender&#10;&#123;&#10;&#160; &#160; NSLog(@&#34;%s&#34;,__func__);&#10;    //&#21457;&#36865;&#22312;&#32447;&#36890;&#30693;&#32473;&#26381;&#21153;&#22120;&#65292;&#26381;&#21153;&#22120;&#25165;&#20250;&#23558;&#31163;&#32447;&#28040;&#24687;&#25512;&#36865;&#36807;&#26469;&#10;    XMPPPresence *presence = [XMPPPresence presence]; // &#40664;&#35748;&#34;available&#34; &#10;&#160; &#160; [[self xmppStream] sendElement:presence];&#10;&#160; &#160; //&#21551;&#29992;&#27969;&#31649;&#29702;&#10;&#160; &#160; [_xmppStreamManagement enableStreamManagementWithResumption:YES maxTimeout:0];&#10;&#125;&#10;//&#30331;&#38470;&#22833;&#36133;&#10;- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error&#10;&#123;&#10;&#160; &#160; NSLog(@&#34;%s&#34;,__func__);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="获取好友列表"><a href="#获取好友列表" class="headerlink" title="获取好友列表"></a>获取好友列表</h4><p>登陆成功之后，我们可以通过XMPPRoster去获取好友列表，在示例中我们为了简单起见使用<br>XMPPRosterMemoryStorage将好友存储在内存中，在实际场景你可以将好友存储在<br>XMPPRosterCoreDataStorage，xmppframework使用coredata将好友保存到本地，可以在初始化xmpp流的时候设置。为了获取好友列表，只需调用fetchRoster方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#33719;&#21462;&#26381;&#21153;&#22120;&#22909;&#21451;&#21015;&#34920;&#10;&#160; &#160; [[[JBXMPPManager sharedInstance] xmppRoster] fetchRoster];</span><br></pre></td></tr></table></figure></p>
<h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><ul>
<li>消息发送<br>只需要调用xmpp的sendElement:方法，由于xmpp只支持文本，所以假如你想发送二进制的文件，比如语音图片等，可以先压缩然后用base64编码，接收方收到再做解码工作，比如语音可以压缩成amr格式，amr格式安卓可以直接播放，iOS需要在解压成wav格式，可以参考<a href="https://github.com/FreeMind-LJ/IMChatDemo" target="_blank" rel="external">demo</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendMessage:(NSString *)message to:(XMPPJID *)jid&#10;&#123;&#10;&#160; &#160; XMPPMessage* newMessage = [[XMPPMessage alloc] initWithType:@&#34;chat&#34; to:jid];&#10;&#160; &#160; [newMessage addBody:message]; //&#28040;&#24687;&#20869;&#23481;&#10;&#160; &#160; [_xmppStream sendElement:newMessage];&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>消息接收<br>当收到消息的时候，xmppframework会调用didReceiveMessage：代理方法，由于我们在初始化流的时候将消息设置存储到本地，可以看到XMPPMessageArchiving在didReceiveMessage收到消息的时候将消息存储起来。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// XMPPMessageArchiving.m&#10;- (void)xmppStream:(XMPPStream *)sender didSendMessage:(XMPPMessage *)message&#10;&#123;&#10;     if ([self shouldArchiveMessage:message outgoing:YES xmppStream:sender])&#10;     &#123;&#10;         [xmppMessageArchivingStorage archiveMessage:message outgoing:YES     xmppStream:sender];&#10;     &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>消息确认<br>为了防止发出去的消息丢失了，可以接入消息回执模块(XEP-184)，这样对方每收到一条消息的时候都会返回一条确认的消息，如果没收到该条确认消息可以认为发送失败，确认消息的格式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> &#160;&#10;&#60;message to=&#34;user2@lujiangbin.local&#34;&#62;&#10;&#160; &#60;received xmlns=&#34;urn:xmpp:receipts&#34; id=&#34;&#28040;&#24687;ID&#34;/&#62;&#10;&#60;/message&#62;</span><br></pre></td></tr></table></figure>
<p>不过这种方法也有些弊端，比如每次收到一条消息都必须回复，一定程度上会浪费流量以及影响服务器的性能，所以一般采用流管理来实现消息确认。</p>
<h4 id="流关闭"><a href="#流关闭" class="headerlink" title="流关闭"></a>流关闭</h4><p>当退出程序的时候，最好能给服务器发送关闭流的通知，也就是发送结束流，服务器收到之后开始将后续发给该对象的消息收集到离线仓库中，当客户端重新上线的时候，服务端会主动将离线消息推送过来，这样不会丢失消息。由于客户端的操作经常是切到后台然后直接关掉程序，因此可以监听UIApplicationWillTerminateNotification消息，然后手动关闭流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillTerminate) name:UIApplicationWillTerminateNotification object:nil];&#10;&#10;#pragma mark -- terminate&#10;/**&#10;&#160;*&#160; &#30003;&#35831;&#21518;&#21488;&#26356;&#22810;&#30340;&#26102;&#38388;&#26469;&#23436;&#25104;&#20851;&#38381;&#27969;&#30340;&#20219;&#21153;&#10;&#160;*/&#10;-(void)applicationWillTerminate&#10;&#123;&#10;&#160; &#160; UIApplication *app=[UIApplication sharedApplication];&#10;&#160; &#160; UIBackgroundTaskIdentifier taskId;&#10;&#160; &#160; taskId=[app beginBackgroundTaskWithExpirationHandler:^(void)&#123;&#10;&#160; &#160; &#160; &#160; [app endBackgroundTask:taskId];&#10;&#160; &#160; &#125;];&#10;&#160; &#160; if(taskId==UIBackgroundTaskInvalid)&#123;&#10;&#160; &#160; &#160; &#160; return;&#10;&#160; &#160; &#125;&#10;&#160; &#160; [_xmppStream disconnectAfterSendingEndStream];&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="流管理"><a href="#流管理" class="headerlink" title="流管理"></a>流管理</h4><p><a href="http://xmpp.org/extensions/xep-0198.html" target="_blank" rel="external">Stream Management</a>是为了流恢复跟节确认而增加的。理想情况下，客户端发送关闭流的通知给服务器，服务器将后续的消息存储到离线仓库，等客户端再登陆上线的时候推送过来，但是在移动端网络可能随时断掉，这时候服务器并不会马上察觉(只能依靠TCP超时或者服务器自己的心跳包)，它会认为对方还在线，将后续的消息发送过去，这样到服务器知道对方掉线的这段时间，期间的消息就丢失了，所以需要流管理来处理。</p>
<ul>
<li>节确认(stanza acknowledgement)<br>用来确认一段时间内节(包括   <iq>    ,<message>,<presence>,不是<iq><br>,<message>,或<presence>这样的stanzas不会在流管理中被确认跟计数的)是否被对方接收，客户端跟服务端都各自有有两个h值用来维护这些信息。从客户端来看，其中一个h值用于记录收到的节，比如当收到服务推送的消息时，会将该h值加1；另一个h值用于记录发出去的节，当发出一条消息时该h值也加1，所以为了确认消息是否被收到其实都是在比较双方的两个h值。<br>为了查询这些h值，xmpp定义了 <a> 和 <r> 两个元素，<r>用户请求节的确认消息，<a>用于回答节的确认消息，必须携带自己已处理的h值。</a></r></r></a></presence></message></iq></presence></message></iq></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#26381;&#21153;&#31471;: &#60;r xmlns=&#39;urn:xmpp:sm:3&#39;/&#62;&#10;&#23458;&#25143;&#31471;: &#60;a xmlns=&#39;urn:xmpp:sm:3&#39; h=&#39;3&#39;/&#62;</span><br></pre></td></tr></table></figure>
<p>比如服务端发送<r>请求，客户端返回自己接受收到的h值（3），然后服务端会根据这个h值跟它自己记录发出去的节的h值做比较，假如小的话会重新发送剩下的节，来防止节丢失。</r></p>
<ul>
<li><p>流恢复<br>由于移动网络可能随时down掉，所以在我们重连上来的时候需要的是快速恢复上一次的流，而不是重新新建一个流，roster的检索以及状态的广播，流管理可以通过上一次的流id（当启用流管理的时候，服务端会生成一个id来表示一个流）以及双方的h值来完成流的快速恢复以及这期间的节确认，发送未被确认的节。</p>
</li>
<li><p>开启流管理<br>要想启用流管理，客户端发送<enable>元素给服务端，服务端返回<enabled>元素表示该流已经被管理了，同时有一个id值来标示这个流，xmppframework开启流管理只需要调用<br>enableStreamManagementWithResumption: maxTimeout:接口：</enabled></enable></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#23458;&#25143;&#31471;: &#60;enable xmlns=&#39;urn:xmpp:sm:3&#39; resume=&#39;true&#39;/&#62;&#10;&#26381;&#21153;&#31471;: &#60;enabled xmlns=&#39;urn:xmpp:sm:3&#39; id=&#39;&#27969;id&#39; resume=&#39;true&#39;/&#62;&#10;&#10;- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender&#10;&#123;&#10;&#160; &#160; //&#30331;&#38470;&#23436;&#25104;&#21518;&#65292;&#21551;&#29992;&#27969;&#31649;&#29702;&#10;&#160; &#160; [_xmppStreamManagement enableStreamManagementWithResumption:YES maxTimeout:0];&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>请求流恢复<br>当客户端想要恢复一个流的时候，需要发送<resume>元素以及一个previd值，也就是想要恢复的上一次的流id，当流可以恢复的时候，服务端会返回<resumed>元素，双方都会携带一个h值用于节确认。</resumed></resume></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#23458;&#25143;&#31471;: &#60;resume xmlns=&#39;urn:xmpp:sm:3&#39; h=&#39;&#23458;&#25143;&#31471;&#25509;&#25910;&#30340;h&#20540;&#39; previd=&#39;&#27969;id&#39;/&#62;&#10;&#26381;&#21153;&#31471;: &#60;resumed xmlns=&#39;urn:xmpp:sm:3&#39; h=&#39;&#26381;&#21153;&#31471;&#25509;&#25910;&#30340;h&#20540;&#39; previd=&#39;&#27969;id&#39;/&#62;</span><br></pre></td></tr></table></figure>
<p>xmppframework将这部分逻辑封装在内部，不过这些h跟流id的值是存储在内存中，当程序退出的时候这些值就没了，也就无法恢复流。所以实际应用的时候需要将这些值保存到本地，比如<a href="https://github.com/FreeMind-LJ/IMChatDemo" target="_blank" rel="external">demo</a>里的XMPPStreamManagementPersistentStorage。</p>
<h4 id="xmpp注意点"><a href="#xmpp注意点" class="headerlink" title="xmpp注意点"></a>xmpp注意点</h4><ul>
<li>文件http上传<br>由于xmpp只支持文本，所以类似音频这种二进制文件需要用base64转成文本形式，但更好的方式是采用http上传文件，消息体保存的是文件对应的URL。</li>
<li>登陆改进<br>xmpp的登陆涉及到始化流、TLS握手和SASL验证等，步骤比较繁琐，可以根据情况简化流程。</li>
<li>TLS加密<br>假如我们的im需要加密，可以开启TLS，不过iOS的TLS<a href="https://dev.ssllabs.com/ssltest/viewClient.html?name=Apple%20ATS&amp;version=9&amp;platform=iOS%209" target="_blank" rel="external">不支持压缩</a>。<br>GCDAsyncSocket内部已经帮我们封装协商的过程，不过我们可能会收到错误：kCFStreamErrorDomainSSL Code=-9807，这是由于服务器证书并不是正式的证书，所以需要手动去认证：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#35774;&#32622;&#25163;&#21160;&#35748;&#35777;&#35777;&#20070;&#10;NSMutableDictionary *settings = [NSMutableDictionary dictionary];&#10;[settings setObject:@YES forKey:GCDAsyncSocketManuallyEvaluateTrust];&#10;[asyncSocket startTLS:settings];&#10;&#10;- (void)socketDidSecure:(GCDAsyncSocket *)sock&#10;&#123;&#10;     // &#24320;&#22987;&#25509;&#25910;&#25968;&#25454;&#10;     [sock readDataWithTimeout:TIMEOUT_XMPP_READ_STREAM tag:TAG_XMPP_READ_STREAM];&#10;&#125;&#10;&#10;//&#22312;delegate&#26041;&#27861;&#20013;&#65292;&#25163;&#21160;&#20449;&#20219;&#10;-(void)xmppStream:(XMPPStream *)sender didReceiveTrust:(SecTrustRef)trust completionHandler:(void (^)(BOOL))completionHandler&#10;&#123;&#10;&#160; &#160; if (completionHandler)&#10;&#160; &#160; &#160; &#160; completionHandler(YES);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的demo工程可以在<a href="https://github.com/FreeMind-LJ/IMChatDemo" target="_blank" rel="external">这里</a>找到。</p>

      
    </div>
    <footer>
      

        
          <div class="alignleft post-nav">
            <em>上一篇: </em><a href="/2015/11/02/NSOperation和NSOperationQueue的一些事儿/">NSOperation和NSOperationQueue的一些事儿</a>
          </div>
        
        
          <div class="alignright post-nav">
            <em>下一篇: </em><a href="/2015/10/08/IM开发-1-ejabberd服务器搭建/">IM开发(1)-ejabberd服务器搭建</a>
          </div>
          <div class="clearfix"></div>
        

        
          <div class="copyright">
            
              <span class="claim">版权声明：自由转载-非商用-保持署名  树下的老男孩</span>
            
            
              <span class="from-link">
                <em>本文链接地址:</em>
                <a href="/2015/10/20/IM开发-2-XMPP-iOS开发/">
                  http://freemind-lj.github.io/2015/10/20/IM开发-2-XMPP-iOS开发/
                </a>
              </span>
            
          </div>
        
        
  
  <div class="categories">
    <a href="/categories/tech/">tech</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/IM/">IM</a>, <a href="/tags/XMPP/">XMPP</a>, <a href="/tags/iOS开发/">iOS开发</a>
  </div>

        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<!-- Duoshuo Comment BEGIN -->
<div class="ds-thread"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name: 'treeboy' };
  (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';
      ds.async = true;
      ds.src = 'http://static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
      || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END -->
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="text" name="q" results="0" placeholder="搜尋">
    <i class="icon-search"></i>
    <input type="hidden" name="q" value="site:freemind-lj.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">標籤</h3>
  <ul class="entry">
  
    <li><a href="/tags/GCD/">GCD</a><small>2</small></li>
  
    <li><a href="/tags/IM/">IM</a><small>2</small></li>
  
    <li><a href="/tags/OGRE/">OGRE</a><small>1</small></li>
  
    <li><a href="/tags/SDWebimage/">SDWebimage</a><small>2</small></li>
  
    <li><a href="/tags/XMPP/">XMPP</a><small>2</small></li>
  
    <li><a href="/tags/charles/">charles</a><small>1</small></li>
  
    <li><a href="/tags/iOS开发/">iOS开发</a><small>16</small></li>
  
    <li><a href="/tags/runtime/">runtime</a><small>3</small></li>
  
    <li><a href="/tags/代码整洁之道/">代码整洁之道</a><small>2</small></li>
  
    <li><a href="/tags/性能优化/">性能优化</a><small>2</small></li>
  
    <li><a href="/tags/测试/">测试</a><small>1</small></li>
  
    <li><a href="/tags/源码剖析/">源码剖析</a><small>1</small></li>
  
    <li><a href="/tags/源码解析/">源码解析</a><small>2</small></li>
  
    <li><a href="/tags/面向对象设计/">面向对象设计</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2016/02/02/iOS应用程序间共享数据/">iOS应用程序间共享数据</a>
      </li>
    
      <li>
        <a href="/2016/01/07/细说-synchronized和dispatch-once/">细说@synchronized和dispatch_once</a>
      </li>
    
      <li>
        <a href="/2015/12/23/谈谈面向对象设计-OOD-原则/">谈谈面向对象设计(OOD)原则</a>
      </li>
    
      <li>
        <a href="/2015/12/16/有意义的命名/">有意义的命名</a>
      </li>
    
      <li>
        <a href="/2015/12/14/整洁代码/">整洁代码</a>
      </li>
    
      <li>
        <a href="/2015/11/24/开源许可证的一些区别/">开源许可证的一些区别</a>
      </li>
    
      <li>
        <a href="/2015/11/20/关于GCD开发的一些事儿/">关于GCD开发的一些事儿</a>
      </li>
    
      <li>
        <a href="/2015/11/02/NSOperation和NSOperationQueue的一些事儿/">NSOperation和NSOperationQueue的一些事儿</a>
      </li>
    
      <li>
        <a href="/2015/10/20/IM开发-2-XMPP-iOS开发/">IM开发(2)-XMPP iOS开发</a>
      </li>
    
      <li>
        <a href="/2015/10/08/IM开发-1-ejabberd服务器搭建/">IM开发(1)-ejabberd服务器搭建</a>
      </li>
    
      <li>
        <a href="/2015/09/09/iOS-app性能优化的那些事-二/">iOS app性能优化的那些事(二)</a>
      </li>
    
      <li>
        <a href="/2015/09/05/iOS-app性能优化的那些事/">iOS app性能优化的那些事</a>
      </li>
    
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <div id="go-pg-top"><i class="icon-arrow-up"></i></div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 树下的老男孩
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/page.js"></script>

</body>

</html>