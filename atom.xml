<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>树下的老男孩</title>
  <subtitle>工匠之行，在行动中体悟修行的乐趣</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://freemind-lj.github.io/"/>
  <updated>2016-02-14T09:41:52.000Z</updated>
  <id>http://freemind-lj.github.io/</id>
  
  <author>
    <name>树下的老男孩</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS应用程序间共享数据</title>
    <link href="http://freemind-lj.github.io/2016/02/02/iOS%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/"/>
    <id>http://freemind-lj.github.io/2016/02/02/iOS应用程序间共享数据/</id>
    <published>2016-02-02T09:39:59.000Z</published>
    <updated>2016-02-14T09:41:52.000Z</updated>
    
    <content type="html">&lt;p&gt;我们知道iOS由于沙盒的存在，应用程序不能越过自己的区域去访问别的存储空间的内容，不过可能有许多场景我们需要在应用程序之间共享数据，比如多个应用共用用户名密码进行登录等。虽然我们不能直接通过文件系统来分享数据，不过还是有些方法可以实现，为了方便说明，这里同时创建了两个工程Example1和Example2，实现这两个app之间的信息共享，Example1负责写数据，Example2负责读数据，具体的demo代码可以到&lt;a href=&quot;https://github.com/FreeMind-LJ/SharedDataDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;获取&lt;/p&gt;
&lt;h4 id=&quot;UIPasteboard&quot;&gt;&lt;a href=&quot;#UIPasteboard&quot; class=&quot;headerlink&quot; title=&quot;UIPasteboard&quot;&gt;&lt;/a&gt;UIPasteboard&lt;/h4&gt;&lt;p&gt;剪贴板是应用程序之间传递数据的简单方式，建议不要使用全局的粘贴板，而是自己根据名字创建一个新的粘贴板，防止其它地方全局拷贝的影响。然后把需要共享的内容复制到粘贴板，粘贴板的内容可以是文本、URL、图片和UIColor等，另一个app就可以根据粘贴板的名字去读取相关的信息。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Example1设置粘贴板的内容:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIPasteboard *pasteboard = [UIPasteboard pasteboardWithName:@&amp;#34;myPasteboard&amp;#34; create:YES];&amp;#10;pasteboard.string = @&amp;#34;myShareData&amp;#34;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example2读取粘贴板的内容:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIPasteboard *pasteboard = [UIPasteboard pasteboardWithName:@&amp;#34;myPasteboard&amp;#34; create:NO];&amp;#10;NSString *content = pasteboard.string;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Custom-URL-Scheme&quot;&gt;&lt;a href=&quot;#Custom-URL-Scheme&quot; class=&quot;headerlink&quot; title=&quot;Custom URL Scheme&quot;&gt;&lt;/a&gt;Custom URL Scheme&lt;/h4&gt;&lt;p&gt;URL Scheme能够让我们通过自定义的协议在应用程序间传递信息，当你想要发送数据给一个实现了自定义URL Scheme的应用时，只需要创建好合适格式的URL，然后调用openURL:方法，系统就会载入注册了该scheme的应用然后将你的URL传递给他，比如如下的代码,todolist是一个其它应用注册的scheme，通过openURL便可以将服务请求发送到该应用（自定义的URL Scheme要能够唯一标示该APP，如果你的URL Scheme跟别人冲突了，那么你的app就不一定会被调起，iOS并不保证调用哪个应用）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSURL *myURL = [NSURL URLWithString:@&amp;#34;todolist://newid=20&amp;#34;];&amp;#10;[[UIApplication sharedApplication] openURL:myURL];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;注册URL Scheme&lt;br&gt;为了能够处理URL请求，我们需要先注册自定义的URL Scheme，只需要在Info tab下的URL Types添加即可，比如我们这里注册Example2的URL Scheme。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-cee0e4ad11ffc587.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;注册URL scheme&quot;&gt;&lt;/p&gt;
&lt;p&gt;Identifier用于标示名称，为了唯一性可以采用反转域名的形式，另外我们设置URL Scheme为Example2，以及role为Viewer(Viewer表示只能读取改URL但不能修改，Editor可以对URL进行读写)，这样Example2就能够接受类似”Example2:\“的URL请求了，可以在浏览器中输入”Example2:\“链接打开app。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理URL请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当有URL请求到来时，所有的URL都会传递给你的app delegate，我们需要实现application:openURL:sourceApplication:annotation:方法来接收处理对应的URL，所以假如你想通过URL方式来传递数据，只需要将数据添加到URL中即可，另外的通过解析该URL来获取对应的数据。&lt;/p&gt;
&lt;p&gt;Eaxmple1发送携带参数的URL到Example2:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *string = @&amp;#34;Example2://name=jiangbin#age=1&amp;#34;;&amp;#10;NSURL *url = [NSURL URLWithString:string];&amp;#10;[[UIApplication sharedApplication] openURL:url];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Example2处理URL请求并解析:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&amp;#10;&amp;#123;&amp;#10;&amp;#160; &amp;#160; if ([[url scheme] isEqualToString:@&amp;#34;Example2&amp;#34;]) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; NSString *content = [url resourceSpecifier];&amp;#10;        //&amp;#35299;&amp;#26512;content&amp;#33719;&amp;#21462;&amp;#25968;&amp;#25454;&amp;#10;        //...&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; return YES;&amp;#10;&amp;#160; &amp;#160; &amp;#125;&amp;#10;&amp;#160; &amp;#160; return NO;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Shared-Keychain-Access&quot;&gt;&lt;a href=&quot;#Shared-Keychain-Access&quot; class=&quot;headerlink&quot; title=&quot;Shared Keychain Access&quot;&gt;&lt;/a&gt;Shared Keychain Access&lt;/h4&gt;&lt;p&gt;iOS的keychain提供一种安全保存信息的方式，可以保存密码等数据，而且keychain中的数据不会因为你删除app而丢失，你可以在重新安装后继续读取keychain中的数据。通常每个应用程序只允许访问自己在keychain中保存的数据，不过假如你使用同一个证书的话，不同的app也可以通过keychain来实现应用间的数据共享。&lt;/p&gt;
&lt;p&gt;为了实现keychain共享数据，我们需要开启Keychain Sharing，开启方法如下，然后添加设置相同的Keychain Group，不过别忘记了添加Security.framework。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-00ce1a0c8ccf752c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;Example1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-33c95673f2c49a7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;Example2&quot;&gt;&lt;/p&gt;
&lt;p&gt;Example1保存数据到keychain(为了简单使用&lt;a href=&quot;https://github.com/soffes/sskeychain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SSKeychian&lt;/a&gt;)&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)setKeyChain&amp;#10;&amp;#123;&amp;#10;    [SSKeychain setPassword:@&amp;#34;shareData&amp;#34; forService:@&amp;#34;myservice&amp;#34; account:@&amp;#34;jiangbin&amp;#34;];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example2读取数据&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (IBAction)getByKeychain:(id)sender&amp;#10;&amp;#123;&amp;#10;    NSString *myData = [SSKeychain passwordForService:@&amp;#34;myservice&amp;#34; account:@&amp;#34;jiangbin&amp;#34;];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;App-Groups&quot;&gt;&lt;a href=&quot;#App-Groups&quot; class=&quot;headerlink&quot; title=&quot;App Groups&quot;&gt;&lt;/a&gt;App Groups&lt;/h4&gt;&lt;p&gt;iOS8之后苹果加入了App Groups功能，应用程序之间可以通过同一个group来共享资源，app group可以通过NSUserDefaults进行小量数据的共享，如果需要共享较大的文件可以通过NSFileCoordinator、NSFilePresenter等方式。&lt;br&gt;开启app groups，需要添加一个group name，app之间通过这个group共享数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-f5aca858ca61a215.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;App Groups&quot;&gt;&lt;br&gt;Example1根据group name设置内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)setAppGroup&amp;#10;&amp;#123;&amp;#10;    NSUserDefaults *myDefaults = [[NSUserDefaults alloc]&amp;#10;                                  initWithSuiteName:@&amp;#34;group.com.jiangbin.SharedData&amp;#34;];&amp;#10;    [myDefaults setObject:@&amp;#34;shared data&amp;#34; forKey:@&amp;#34;mykey&amp;#34;];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example2根据group name读取数据&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)getByAppGroup&amp;#10; &amp;#123;&amp;#10;    NSUserDefaults *myDefaults = [[NSUserDefaults alloc]&amp;#10;                                  initWithSuiteName:@&amp;#34;group.com.jiangbin.SharedData&amp;#34;];&amp;#10;    NSString *content = [myDefaults objectForKey:@&amp;#34;mykey&amp;#34;];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道iOS由于沙盒的存在，应用程序不能越过自己的区域去访问别的存储空间的内容，不过可能有许多场景我们需要在应用程序之间共享数据，比如多个应用共用用户名密码进行登录等。虽然我们不能直接通过文件系统来分享数据，不过还是有些方法可以实现，为了方便说明，这里同时创建了两个工程Example1和Example2，实现这两个app之间的信息共享，Example1负责写数据，Example2负责读数据，具体的demo代码可以到&lt;a href=&quot;https://github.com/FreeMind-LJ/SharedDataDemo&quot;&gt;这里&lt;/a&gt;获取&lt;/p&gt;
&lt;h4 id=&quot;UIPasteboard&quot;&gt;&lt;a href=&quot;#UIPasteboard&quot; class=&quot;headerlink&quot; title=&quot;UIPasteboard&quot;&gt;&lt;/a&gt;UIPasteboard&lt;/h4&gt;&lt;p&gt;剪贴板是应用程序之间传递数据的简单方式，建议不要使用全局的粘贴板，而是自己根据名字创建一个新的粘贴板，防止其它地方全局拷贝的影响。然后把需要共享的内容复制到粘贴板，粘贴板的内容可以是文本、URL、图片和UIColor等，另一个app就可以根据粘贴板的名字去读取相关的信息。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>细说@synchronized和dispatch_once</title>
    <link href="http://freemind-lj.github.io/2016/01/07/%E7%BB%86%E8%AF%B4-synchronized%E5%92%8Cdispatch-once/"/>
    <id>http://freemind-lj.github.io/2016/01/07/细说-synchronized和dispatch-once/</id>
    <published>2016-01-07T09:43:12.000Z</published>
    <updated>2016-02-14T09:46:05.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;工欲善其事&lt;/em&gt;,&lt;em&gt;必先利其器&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  通常我们在实现单例时候都会使用synchronized或者dispatch_once方法，初始化往往是下面的样子：&lt;br&gt;使用synchronized方法实现：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static id obj = nil;&amp;#10;+(instancetype)shareInstance&amp;#10;&amp;#123;&amp;#10;    @synchronized(self) &amp;#123;&amp;#10;        if (!obj) &amp;#123;&amp;#10;            obj = [[SingletonObj alloc] init];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    return obj;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用dispatch_once方法实现：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static id obj = nil;&amp;#10;+(instancetype)shareInstance&amp;#10;&amp;#123;&amp;#10;    static dispatch_once_t onceToken;&amp;#10;    dispatch_once(&amp;#38;onceToken, ^&amp;#123;&amp;#10;        obj = [[SingletonObj alloc] init];&amp;#10;    &amp;#125;);&amp;#10;    return obj;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&quot;性能差异&quot;&gt;&lt;a href=&quot;#性能差异&quot; class=&quot;headerlink&quot; title=&quot;性能差异&quot;&gt;&lt;/a&gt;性能差异&lt;/h5&gt;&lt;p&gt;  上面的这些写法大家应该都很熟悉，既然两种方式都能实现，我们来看看两者的性能差异，这里简单写了个测试的&lt;a href=&quot;https://github.com/FreeMind-LJ/SingletonTest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo&lt;/a&gt;，使用两个方法分单线程跟多线程(采用dispatch_apply方式，性能相对较高)去访问一个单例对象一百万次，对比这期间的耗时，从iPod跟5s测试得到如下的结果&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//ipod&amp;#65292;&amp;#20027;&amp;#32447;&amp;#31243;&amp;#10;   SingletonTest[4285:446820] synchronized time cost:2.202945s&amp;#10;   SingletonTest[4285:446820] dispatch_once time cost:0.761034s&amp;#10;   &amp;#10;   //5s&amp;#65292;&amp;#20027;&amp;#32447;&amp;#31243;&amp;#10;   SingletonTest[5372:2394430] synchronized time cost:0.466293s&amp;#10;   SingletonTest[5372:2394430] dispatch_once time cost:0.070822s&amp;#10;&amp;#10;   //ipod&amp;#65292;&amp;#22810;&amp;#32447;&amp;#31243;&amp;#10;   SingletonTest[4315:448499] synchronized time cost:3.385109s&amp;#10;   SingletonTest[4315:448499] dispatch_once time cost:0.908009s&amp;#10;   &amp;#10;   //5s&amp;#65292;&amp;#22810;&amp;#32447;&amp;#31243;&amp;#10;   SingletonTest[5391:2399069] synchronized time cost:0.507504s&amp;#10;   SingletonTest[5391:2399069] dispatch_once time cost:0.169934s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  可以发现dispatch_once方法的性能要明显优于synchronized方法(多线程不采用dispathc_apply方式差距更明显)，所以在实际的应用中我们可以多采用dispatch_once方式来实现单例。通常使用的时候了解这些就够了，不过想知道两者的具体差异就需要我们再迈进一步。&lt;/p&gt;
&lt;h5 id=&quot;深入-synchronized-object&quot;&gt;&lt;a href=&quot;#深入-synchronized-object&quot; class=&quot;headerlink&quot; title=&quot;深入@synchronized(object)&quot;&gt;&lt;/a&gt;深入@synchronized(object)&lt;/h5&gt;&lt;p&gt;  翻看苹果的&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;可以发现 @synchronized指令内部使用锁来实现多线程的安全访问，并且隐式添加了一个异常处理的handler，当异常发生时会自动释放锁。在&lt;a href=&quot;http://stackoverflow.com/questions/1215330/how-does-synchronized-lock-unlock-in-objective-c/6047218#6047218&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow&lt;/a&gt;上看到@synchronized指令其实可以转换成objc_sync_enter跟objc_sync_exit，可以在&lt;objc objc-sync.h=&quot;&quot;&gt;头文件中找到这两个函数:&lt;/objc&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//Allocates recursive pthread_mutex associated with &amp;#39;obj&amp;#39; if needed&amp;#10;int objc_sync_enter(id obj)&amp;#10;&amp;#10;//End synchronizing on &amp;#39;obj&amp;#39;&amp;#10;int objc_sync_exit(id obj)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  根据注释文档，objc_sync_enter会根据需要给每个传进来的对象创建一个互斥锁并lock，然后objc_sync_exit的时候unlock，这样就可以通过这个锁来实现多线程的安全访问，所以结合苹果文档可以认为&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@synchronized(self) &amp;#123;&amp;#10;&amp;#9;//thread safe code&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等价于&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@try &amp;#123;&amp;#10;    objc_sync_enter(self);&amp;#10;    // thread safe code&amp;#10;&amp;#125; @finally &amp;#123;&amp;#10;    objc_sync_exit(self);    &amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;  庆幸的是苹果已经将objc-runtime这部分开源，所以我们可以更进一步了解内部的实现，源码在&lt;a href=&quot;http://www.opensource.apple.com/source/objc4/objc4-680/runtime/objc-sync.mm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;，有兴趣也可以自己去查阅，这里简单介绍一下。&lt;br&gt;让我们先来看看几个数据结构，其中有些涉及到缓存，我们就不去考虑了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct SyncData &amp;#123;&amp;#10;    struct SyncData* nextData;&amp;#10;    DisguisedPtr&amp;#60;objc_object&amp;#62; object;&amp;#10;    int32_t threadCount;  // number of THREADS using this block&amp;#10;    recursive_mutex_t mutex;&amp;#10;&amp;#125; SyncData;&amp;#10;&amp;#10;struct SyncList &amp;#123;&amp;#10;    SyncData *data;&amp;#10;    spinlock_t lock;&amp;#10;&amp;#125;;&amp;#10;&amp;#10;#define LOCK_FOR_OBJ(obj) sDataLists[obj].lock&amp;#10;#define LIST_FOR_OBJ(obj) sDataLists[obj].data&amp;#10;static StripedMap&amp;#60;SyncList&amp;#62; sDataLists;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;  首先看看SyncData这个数据结构，包含一个指向object的指针，这个object对象就是我们@synchronized时传进来的对象，也包含一个跟object关联的递归互斥锁recursive_mutex_t，该锁用来互斥访问object对象；同时还包含一个指向下一个SyncData的指针nextData，可以看出SyncData是一个链表中的节点；至于threadCount，这个值标示有几个线程正在访问这个对象，当threadCount==0的时候，会重用该SyncData对象，这是为了节省内存。&lt;br&gt;  接下来看看SyncList，SyncList其实就是一个链表，data指向第一个SyncData节点，lock则是为了多线程安全访问该链表。&lt;br&gt;  最后看下sDataLists静态哈希表对象，它以obj的指针为key,对应的value为SyncList链表。&lt;br&gt;  了解上面之后，我们就可以看看objc_sync_enter跟objc_sync_exit的具体实现（摘取部分代码）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#10;//&amp;#26681;&amp;#25454;object&amp;#23545;&amp;#35937;&amp;#21435;&amp;#26597;&amp;#35810;&amp;#30456;&amp;#24212;&amp;#30340;SyncData&amp;#23545;&amp;#35937;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#27809;&amp;#26377;&amp;#21017;&amp;#21019;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#26032;&amp;#30340;&amp;#10;static SyncData* id2data(id object, enum usage why)&amp;#10;&amp;#123;&amp;#10;    spinlock_t *lockp = &amp;#38;LOCK_FOR_OBJ(object);&amp;#10;    SyncData **listp = &amp;#38;LIST_FOR_OBJ(object);&amp;#10;    SyncData* result = NULL;&amp;#10;    &amp;#10;    //lock&amp;#65292;&amp;#22810;&amp;#32447;&amp;#31243;&amp;#23433;&amp;#20840;&amp;#35775;&amp;#38382;SyncList&amp;#10;    lockp-&amp;#62;lock();&amp;#10;    &amp;#123;&amp;#10;        SyncData* p;&amp;#10;        SyncData* firstUnused = NULL;&amp;#10;        for (p = *listp; p != NULL; p = p-&amp;#62;nextData) &amp;#123;&amp;#10;            //&amp;#25214;&amp;#21040;object&amp;#23545;&amp;#35937;&amp;#23545;&amp;#24212;&amp;#30340;SyncData&amp;#23545;&amp;#35937;&amp;#65292;&amp;#22686;&amp;#21152;&amp;#20854;threadCount&amp;#35745;&amp;#25968;&amp;#65292;&amp;#28982;&amp;#21518;&amp;#36820;&amp;#22238;&amp;#10;            if ( p-&amp;#62;object == object ) &amp;#123;&amp;#10;                result = p;&amp;#10;                OSAtomicIncrement32Barrier(&amp;#38;result-&amp;#62;threadCount);&amp;#10;                goto done;&amp;#10;            &amp;#125;&amp;#10;            //&amp;#24403;threadCount == 0&amp;#26102;&amp;#65292;&amp;#35774;&amp;#32622;&amp;#24403;&amp;#21069;SyncData&amp;#20026;&amp;#21487;&amp;#37325;&amp;#29992;&amp;#10;            if ( (firstUnused == NULL) &amp;#38;&amp;#38; (p-&amp;#62;threadCount == 0) )&amp;#10;                firstUnused = p;&amp;#10;        &amp;#125;&amp;#10;        // &amp;#22914;&amp;#26524;&amp;#26377;&amp;#21487;&amp;#37325;&amp;#29992;&amp;#30340;&amp;#33410;&amp;#28857;&amp;#65292;&amp;#21017;&amp;#20351;&amp;#29992;&amp;#24403;&amp;#21069;SyncData&amp;#33410;&amp;#28857;&amp;#65292;SyncData&amp;#30340;object&amp;#25351;&amp;#38024;&amp;#25351;&amp;#21521;&amp;#26032;&amp;#30340;object&amp;#23545;&amp;#35937;&amp;#10;        if ( firstUnused != NULL ) &amp;#123;&amp;#10;            result = firstUnused;&amp;#10;            result-&amp;#62;object = (objc_object *)object;&amp;#10;            result-&amp;#62;threadCount = 1;&amp;#10;            goto done;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    //&amp;#22914;&amp;#26524;&amp;#27809;&amp;#26377;&amp;#21487;&amp;#37325;&amp;#29992;&amp;#30340;&amp;#33410;&amp;#28857;&amp;#65292;&amp;#21017;&amp;#21019;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#26032;&amp;#30340;SyncData&amp;#33410;&amp;#28857;&amp;#10;    result = (SyncData*)calloc(sizeof(SyncData), 1);&amp;#10;&amp;#10;    //&amp;#23558;&amp;#26032;&amp;#30340;SyncData&amp;#33410;&amp;#28857;&amp;#30340;object&amp;#25351;&amp;#38024;&amp;#25351;&amp;#21521;&amp;#20256;&amp;#36827;&amp;#26469;&amp;#30340;object&amp;#23545;&amp;#35937;&amp;#10;    result-&amp;#62;object = (objc_object *)object;&amp;#10;    result-&amp;#62;threadCount = 1;&amp;#10;&amp;#10;    //&amp;#21019;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#26032;&amp;#30340;&amp;#19982;&amp;#35813;object&amp;#20851;&amp;#32852;&amp;#30340;&amp;#36882;&amp;#24402;&amp;#20114;&amp;#26021;&amp;#38145;&amp;#10;    new (&amp;#38;result-&amp;#62;mutex) recursive_mutex_t();&amp;#10;    result-&amp;#62;nextData = *listp;&amp;#10;    *listp = result;&amp;#10;    &amp;#10; done:&amp;#10;    lockp-&amp;#62;unlock();&amp;#10;    return result;&amp;#10;&amp;#125;&amp;#10;&amp;#10;int objc_sync_enter(id obj)&amp;#10;&amp;#123;&amp;#10;    int result = OBJC_SYNC_SUCCESS;&amp;#10;    if (obj) &amp;#123;&amp;#10;        //&amp;#26681;&amp;#25454;obj&amp;#25351;&amp;#38024;&amp;#30340;&amp;#21704;&amp;#24076;&amp;#20540;&amp;#26597;&amp;#25214;&amp;#23545;&amp;#24212;&amp;#30340;SyncData,threadcount&amp;#35745;&amp;#25968;&amp;#21152;&amp;#19968;&amp;#10;        SyncData* data = id2data(obj, ACQUIRE);&amp;#10;&amp;#10;        //&amp;#20351;&amp;#29992;SyncData&amp;#30340;&amp;#20114;&amp;#26021;&amp;#38145;&amp;#19978;&amp;#38145;&amp;#10;        data-&amp;#62;mutex.lock();&amp;#10;    &amp;#125; else &amp;#123;&amp;#10;        // @synchronized(nil) &amp;#20256;&amp;#20837;nil&amp;#26102;&amp;#20160;&amp;#20040;&amp;#20063;&amp;#19981;&amp;#22788;&amp;#29702;&amp;#10;    &amp;#125;&amp;#10;    return result;&amp;#10;&amp;#125;&amp;#10;&amp;#10;int objc_sync_exit(id obj)&amp;#10;&amp;#123;&amp;#10;    int result = OBJC_SYNC_SUCCESS;&amp;#10;    if (obj) &amp;#123;&amp;#10;        //&amp;#26681;&amp;#25454;obj&amp;#25351;&amp;#38024;&amp;#30340;&amp;#21704;&amp;#24076;&amp;#20540;&amp;#26597;&amp;#25214;&amp;#23545;&amp;#24212;&amp;#30340;SyncData&amp;#65292;threadcount&amp;#35745;&amp;#25968;&amp;#20943;&amp;#19968;&amp;#10;        SyncData* data = id2data(obj, RELEASE);&amp;#10;&amp;#10;        //&amp;#20351;&amp;#29992;SyncData&amp;#30340;&amp;#20114;&amp;#26021;&amp;#38145;&amp;#35299;&amp;#38145; &amp;#10;        bool okay = data-&amp;#62;mutex.tryUnlock();&amp;#10;        if (!okay) &amp;#123;&amp;#10;           result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125; else &amp;#123;&amp;#10;        // @synchronized(nil) &amp;#20256;&amp;#20837;nil&amp;#26102;&amp;#20160;&amp;#20040;&amp;#20063;&amp;#19981;&amp;#22788;&amp;#29702;&amp;#10;    &amp;#125;&amp;#10;    return result;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  简单来说，调用objc_sync_enter(obj)时，会根据obj指针在哈希表sDataLists对应的链表SyncList，然后在链表中查询对应obj的SyncData对象，如果查询不到则创建一个新的SyncData对象（包含创建跟obj相关的递归互斥锁）并添加到链表中，然后使用SyncData对象上锁；调用objc_sync_exit(obj)时，使用SyncData对象解锁，因此通过这个锁便可确保@synchronized之间的代码线程安全。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-1c42de5d32202095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600&quot; alt=&quot;sDataLists&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;深入dispatch-once&quot;&gt;&lt;a href=&quot;#深入dispatch-once&quot; class=&quot;headerlink&quot; title=&quot;深入dispatch_once&quot;&gt;&lt;/a&gt;深入dispatch_once&lt;/h5&gt;&lt;p&gt;探讨了synchronized之后，我们再来说说dispatch_once。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;  根据&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/#//apple_ref/c/func/dispatch_once&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;,dispatch_once可以用来初始化一些全局的数据，它能够确保block代码在app的生命周期内仅被运行一次，而且还是线程安全的，不需要额外加锁；predicate必须指向一个全局或者静态的变量，不过使用predicate的话结果是未定义的，不过predicate有啥作用，如何实现block在整个生命周期执行一次？那我们只能从源码查找(源码地址：&lt;a href=&quot;http://opensource.apple.com/source/libdispatch/libdispatch-84.5/src/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;once&lt;/a&gt;)。&lt;br&gt;不过在这之前先简要介绍一下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;bool __sync_bool_compare_and_swap (type &lt;em&gt;ptr, type oldval type newval, …)&lt;br&gt;提供原子的比较和交换操作，如果当前值&lt;/em&gt;ptr == oldval，就将newval写入*ptr，当比较赋值操作成功后返回true&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;*__sync_synchronize (…)&lt;br&gt;调用这个函数会产生一个full &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_barrier&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;memory barrier&lt;/a&gt; ，用于保证CPU按照我们代码编写的顺序来执行代码，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;doJob1();&amp;#10; doJob2();&amp;#10; __sync_synchronize();  //Job3&amp;#20250;&amp;#22312;Job1&amp;#36319;Job2&amp;#23436;&amp;#25104;&amp;#21518;&amp;#25165;&amp;#25191;&amp;#34892;&amp;#10;doJob3();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;type __sync_swap(type *ptr, type value, …)&lt;br&gt;提供原子交换操作的函数，交换第一个跟第二个参数的值，然后返回交换前第一个参数的旧值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;_dispatch_hardware_pause()&lt;br&gt;调用这个函数主要是暗示处理器不要做额外的优化处理等，提高性能，节省CPU时间，可以查看&lt;a href=&quot;http://www.searchtb.com/2011/06/spinlock%E5%89%96%E6%9E%90%E4%B8%8E%E6%94%B9%E8%BF%9B.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;了解更多&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;信号量&lt;br&gt;信号量是一个非负整数，定义了两种原子操作：wait跟signal来进行访，信号量主要用于线程同步。当一个线程调用wait操作时，如果信号量的值大于0，则获得资源并将信号量值减一，如果等于0线程睡眠直到信号量值大于0或者超时；singal将信号量的值加1，如果这时候有正在等待的线程，唤醒该线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#21019;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#65292;&amp;#20854;&amp;#20540;&amp;#20026;0        &amp;#10;dispatch_semaphore_t sema = dispatch_semaphore_create(0);&amp;#10;ABAddressBookRequestAccessWithCompletion(addressBook, ^(bool granted, CFErrorRef error) &amp;#123;&amp;#10;&amp;#9;//&amp;#25805;&amp;#20316;&amp;#23436;&amp;#25104;&amp;#21518;&amp;#65292;&amp;#35843;&amp;#29992;signal&amp;#20449;&amp;#21495;&amp;#37327;+1&amp;#10;    dispatch_semaphore_signal(sema);&amp;#10;&amp;#125;);&amp;#10;//&amp;#31561;&amp;#24453;dispatch_semaphore_signal&amp;#23558;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#20540;&amp;#21152;1&amp;#21518;&amp;#25165;&amp;#32487;&amp;#32493;&amp;#36816;&amp;#34892;&amp;#10;dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  接下来看看具体代码，当我们调用dispatch_once时候，内部是调用dispatch_once_f函数，其中val就是外部传入的predicate值，ctxt为Block的指针，func则是Block内部具体实现的函数指针，由于源码比较短，所以我直接把源码贴出来(为了方便查看，有些不使用宏定义)。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct _dispatch_once_waiter_s &amp;#123;&amp;#10;    volatile struct _dispatch_once_waiter_s *volatile dow_next;&amp;#10;    _dispatch_thread_semaphore_t dow_sema;&amp;#10;&amp;#125;;&amp;#10;#define DISPATCH_ONCE_DONE ((struct _dispatch_once_waiter_s *)~0l)&amp;#10;void dispatch_once(dispatch_once_t *val, dispatch_block_t block)&amp;#10;&amp;#123;&amp;#10;    struct Block_basic *bb = (void *)block;&amp;#10;    dispatch_once_f(val, block, (void *)bb-&amp;#62;Block_invoke);&amp;#10;&amp;#125;&amp;#10;&amp;#10;void dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func)&amp;#10;&amp;#123;&amp;#10;    //volatile&amp;#65292;&amp;#26631;&amp;#31034;&amp;#35813;&amp;#21464;&amp;#37327;&amp;#38543;&amp;#26102;&amp;#21487;&amp;#33021;&amp;#25913;&amp;#21464;&amp;#65292;&amp;#32534;&amp;#35793;&amp;#22120;&amp;#19981;&amp;#20250;&amp;#23545;&amp;#35775;&amp;#38382;&amp;#35813;&amp;#21464;&amp;#37327;&amp;#30340;&amp;#20195;&amp;#30721;&amp;#36827;&amp;#34892;&amp;#20248;&amp;#21270;&amp;#65292;&amp;#27599;&amp;#27425;&amp;#37117;&amp;#20174;&amp;#20869;&amp;#23384;&amp;#21435;&amp;#35835;&amp;#21462;&amp;#65292;&amp;#32780;&amp;#19981;&amp;#20351;&amp;#29992;&amp;#23492;&amp;#23384;&amp;#22120;&amp;#37324;&amp;#30340;&amp;#20540;&amp;#10;    struct _dispatch_once_waiter_s * volatile *vval =&amp;#10;            (struct _dispatch_once_waiter_s**)val;&amp;#10;    struct _dispatch_once_waiter_s dow = &amp;#123; NULL, 0 &amp;#125;;&amp;#10;    struct _dispatch_once_waiter_s *tail, *tmp;&amp;#10;    _dispatch_thread_semaphore_t sema;&amp;#10;&amp;#10;    //&amp;#31532;&amp;#19968;&amp;#27425;&amp;#25191;&amp;#34892;&amp;#30340;&amp;#26102;&amp;#20505;&amp;#65292;predicate&amp;#30340;&amp;#20540;&amp;#20026;0&amp;#65292;&amp;#25152;&amp;#20197;vval&amp;#65309;NULL&amp;#65292;&amp;#21407;&amp;#23376;&amp;#27604;&amp;#36739;&amp;#20132;&amp;#25442;&amp;#20989;&amp;#25968;&amp;#36820;&amp;#22238;true&amp;#10;    //&amp;#28982;&amp;#21518;vval&amp;#25351;&amp;#21521;dow(dispatch_once_waiter_s&amp;#65292;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#30340;&amp;#20540;&amp;#20026;0&amp;#65292;&amp;#21363;&amp;#31561;&amp;#24453;&amp;#20013;)&amp;#10;    if (__sync_bool_compare_and_swap(vval, NULL, &amp;#38;dow)) &amp;#123;&amp;#10;&amp;#10;        //&amp;#31354;&amp;#30340;&amp;#23439;&amp;#23450;&amp;#20041;&amp;#65292;&amp;#21861;&amp;#20063;&amp;#19981;&amp;#20570;&amp;#10;        dispatch_atomic_acquire_barrier();&amp;#10;&amp;#10;        //&amp;#25191;&amp;#34892;dispatch_once&amp;#20256;&amp;#36827;&amp;#26469;&amp;#30340;block&amp;#10;        _dispatch_client_callout(ctxt, func);&amp;#10;        &amp;#10;        //&amp;#21518;&amp;#38754;&amp;#35299;&amp;#37322;&amp;#10;        dispatch_atomic_maximally_synchronizing_barrier();&amp;#10;        &amp;#10;        //&amp;#25191;&amp;#34892;&amp;#23436;block&amp;#20043;&amp;#21518;&amp;#65292;&amp;#23558;vval&amp;#30340;&amp;#20540;&amp;#35774;&amp;#20026;DISPATCH_ONCE_DONE(&amp;#21363;predicate&amp;#35774;&amp;#20026;~0l&amp;#65289;&amp;#10;        tmp = __sync_swap(vval, DISPATCH_ONCE_DONE);  &amp;#10;        tail = &amp;#38;dow;&amp;#10;&amp;#10;        //1.&amp;#22914;&amp;#26524;&amp;#22312;block&amp;#30340;&amp;#25191;&amp;#34892;&amp;#36807;&amp;#31243;&amp;#20013;&amp;#65292;&amp;#27809;&amp;#26377;&amp;#20854;&amp;#32447;&amp;#31243;&amp;#35843;&amp;#29992;&amp;#35813;&amp;#20989;&amp;#25968;&amp;#31561;&amp;#24453;&amp;#65292;tmp&amp;#30340;&amp;#20540;&amp;#20063;&amp;#20026;&amp;#38;dow,tail==tmp&amp;#65292;&amp;#24490;&amp;#29615;&amp;#30340;&amp;#26465;&amp;#20214;&amp;#19981;&amp;#28385;&amp;#36275;&amp;#65292;&amp;#20989;&amp;#25968;&amp;#25191;&amp;#34892;&amp;#23436;&amp;#27605;&amp;#10;        //2.&amp;#22914;&amp;#26524;&amp;#22312;block&amp;#30340;&amp;#25191;&amp;#34892;&amp;#36807;&amp;#31243;&amp;#20013;&amp;#65292;&amp;#26377;&amp;#20854;&amp;#32447;&amp;#31243;&amp;#35843;&amp;#29992;&amp;#35813;&amp;#20989;&amp;#25968;&amp;#31561;&amp;#24453;&amp;#65292;&amp;#21382;&amp;#36941;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#38142;&amp;#34920;&amp;#65292;&amp;#36880;&amp;#20010;&amp;#21796;&amp;#37266;&amp;#32447;&amp;#31243;&amp;#32487;&amp;#32493;&amp;#36816;&amp;#34892;&amp;#10;        while (tail != tmp) &amp;#123;&amp;#10;            //&amp;#22914;&amp;#26524;&amp;#20013;&amp;#36884;&amp;#26377;&amp;#20854;&amp;#23427;&amp;#32447;&amp;#31243;&amp;#23558;vval&amp;#36171;&amp;#20540;&amp;#38;dow&amp;#65292;&amp;#36825;&amp;#26399;&amp;#38388;dow_next&amp;#20540;&amp;#20026;NULL&amp;#65292;&amp;#38656;&amp;#35201;&amp;#31561;&amp;#24453;&amp;#65292;&amp;#21442;&amp;#35265;else&amp;#20998;&amp;#25903;&amp;#30340;__sync_bool_compare_and_swap&amp;#35843;&amp;#29992;&amp;#10;            while (!tmp-&amp;#62;dow_next) &amp;#123;&amp;#10;                _dispatch_hardware_pause();&amp;#10;            &amp;#125;&amp;#10;            sema = tmp-&amp;#62;dow_sema;&amp;#10;            tmp = (struct _dispatch_once_waiter_s*)tmp-&amp;#62;dow_next;&amp;#10;            _dispatch_thread_semaphore_signal(sema);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    else &amp;#10;    &amp;#123;   &amp;#10;        //&amp;#22914;&amp;#26524;vval&amp;#19981;&amp;#31561;NULL&amp;#65292;&amp;#36208;&amp;#36825;&amp;#20010;&amp;#20998;&amp;#25903;&amp;#65292;&amp;#38750;&amp;#31532;&amp;#19968;&amp;#27425;&amp;#35843;&amp;#29992;dispatch_once&amp;#65292;&amp;#20854;&amp;#23427;&amp;#32447;&amp;#31243;&amp;#35843;&amp;#29992;&amp;#10;        //&amp;#33719;&amp;#21462;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#26377;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#21017;&amp;#36820;&amp;#22238;&amp;#35813;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#27809;&amp;#26377;&amp;#21017;&amp;#22312;&amp;#24403;&amp;#21069;&amp;#32447;&amp;#31243;&amp;#21019;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#26032;&amp;#30340;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#10;        dow.dow_sema = _dispatch_get_thread_semaphore();&amp;#10;        for (;;) &amp;#123;&amp;#10;            tmp = *vval;&amp;#10;&amp;#10;            //vval&amp;#24050;&amp;#32463;&amp;#34987;&amp;#36171;&amp;#20540;&amp;#20026;~0l&amp;#65292;&amp;#35777;&amp;#26126;block&amp;#24050;&amp;#32463;&amp;#34987;&amp;#25191;&amp;#34892;&amp;#20102;&amp;#65292;&amp;#36864;&amp;#20986;&amp;#28982;&amp;#21518;&amp;#35843;&amp;#29992;_dispatch_put_thread_semaphore&amp;#38144;&amp;#27585;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#10;            if (tmp == DISPATCH_ONCE_DONE) &amp;#123;&amp;#10;                break;&amp;#10;            &amp;#125;&amp;#10;            //&amp;#31354;&amp;#30340;&amp;#23439;&amp;#23450;&amp;#20041;&amp;#65292;&amp;#21861;&amp;#20063;&amp;#19981;&amp;#20570;&amp;#10;            dispatch_atomic_store_barrier();&amp;#10;&amp;#10;            //&amp;#23558;&amp;#24403;&amp;#21069;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#21152;&amp;#20837;&amp;#21040;&amp;#20449;&amp;#21495;&amp;#38142;&amp;#34920;&amp;#20013;&amp;#65292;&amp;#28982;&amp;#21518;&amp;#32447;&amp;#31243;&amp;#31561;&amp;#24453;&amp;#65292;&amp;#10;            if (__sync_bool_compare_and_swap(vval, tmp, &amp;#38;dow)) &amp;#123;&amp;#10;                dow.dow_next = tmp;&amp;#10;                _dispatch_thread_semaphore_wait(dow.dow_sema);&amp;#10;            &amp;#125;&amp;#10;&amp;#10;            //&amp;#22914;&amp;#26524;vval&amp;#30340;&amp;#25351;&amp;#21521;&amp;#20540;&amp;#19981;&amp;#20877;&amp;#26159;tmp&amp;#65292;&amp;#21487;&amp;#33021;&amp;#20854;&amp;#23427;&amp;#32447;&amp;#31243;&amp;#21516;&amp;#26102;&amp;#36827;&amp;#20837;&amp;#35813;&amp;#20998;&amp;#25903;&amp;#65292;&amp;#28982;&amp;#21518;&amp;#35843;&amp;#29992;__sync_bool_compare_and_swap&amp;#21407;&amp;#23376;&amp;#25805;&amp;#20316;&amp;#23558;vval&amp;#25351;&amp;#21521;&amp;#20102;&amp;#26032;&amp;#30340;&amp;#33410;&amp;#28857;&amp;#65292;&amp;#10;            //&amp;#21017;&amp;#37325;&amp;#26032;&amp;#24320;&amp;#22987;for&amp;#24490;&amp;#29615;&amp;#10;        &amp;#125;&amp;#10;        _dispatch_put_thread_semaphore(dow.dow_sema);&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;让我们来看看dispatch_once是如何确保block只执行一次。简单来说，当线程A在调用执行block并设置predicate为DISPATCH_ONCE_DONE(~0l)期间，如果有其他线程也在调用disptach_once，则这些线程会等待，各线程对应的信号量会加入到信号量链表中，等predicate设置为DISPATCH_ONCE_DONE后，也就是block执行完了，会根据信号量链表唤醒各个线程使其继续执行。&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-2d1119321803ee9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;信号量链表.png&quot;&gt;&lt;br&gt;  不过有一种临界情况，假如线程A在执行block，但是创建单例对象obj还未完成，这时候线程B获取该obj对象，此时obj＝nil，而线程B在线程A将predicate设为DISPATCH_ONCE_DONE之后读取predicate，这是线程B会认为单例对象已经初始化完成，然后使用空的obj对象，这就会导致错误发生。因此dispatch_once会在执行完block之后会执行dispatch_atomic_maximally_synchronizing_barrier()调用，这个调用会执行一些cpuid指令，确保线程A创建单例对象obj以及置predicate为DISPATCH_ONCE_DONE的时间TimeA大于线程B进入block并读取predicate值的时间TimeB。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define dispatch_atomic_maximally_synchronizing_barrier() \&amp;#10;    do &amp;#123; unsigned long _clbr; __asm__ __volatile__( \&amp;#10;    &amp;#34;cpuid&amp;#34; \&amp;#10;    : &amp;#34;=a&amp;#34; (_clbr) : &amp;#34;0&amp;#34; (0) : &amp;#34;ebx&amp;#34;, &amp;#34;ecx&amp;#34;, &amp;#34;edx&amp;#34;, &amp;#34;cc&amp;#34;, &amp;#34;memory&amp;#34; \&amp;#10;    ); &amp;#125; while(0)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;  除此之外，每次调用dispatch_once的时候，都会先判断predicate的值是否是~0l(也就是DISPATCH_ONCE_DONE)，如果是则意味着block已经执行过了，便不再执行，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block);&amp;#10;#ifdef __GNUC__&amp;#10;#define dispatch_once(x, ...) do &amp;#123; if (__builtin_expect(*(x), ~0l) != ~0l) dispatch_once((x), (__VA_ARGS__)); &amp;#125; while (0)&amp;#10;#endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;让我们看看这里面的__builtin_expect((x), (v))，这又是一个优化的地方。。。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__builtin_expect()&amp;#30446;&amp;#30340;&amp;#26159;&amp;#23558;&amp;#8220;&amp;#20998;&amp;#25903;&amp;#36716;&amp;#31227;&amp;#8221;&amp;#30340;&amp;#20449;&amp;#24687;&amp;#25552;&amp;#20379;&amp;#32473;&amp;#32534;&amp;#35793;&amp;#22120;&amp;#65292;&amp;#36825;&amp;#26679;&amp;#32534;&amp;#35793;&amp;#22120;&amp;#21487;&amp;#20197;&amp;#23545;&amp;#20195;&amp;#30721;&amp;#36827;&amp;#34892;&amp;#20248;&amp;#21270;&amp;#65292;&amp;#10;&amp;#20197;&amp;#20943;&amp;#23569;&amp;#25351;&amp;#20196;&amp;#36339;&amp;#36716;&amp;#24102;&amp;#26469;&amp;#30340;&amp;#24615;&amp;#33021;&amp;#19979;&amp;#38477;&amp;#12290;&amp;#10;__builtin_expect((x),1) &amp;#34920;&amp;#31034; x &amp;#30340;&amp;#20540;&amp;#20026;&amp;#30495;&amp;#30340;&amp;#21487;&amp;#33021;&amp;#24615;&amp;#26356;&amp;#22823;&amp;#65307; &amp;#10;__builtin_expect((x),0) &amp;#34920;&amp;#31034; x &amp;#30340;&amp;#20540;&amp;#20026;&amp;#20551;&amp;#30340;&amp;#21487;&amp;#33021;&amp;#24615;&amp;#26356;&amp;#22823;&amp;#12290;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;  由于dispatch_once的只执行block一次，所以我们更期望的是已经block已经执行完了，也就是predict的值为~0l的可能性更大。&lt;br&gt;  现在我们清楚dispatch_once是如何确保block只执行一次了，关键就在predict这个值，通过比较这个值等于0或者~0l来判断block是否执行过，这也就是为啥我们需要将这个值设为static或者全局的缘故，因为各个线程都要去访问这个predict，有兴趣的可以试试把predicate的初始值设为非0或者非静态全局变量会发生什么～～&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h4&gt;&lt;p&gt;  通过上面的分析，我们知道@synchronized采用的是递归互斥锁来实现线程安全，而dispatch_once的内部则使用了很多原子操作来替代锁，以及通过信号量来实现线程同步，而且有很多针对处理器优化的地方，甚至在if判断语句上也做了优化(逼格有点高)，使得其效率有很大的提升，虽然其源码很短，但里面包含的东西却很多，所以苹果也推荐使用dispatch_once来创建单例。通过这个简短的dispatch_once，你也可以清楚为什么GCD的性能会这么高了，感兴趣可以再去看看libdispatch的其它源码。。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.opensource.apple.com/source/objc4/objc4-680/runtime/objc-sync.mm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;objc-sync&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://rykap.com/objective-c/2015/05/09/synchronized.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;synchronized&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/#//apple_ref/c/func/dispatch_once&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dispatch_once&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html#Atomic-Builtins&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Built-in functions for atomic memory access&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://kernelnewbies.org/FAQ/LikelyUnlikely&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;__builtin_expect&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;工欲善其事&lt;/em&gt;,&lt;em&gt;必先利其器&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  通常我们在实现单例时候都会使用synchronized或者dispatch_once方法，初始化往往是下面的样子：&lt;br&gt;使用synchronized方法实现：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static id obj = nil;&amp;#10;+(instancetype)shareInstance&amp;#10;&amp;#123;&amp;#10;    @synchronized(self) &amp;#123;&amp;#10;        if (!obj) &amp;#123;&amp;#10;            obj = [[SingletonObj alloc] init];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    return obj;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用dispatch_once方法实现：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static id obj = nil;&amp;#10;+(instancetype)shareInstance&amp;#10;&amp;#123;&amp;#10;    static dispatch_once_t onceToken;&amp;#10;    dispatch_once(&amp;#38;onceToken, ^&amp;#123;&amp;#10;        obj = [[SingletonObj alloc] init];&amp;#10;    &amp;#125;);&amp;#10;    return obj;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&quot;性能差异&quot;&gt;&lt;a href=&quot;#性能差异&quot; class=&quot;headerlink&quot; title=&quot;性能差异&quot;&gt;&lt;/a&gt;性能差异&lt;/h5&gt;&lt;p&gt;  上面的这些写法大家应该都很熟悉，既然两种方式都能实现，我们来看看两者的性能差异，这里简单写了个测试的&lt;a href=&quot;https://github.com/FreeMind-LJ/SingletonTest&quot;&gt;demo&lt;/a&gt;，使用两个方法分单线程跟多线程(采用dispatch_apply方式，性能相对较高)去访问一个单例对象一百万次，对比这期间的耗时，从iPod跟5s测试得到如下的结果&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码剖析" scheme="http://freemind-lj.github.io/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>谈谈面向对象设计(OOD)原则</title>
    <link href="http://freemind-lj.github.io/2015/12/23/%E8%B0%88%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1-OOD-%E5%8E%9F%E5%88%99/"/>
    <id>http://freemind-lj.github.io/2015/12/23/谈谈面向对象设计-OOD-原则/</id>
    <published>2015-12-23T09:46:39.000Z</published>
    <updated>2016-02-14T10:09:32.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;拥有一把锤子未必能成为建筑师&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  最近在项目开发过程中碰到了一些问题，发现在每波迭代开发过程中，经常需要去修改之前的代码，虽然出现这样的情形很正常，新的需求必然会带来新的功能新的设计，导致之前的代码受到影响。记得看过一个笑话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“杀一个程序员不需要用枪，改三次需求就可以了”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  其实需求设计是一个方面，另外我们作为设计开发人员有时候也需要去反省，反省一下代码的设计是否合理，为什么新功能的在原有代码上扩展会那么难，为什么我们的代码这么不稳定，牵一发而动全身？&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;  我觉得能成为一名程序员，至少不会是一个笨的人，要完成一个功能，总能想办法实现（不然早被开除啦～），但实现的方法思路却有好有坏，不过认为思路可以被引导，软件开发不是才刚开始，它已经存在一段时间，我们可以吸收前人的一些经验教训来提高自己，比如GOF的《设计模式：可复用面向对象软件的基础》，帮我们总结了很多问题的解决思路。这段时间也花了点时间学习面向对象设计的一些思想，也谈谈自己的一些理解。&lt;br&gt;  提到设计模式，我想很多人都看过这块的一些书籍，不过不知道会不会有跟我一样的困惑：看的时候都理解，但是实际开发的时候却无法融入，后面慢慢就忘记了。尴尬，可能我们只是看到了某个模式的表面，而隐藏在模式后面的一些“真理”却没有去挖掘，这个模式是要解决什么问题？其实模式设计的背后都是为了遵循某种设计原则。&lt;/p&gt;
&lt;h4 id=&quot;“比设计模式更重要的是设计原则”&quot;&gt;&lt;a href=&quot;#“比设计模式更重要的是设计原则”&quot; class=&quot;headerlink&quot; title=&quot;“比设计模式更重要的是设计原则”&quot;&gt;&lt;/a&gt;“比设计模式更重要的是设计原则”&lt;/h4&gt;&lt;p&gt;  面相对象设计的概念大家也都知道，它的设计目标就是希望软件系统能做到以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可扩展：新特性能够很容易的添加到现有系统中，不会影响原本的东西&lt;/li&gt;
&lt;li&gt;可修改：当修改某一部分的代码时，不会影响到其它不相关的部分&lt;/li&gt;
&lt;li&gt;可替代：将系统中某部分的代码用其它有相同接口的类替换时，不会影响到现有系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这几个可以用来检测我们的软件系统是不是设计得合理，而如何设计出易于维护和扩展的软件系统是有设计原则可以遵循指导的，&lt;a href=&quot;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Robert C. Martin&lt;/a&gt;提出了面相对象设计的五个基本原则（SOLID）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S－单一职责原则&lt;/li&gt;
&lt;li&gt;O－开放关闭原则&lt;/li&gt;
&lt;li&gt;L－里氏替换原则&lt;/li&gt;
&lt;li&gt;I－接口隔离原则&lt;/li&gt;
&lt;li&gt;D－依赖倒置原则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  我们在进行面相对象设计的时候应该牢记这几个原则，这能让你成为更优秀的设计开发人员－－－至少你的代码不会那么烂，下面来简单了解一下这几个原则。&lt;/p&gt;
&lt;h3 id=&quot;单一职责原则：Single-Responsibility-Principle&quot;&gt;&lt;a href=&quot;#单一职责原则：Single-Responsibility-Principle&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则：Single Responsibility Principle&quot;&gt;&lt;/a&gt;单一职责原则：Single Responsibility Principle&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个类有且仅有一个职责，只有一个引起它变化的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  简单来说一个类只做好一件事就行，不去管跟自己不相干的，狗拿耗子多管闲事，其核心就是解耦以及高内聚。这个原则看着很简单，我们在写代码的时候即便不知道这个原则也会往这个方向靠拢，写出功能相对单一的类，不过这个原则很容易违背，因为可能由于某种原因，原来功能单一的类需要被细化成颗粒更小的职责1跟职责2，所以在每次迭代过程中可能需要重新梳理重构之前编写的代码，将不同的职责封装到不同的类或者模块中。&lt;br&gt;举个栗子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface DataTransfer : NSObject&amp;#10;-(void)upload:(NSData *)data; //&amp;#19978;&amp;#20256;&amp;#25968;&amp;#25454;&amp;#10;-(void)download(NSString*)url;  //&amp;#26681;&amp;#25454;URL&amp;#19979;&amp;#36733;&amp;#19996;&amp;#35199;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  DataTransfer包含上传跟下载功能，仔细考虑可以发现这相当于实现了两个功能，一个负责上传的相关逻辑，另一个负责下载的逻辑，而这个两个功能相对对立，当有一个功能改变的时候，比如我们之前是使用AFNetworking，现在想换成其它第三方或者nsurlconnection来实现上传跟下载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上传方式变更，导致DataTransfer变更&lt;/li&gt;
&lt;li&gt;下载方式变更，导致 DataTransfer变更&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  这就违反了单一职责的原则，所以需要将不同的功能拆解成两个不同的类，来负责各自的职责，不过这个拆的粒度可能因人而已，有时候并不需要拆的过细，不要成了为设计而设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-713b53d08d6de141.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;单一职责&quot;&gt;&lt;br&gt;  在我们项目中经常看到很多违反这条原则的代码，而且违反的比较明显，许多类都是丰富功能的超级集合，整个类变得臃肿难以理解，这时候就需要我们有意识地去重构了。&lt;/p&gt;
&lt;p&gt;###开放关闭原则：Open Closed Principle&lt;br&gt;  开闭原则的定义是说一个软件实体如类，模块和函数应该对扩展开放，而对修改关闭，具体来说就是你应该通过扩展来实现变化，而不是通过修改原有的代码来实现变化，该原则是面相对象设计最基本的原则。&lt;br&gt;  之前说过在项目中每当需求需改的时候经常需要对代码有很大的改动，很大程度上就是因为我们对这个原则理解的不够透彻。&lt;br&gt;  开闭原则的关键在于抽象，我们需要抽象出那些不会变化或者基本不变的东西，这部分东西相对稳定，这也就是对修改关闭的地方（这并不意味着不可以再修改），而对于那些容易变化的部分我们也对其封装，但是这部分是可以动态修改的，这也就是对扩展开发的地方，比如设计模式中的策略模式和模板模式就是在实现这个原则（现在应该对模式有更感性的认识了吧～）。&lt;/p&gt;
&lt;p&gt;  举个例子：我们需要保存对象到数据库当中，其中有个类似save()的保存方法，这部分应该是不变的，接口相对稳定，而具体保存的实现却有可能不同，我们现在可能是保存在Sqlite数据库中，假如以后如果想保存到一个自己实现的数据库中时，我们只需要实现一个拥有同样接口的扩展类添加进去即可，这就是对扩展开放，不会对之前的代码造成任何影响，就可以实现保存到新数据库的功能，保证了系统的稳定性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-45767c7119b61c69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开闭原则&quot;&gt;&lt;br&gt;实现开闭原则的指导思想就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象出相对稳定的接口，这部分应该不改动或者很少改动&lt;/li&gt;
&lt;li&gt;封装变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  不过在软件开发过程中，要一开始就完全按照开闭原则来可能比较困难，更多的情况是在不断的迭代重构过程中去改进，在可预见的变化范围内去做设计。&lt;/p&gt;
&lt;h3 id=&quot;里氏替代原则：Liskov-Substitution-Principle&quot;&gt;&lt;a href=&quot;#里氏替代原则：Liskov-Substitution-Principle&quot; class=&quot;headerlink&quot; title=&quot;里氏替代原则：Liskov Substitution Principle&quot;&gt;&lt;/a&gt;里氏替代原则：Liskov Substitution Principle&lt;/h3&gt;&lt;p&gt;  该原则的定义：所有引用基类的地方必须能透明地使用其子类的对象。简单来说，所有使用基类代码的地方，如果换成子类对象的时候还能够正常运行，则满足这个原则，否则就是继承关系有问题，应该废除两者的继承关系，这个原则可以用来判断我们的对象继承关系是否合理。&lt;br&gt;比如有一个鲸鱼的类，我们让鲸鱼继承于鱼类，然后鱼类有个呼吸的功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-f1c341f4068a3d82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;鲸鱼继承自鱼类&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后在水里的时候，鱼能够进行呼吸：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if(isInwater)&amp;#123;&amp;#10;    //&amp;#22312;&amp;#27700;&amp;#20013;&amp;#20102;&amp;#65292;&amp;#24320;&amp;#22987;&amp;#21628;&amp;#21560;&amp;#10;    fish.breath();&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;  当我们把鲸鱼这个子对象替换原来的基类鱼对象，鲸鱼在水里开始呼吸，这时问题就出现了，鲸鱼是哺乳动物，在水里呼吸是没法呼吸的，一直在水里就GG思密达了，所以这违反了该原则，我们就可以判断鲸鱼继承于鱼类不合理，需要去重新设计。&lt;br&gt;  通常在设计的时候，我们都会优先采用组合而不是继承，因为继承虽然减少了代码，提高了代码的重用性，但是父类跟子类会有很强的耦合性，破坏了封装。&lt;/p&gt;
&lt;h3 id=&quot;接口隔离原则：Interface-Segregation-Principle&quot;&gt;&lt;a href=&quot;#接口隔离原则：Interface-Segregation-Principle&quot; class=&quot;headerlink&quot; title=&quot;接口隔离原则：Interface Segregation Principle&quot;&gt;&lt;/a&gt;接口隔离原则：Interface Segregation Principle&lt;/h3&gt;&lt;p&gt;  该原则的定义：不能强迫用户去依赖那些他们不使用的接口。简单来说就是客户端需要什么接口，就提供给它什么样的接口，其它多余的接口就不要提供，不要让接口变得臃肿，否则当对象一个没有使用的方法被改变了，这个对象也将会受到影响。接口的设计应该遵循最小接口原则，其实这也是高内聚的一种表现，换句话说，使用多个功能单一、高内聚的接口总比使用一个庞大的接口要好。&lt;br&gt;  举个简单的例子：比如我们有个自行车接口，这个接口包含了很多方法，包括GPS定位，以及换挡的方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-6413661553a89ece.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;不满足ISP原则&quot;&gt;&lt;br&gt; 然后我们发现即便普通的自行车也需要实现GPS定位以及换挡的功能，显然这违背了接口隔离的原则。遵循接口最小化的原则，我们重新设计：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-0ae1f5ed465562dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;满足ISP原则&quot;&gt;&lt;br&gt;  这样一来每个接口的功能相对单一，使用多个专门的接口比使用一个总的接口要好，假如我们的山地车没有没有GPS定位的功能，我们不去继承实现对应的接口即可，在iOS开发中有很多这样的例子，比如UITalbleView的代理有两个不同的接口，UITableViewDataSource专门负责需要显示的内容，UITableViewDelegate专门负责一些view的自定义显示，然后我们会继承多个接口，这就满足了ISP原则。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController () &amp;#60;UITableViewDataSource,UITableViewDelegate,OtherProtocol&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;依赖倒置原则：Dependence-Inversion-Principle&quot;&gt;&lt;a href=&quot;#依赖倒置原则：Dependence-Inversion-Principle&quot; class=&quot;headerlink&quot; title=&quot;依赖倒置原则：Dependence Inversion Principle&quot;&gt;&lt;/a&gt;依赖倒置原则：Dependence Inversion Principle&lt;/h3&gt;&lt;p&gt;  该原则的定义：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。其实这就是我们经常说的“针对接口编程”，这里的接口就是抽象，我们应该依赖接口，而不是依赖具体的实现来编程。&lt;br&gt;  如你在Sqlite数据库的基础上开发一套新的数据库系统AWEDatabase，这时候Sqlite相当于底层模块，而你的AWEDatabase就属于高层模块；而从AWEDatabase开发使用者来看，他的业务层就相当于高层模块，而AWEDatabase就变成底层模块了，所以模块的高低应该是从开发者当前的角度来看的，不过DIP原则从不同角度来看它都适合且需要被遵守。假如我们高层模块直接依赖于底层模块，带来的后果是每次底层模块改动，高层模块就会受到影响，整个系统就变得不稳定，这也违反了开放关闭原则。&lt;br&gt;  通常我们会通过引入中间层的方式来解决这个问题，这个中间层相当于一个抽象接口层，高层模块和底层模块都依赖于这个中间层来交互，这样只要中间抽象层保持不变，底层模块改变不会影响到高层模块，这就满足了开放关闭原则；而且假如高层模块跟底层模块同时处于开发阶段，这样有了中间抽象层之后，每个模块都可以针对这个抽象层的接口同时开发，高层模块就不需要等到底层模块开发完毕才能继续了。&lt;br&gt;  比如在我们项目中有涉及IM的功能，现在这个IM模块采用的是XMPP协议来实现，客户端通过这个模块来实现消息的收发，但是假如后面我们想要换成其它协议，比如MQTT等，针对接口编程的话就可以让我们很轻松的实现模块替换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-cbf419fb6dbdaed8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;针对接口编程&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@protocol MessageDelegate &amp;#60;NSObject&amp;#62;&amp;#10;@required&amp;#10;-(void)goOnline;&amp;#10;-(void)sendMessage:(NSString*)content;&amp;#10;@end&amp;#10;&amp;#10;//xmpp&amp;#23454;&amp;#29616;&amp;#10;@interface XMPPMessageCenter &amp;#60;MessageDelegate&amp;#62;&amp;#10;@end&amp;#10;&amp;#10;//MQTT&amp;#23454;&amp;#29616;&amp;#10;@interface MQTTMessageCenter &amp;#60;MessageDelegate&amp;#62;&amp;#10;@end&amp;#10;&amp;#10;//&amp;#19994;&amp;#21153;&amp;#23618;&amp;#10;@interface BussinessLayer&amp;#10;//&amp;#20351;&amp;#29992;&amp;#36981;&amp;#24490;MessageDelegate&amp;#21327;&amp;#35758;&amp;#30340;&amp;#23545;&amp;#35937;&amp;#65292;&amp;#38024;&amp;#23545;&amp;#25509;&amp;#21475;&amp;#32534;&amp;#31243;&amp;#65292;&amp;#20197;&amp;#21518;&amp;#26367;&amp;#25442;&amp;#20063;&amp;#24456;&amp;#26041;&amp;#20415;&amp;#10;@property(nonatomic,strong)id&amp;#60;MessageDelegate&amp;#62; messageCenter;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  当我们在进行面向对象设计的时候应该充分考虑上面这几个原则，一开始可能设计并不完美，不过可以在重构的过程中不断完善。但其实很多人都跳过了设计这个环节，拿到一个模块直接动手编写代码，更不用说去思考设计了，项目中也有很多这样的例子。当然对于简单的模块或许不用什么设计，不过假如模块相对复杂的话，能够在动手写代码之前好好设计思考一下，养成这个习惯，肯定会对编写出可读性、稳定性以及可扩展性较高的代码有帮助。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最关键的软件开发工具是受过良好设计原则训练的思维。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;拥有一把锤子未必能成为建筑师&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  最近在项目开发过程中碰到了一些问题，发现在每波迭代开发过程中，经常需要去修改之前的代码，虽然出现这样的情形很正常，新的需求必然会带来新的功能新的设计，导致之前的代码受到影响。记得看过一个笑话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“杀一个程序员不需要用枪，改三次需求就可以了”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  其实需求设计是一个方面，另外我们作为设计开发人员有时候也需要去反省，反省一下代码的设计是否合理，为什么新功能的在原有代码上扩展会那么难，为什么我们的代码这么不稳定，牵一发而动全身？&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="面向对象设计" scheme="http://freemind-lj.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>有意义的命名</title>
    <link href="http://freemind-lj.github.io/2015/12/16/%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D/"/>
    <id>http://freemind-lj.github.io/2015/12/16/有意义的命名/</id>
    <published>2015-12-16T01:37:01.000Z</published>
    <updated>2016-02-14T10:04:25.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;名副其实：&quot;&gt;&lt;a href=&quot;#名副其实：&quot; class=&quot;headerlink&quot; title=&quot;名副其实：&quot;&gt;&lt;/a&gt;名副其实：&lt;/h3&gt;&lt;p&gt;变量、函数或类的名称就能够说明为什么它存在，做什么事，怎么用，如果需要注释来补充，就不算名副其实:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#28040;&amp;#36893;&amp;#30340;&amp;#26102;&amp;#38388;&amp;#65292;&amp;#20197;&amp;#26085;&amp;#35745;, bad!&amp;#10;int d;&amp;#10;&amp;#10;//good&amp;#10;int daysSinceCreation;&amp;#160;&amp;#10;int daysSinceModification;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;避免误导&quot;&gt;&lt;a href=&quot;#避免误导&quot; class=&quot;headerlink&quot; title=&quot;避免误导&quot;&gt;&lt;/a&gt;避免误导&lt;/h3&gt;&lt;p&gt;避免留下隐藏代码本意的错误线索。&lt;br&gt;accountList  一组账号，如果类型不是List会引起误判，accountGroup或bunchOfAccoutns,甚至accounts，更可怕的例子：使用小些字母l跟字母O作为变量名&lt;/p&gt;
&lt;h3 id=&quot;做有意义的区分&quot;&gt;&lt;a href=&quot;#做有意义的区分&quot; class=&quot;headerlink&quot; title=&quot;做有意义的区分&quot;&gt;&lt;/a&gt;做有意义的区分&lt;/h3&gt;&lt;p&gt;代码是写给人看的,仅仅是满足编译器的要求,就会引起混乱&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以数字系列命名：void copyChars(char a1[],char a2[]) ==&amp;gt; void copyChars(char source[],char destination[])&lt;/li&gt;
&lt;li&gt;说废话： a, an, the, Info, Data&lt;/li&gt;
&lt;li&gt;使用可读的名字：避免过度使用缩写，genymdhms (生成日期，年月日时分秒)&lt;/li&gt;
&lt;li&gt;使用便于搜索的名称：避免使用Magic Number，避免使用单字母,或出现频率极高的短字母组合(注意度的把握)；MAX_CLASSER_PER_STUDENT  跟  “7” “e”&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类名&quot;&gt;&lt;a href=&quot;#类名&quot; class=&quot;headerlink&quot; title=&quot;类名&quot;&gt;&lt;/a&gt;类名&lt;/h3&gt;&lt;p&gt;类名和对象名应该是名词或名词短语，Customer、Account&lt;/p&gt;
&lt;h3 id=&quot;方法名&quot;&gt;&lt;a href=&quot;#方法名&quot; class=&quot;headerlink&quot; title=&quot;方法名&quot;&gt;&lt;/a&gt;方法名&lt;/h3&gt;&lt;p&gt;动词或动词短语：deletePage、save,属性访问、修改和断言：加上get、set和is&lt;/p&gt;
&lt;h3 id=&quot;别装可爱&quot;&gt;&lt;a href=&quot;#别装可爱&quot; class=&quot;headerlink&quot; title=&quot;别装可爱&quot;&gt;&lt;/a&gt;别装可爱&lt;/h3&gt;&lt;p&gt;使用俗语或俚语, eatMyShorts()表示abort()  eatMyShorts：去死吧&lt;/p&gt;
&lt;h3 id=&quot;每个概念对应一个词&quot;&gt;&lt;a href=&quot;#每个概念对应一个词&quot; class=&quot;headerlink&quot; title=&quot;每个概念对应一个词&quot;&gt;&lt;/a&gt;每个概念对应一个词&lt;/h3&gt;&lt;p&gt;给每个抽象概念选一个词，并一以贯之。比如获取数据可以使用fetch、retrive、get这些词语，但最好能够统一使用一种(controller、manager类似)&lt;/p&gt;
&lt;h3 id=&quot;名字尽量来自解决方案领域或问题领域：&quot;&gt;&lt;a href=&quot;#名字尽量来自解决方案领域或问题领域：&quot; class=&quot;headerlink&quot; title=&quot;名字尽量来自解决方案领域或问题领域：&quot;&gt;&lt;/a&gt;名字尽量来自解决方案领域或问题领域：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用解决方案领域名称：使用计算机领域的科学术语、算法名、模式名等。如AccountVisitor：Visitor模式实现的Account类。&lt;/li&gt;
&lt;li&gt;使用问题领域的名称：如果不能用程序员熟悉的术语来命名，就采用所涉问题领域的名称。排序==&amp;gt; sort&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;适当使用有意义的语境：&quot;&gt;&lt;a href=&quot;#适当使用有意义的语境：&quot; class=&quot;headerlink&quot; title=&quot;适当使用有意义的语境：&quot;&gt;&lt;/a&gt;适当使用有意义的语境：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;良好命名的类、函数、名称空间来放置名称，给读者提供语境&lt;/li&gt;
&lt;li&gt;给名称前加前缀：firstName、lastName、street、houseNumber、city、state和zipcode，和在一起知道是地址，孤零零时无法推断， state＝》addrState&lt;/li&gt;
&lt;li&gt;事不过三，如果传递给函数的变量超过三个，考虑封装成概念,添加struct或class&lt;/li&gt;
&lt;li&gt;不要添加没用的语境&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;名副其实：&quot;&gt;&lt;a href=&quot;#名副其实：&quot; class=&quot;headerlink&quot; title=&quot;名副其实：&quot;&gt;&lt;/a&gt;名副其实：&lt;/h3&gt;&lt;p&gt;变量、函数或类的名称就能够说明为什么它存在，做什么事，怎么用，如果需要注释来补充，就不算名副其实:&lt;br&gt;&lt;figu
    
    </summary>
    
      <category term="others" scheme="http://freemind-lj.github.io/categories/others/"/>
    
    
      <category term="代码整洁之道" scheme="http://freemind-lj.github.io/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>整洁代码</title>
    <link href="http://freemind-lj.github.io/2015/12/14/%E6%95%B4%E6%B4%81%E4%BB%A3%E7%A0%81/"/>
    <id>http://freemind-lj.github.io/2015/12/14/整洁代码/</id>
    <published>2015-12-14T07:16:01.000Z</published>
    <updated>2016-02-14T09:57:05.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;为什么要写糟糕的代码？&quot;&gt;&lt;a href=&quot;#为什么要写糟糕的代码？&quot; class=&quot;headerlink&quot; title=&quot;为什么要写糟糕的代码？&quot;&gt;&lt;/a&gt;为什么要写糟糕的代码？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;赶时间完成任务 ，期望后面再清理.&lt;/li&gt;
&lt;li&gt;勒布朗法则：稍后等于永不（Later equals never）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;混乱的代价：&quot;&gt;&lt;a href=&quot;#混乱的代价：&quot; class=&quot;headerlink&quot; title=&quot;混乱的代价：&quot;&gt;&lt;/a&gt;混乱的代价：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;代码变的无法管理，团队生产力下降，&lt;/li&gt;
&lt;li&gt;增加人力？Brooks定律(人月神话)：向进度落后的项目中增加人手，只会使进度更加落后。&lt;/li&gt;
&lt;li&gt;破窗理论：假如原来的代码很优秀，新加入的代码会害怕破坏这美妙的整体而变的更好，反之则不会去在意。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;开始新设计&quot;&gt;&lt;a href=&quot;#开始新设计&quot; class=&quot;headerlink&quot; title=&quot;开始新设计:&quot;&gt;&lt;/a&gt;开始新设计:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;新系统设计与旧系统维护竞赛，时间可持续十年之久，完成时成员早不知去向&lt;/li&gt;
&lt;li&gt;花时间保持代码整洁不但关乎效率，还关乎生存&lt;/li&gt;
&lt;li&gt;制造混乱无助于赶上工期，只会拖累，唯一方法就是始终尽可能保持代码整洁&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是整洁代码？&quot;&gt;&lt;a href=&quot;#什么是整洁代码？&quot; class=&quot;headerlink&quot; title=&quot;什么是整洁代码？&quot;&gt;&lt;/a&gt;什么是整洁代码？&lt;/h2&gt;&lt;h4 id=&quot;Bjarne-stroustrup：&quot;&gt;&lt;a href=&quot;#Bjarne-stroustrup：&quot; class=&quot;headerlink&quot; title=&quot;Bjarne stroustrup：&quot;&gt;&lt;/a&gt;Bjarne stroustrup：&lt;/h4&gt;&lt;p&gt;我喜欢优雅和高效的代码，代码逻辑应直截了当，叫缺陷难以隐藏；尽量减少依赖，使之便于维护；依据某种分成战略完善错误代码处理；性能调至最优，省的引诱别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做好一件事。&lt;/p&gt;
&lt;h4 id=&quot;Michael-Feathers-修改代码的艺术作者-：&quot;&gt;&lt;a href=&quot;#Michael-Feathers-修改代码的艺术作者-：&quot; class=&quot;headerlink&quot; title=&quot;Michael Feathers(修改代码的艺术作者)：&quot;&gt;&lt;/a&gt;Michael Feathers(修改代码的艺术作者)：&lt;/h4&gt;&lt;p&gt;我可以列出我留意到的整洁代码的所有特点，但其中有一条是根本性的。整洁的代码总是看起来像是某位特别在意它的人写的，几乎没有什么改进的余地，代码作者什么都想到了，如果你企图改进它，总会回到原点，赞叹某人留给你的代码———全心头人的某人留下的代码。&lt;/p&gt;
&lt;h4 id=&quot;Ron（c-极限编程探险作者）&quot;&gt;&lt;a href=&quot;#Ron（c-极限编程探险作者）&quot; class=&quot;headerlink&quot; title=&quot;Ron（c#极限编程探险作者）:&quot;&gt;&lt;/a&gt;Ron（c#极限编程探险作者）:&lt;/h4&gt;&lt;p&gt;不要重复的代码（表示某种想法未在代码中得到良好的体现），只做一件事，提早构建简单抽象（在集合中查找某物）&lt;/p&gt;
&lt;h4 id=&quot;美国童子军军规：让营地比你来时更干净。&quot;&gt;&lt;a href=&quot;#美国童子军军规：让营地比你来时更干净。&quot; class=&quot;headerlink&quot; title=&quot;美国童子军军规：让营地比你来时更干净。&quot;&gt;&lt;/a&gt;美国童子军军规：让营地比你来时更干净。&lt;/h4&gt;&lt;p&gt;改好一个变量名，拆分一个过长的函数，消除一点点重复代码&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要写糟糕的代码？&quot;&gt;&lt;a href=&quot;#为什么要写糟糕的代码？&quot; class=&quot;headerlink&quot; title=&quot;为什么要写糟糕的代码？&quot;&gt;&lt;/a&gt;为什么要写糟糕的代码？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;赶时间完成任务 ，期望后面再清理.&lt;/li&gt;
&lt;li&gt;勒
    
    </summary>
    
      <category term="others" scheme="http://freemind-lj.github.io/categories/others/"/>
    
    
      <category term="代码整洁之道" scheme="http://freemind-lj.github.io/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>开源许可证的一些区别</title>
    <link href="http://freemind-lj.github.io/2015/11/24/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/"/>
    <id>http://freemind-lj.github.io/2015/11/24/开源许可证的一些区别/</id>
    <published>2015-11-24T01:49:32.000Z</published>
    <updated>2016-02-14T08:53:10.000Z</updated>
    
    <content type="html">&lt;p&gt;我们在看一些开源项目的时候，一般很少去关注开源的许可证，不过有些时候我们需要对这些证书有一定的了解，一张图胜过千言万语：&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-6480fd9bda587f7a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开源许可证&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我们在看一些开源项目的时候，一般很少去关注开源的许可证，不过有些时候我们需要对这些证书有一定的了解，一张图胜过千言万语：&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-6480fd9bda
    
    </summary>
    
      <category term="others" scheme="http://freemind-lj.github.io/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>关于GCD开发的一些事儿</title>
    <link href="http://freemind-lj.github.io/2015/11/20/%E5%85%B3%E4%BA%8EGCD%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://freemind-lj.github.io/2015/11/20/关于GCD开发的一些事儿/</id>
    <published>2015-11-20T09:58:10.000Z</published>
    <updated>2016-02-14T10:03:30.000Z</updated>
    
    <content type="html">&lt;p&gt;在之前我们介绍过NSOperation的一些东西，这次我们来聊一聊另一个iOS开发最经常使用的技术之一 — GCD，GCD将线程的管理移到系统级别，你只需要定义好要执行的任务，然后丢到合适的Dispatch queue，GCD会负责创建线程来执行你的代码，由于这部分是处于系统级别，所以执行的性能通常非常高。GCD这部分代码苹果已开源，有兴趣的可以去下载了解一下:&lt;a href=&quot;http://libdispatch.macosforge.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;地址&lt;/a&gt;&lt;br&gt;在介绍GCD之前我们先了解一下Quality of Service：&lt;/p&gt;
&lt;h3 id=&quot;Quality-of-Service-QoS&quot;&gt;&lt;a href=&quot;#Quality-of-Service-QoS&quot; class=&quot;headerlink&quot; title=&quot;Quality of Service(QoS)&quot;&gt;&lt;/a&gt;Quality of Service(QoS)&lt;/h3&gt;&lt;p&gt;这是在iOS8之后提供的新功能，苹果提供了几个Quality of Service枚举来使用:user interactive, user initiated, utility 和 background，通过这告诉系统我们在进行什么样的工作，然后系统会通过合理的资源控制来最高效的执行任务代码，其中主要涉及到CPU调度的优先级、IO优先级、任务运行在哪个线程以及运行的顺序等等，我们通过一个抽象的Quality of Service参数来表明任务的意图以及类别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSQualityOfServiceUserInteractive&lt;br&gt;与用户交互的任务，这些任务通常跟UI级别的刷新相关，比如动画，这些任务需要在一瞬间完成&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceUserInitiated&lt;br&gt;由用户发起的并且需要立即得到结果的任务，比如滑动scroll view时去加载数据用于后续cell的显示，这些任务通常跟后续的用户交互相关，在几秒或者更短的时间内完成&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceUtility&lt;br&gt;一些可能需要花点时间的任务，这些任务不需要马上返回结果，比如下载的任务，这些任务可能花费几秒或者几分钟的时间&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceBackground&lt;br&gt;这些任务对用户不可见，比如后台进行备份的操作，这些任务可能需要较长的时间，几分钟甚至几个小时&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceDefault&lt;br&gt;优先级介于user-initiated 和 utility，当没有 QoS信息时默认使用，开发者不应该使用这个值来设置自己的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Qos可以跟GCD queue做个对照：&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-74ed8a8b44ba56e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;对照表&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面我们了解一下GCD的一些用法：&lt;/p&gt;
&lt;h3 id=&quot;Dispatch-Queue&quot;&gt;&lt;a href=&quot;#Dispatch-Queue&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Queue&quot;&gt;&lt;/a&gt;Dispatch Queue&lt;/h3&gt;&lt;p&gt;开发者将需要执行的任务添加到合适的Dispatch Queue中即可，Dispatch Queue会根据任务添加的顺序先到先执行，其中有以下几种队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;main dispatch queue&lt;br&gt;功能跟主线程一样，通过dispatch_get_main_queue()来获取，提交到main queue的任务实际上都是在主线程执行的，所以这是一个串行队列&lt;/li&gt;
&lt;li&gt;&lt;p&gt;global dispatch queues&lt;br&gt;系统给每个应用提供四个全局的并发队列，这四个队列分别有不同的优先级：高、默认、低以及后台，用户不能去创建全局队列，只能根据优先级去获取: &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue ; &amp;#10;queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;user create queue&lt;br&gt;用户可以通过dispatch_queue_create自己创建队列，该函数有两个参数，第一个是队列的名称，在debug的时候方便区分；第二个是队列的一些属性，NULL或者DISPATCH_QUEUE_SERIAL创建出来的队列是串行队列，如果传递DISPATCH_QUEUE_CONCURRENT则为并行队列。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#21019;&amp;#24314;&amp;#24182;&amp;#34892;&amp;#38431;&amp;#21015;&amp;#10;dispatch_queue_t queue;&amp;#10;queue = dispatch_queue_create(&amp;#34;com.example.MyQueue&amp;#34;, DISPATCH_QUEUE_CONCURRENT);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;队列优先级&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;dispatch_queue_create创建队列的优先级跟global dispatch queue的默认优先级一样，假如我们需要设置队列的优先级，可以通过dispatch_queue_attr_make_with_qos_class或者dispatch_set_target_queue方法；&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#25351;&amp;#23450;&amp;#38431;&amp;#21015;&amp;#30340;QoS&amp;#31867;&amp;#21035;&amp;#20026;QOS_CLASS_UTILITY&amp;#10;dispatch_queue_attr_t queue_attr = dispatch_queue_attr_make_with_qos_class (DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY,-1);&amp;#10;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, queue_attr);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;dispatch_set_target_queue的第一个参数为要设置优先级的queue,第二个参数是对应的优先级参照物&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t&amp;#160;serialQueue&amp;#160;=&amp;#160;dispatch_queue_create(&amp;#34;com.example.MyQueue&amp;#34;,NULL);&amp;#160;&amp;#160;&amp;#10;dispatch_queue_t&amp;#160;globalQueue&amp;#160;=&amp;#160;dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);&amp;#160;&amp;#160;&amp;#10;&amp;#160;&amp;#10;//serialQueue&amp;#29616;&amp;#22312;&amp;#30340;&amp;#20248;&amp;#20808;&amp;#32423;&amp;#36319;globalQueue&amp;#30340;&amp;#20248;&amp;#20808;&amp;#32423;&amp;#19968;&amp;#26679;&amp;#10;dispatch_set_target_queue(serialQueue,&amp;#160;globalQueue);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_set_target_queue&lt;br&gt;dispatch_set_target_queue除了能用来设置队列的优先级之外，还能够创建队列的层次体系，当我们想让不同队列中的任务同步的执行时，我们可以创建一个串行队列，然后将这些队列的target指向新创建的队列即可，比如&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-f9e00e6cbc2000c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; alt=&quot;队列体系.png&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t targetQueue = dispatch_queue_create(&amp;#34;target_queue&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;dispatch_queue_t queue1 = dispatch_queue_create(&amp;#34;queue1&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;dispatch_queue_t queue2 = dispatch_queue_create(&amp;#34;queue2&amp;#34;, DISPATCH_QUEUE_CONCURRENT);&amp;#10;dispatch_set_target_queue(queue1, targetQueue);&amp;#10;dispatch_set_target_queue(queue2, targetQueue);&amp;#10;&amp;#160; dispatch_async(queue1, ^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; NSLog(@&amp;#34;do job1&amp;#34;);&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [NSThread sleepForTimeInterval:3.f];&amp;#10;&amp;#160; &amp;#160; &amp;#125;);&amp;#10;&amp;#160; dispatch_async(queue2, ^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; NSLog(@&amp;#34;do job2&amp;#34;);&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [NSThread sleepForTimeInterval:2.f];&amp;#10;&amp;#160; &amp;#160; &amp;#125;);&amp;#10;&amp;#160; dispatch_async(queue2, ^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; NSLog(@&amp;#34;do job3&amp;#34;);&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [NSThread sleepForTimeInterval:1.f];&amp;#10;&amp;#160; &amp;#160; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到执行的结果如下，这些队列会同步的执行任务。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[13323:569147] do job1&amp;#10;GCDTests[13323:569147] do job2&amp;#10;GCDTests[13323:569147] do job3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_barrier_async&lt;br&gt;dispatch_barrier_async用于等待前面的任务执行完毕后自己才执行，而它后面的任务需等待它完成之后才执行。一个典型的例子就是数据的读写，通常为了防止文件读写导致冲突，我们会创建一个串行的队列，所有的文件操作都是通过这个队列来执行，比如FMDB，这样就可以避免读写冲突。不过其实这样效率是有提升的空间的，当没有更新数据时，读操作其实是可以并行进行的，而写操作需要串行的执行，如何实现呢：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;Database_Queue&amp;#34;, DISPATCH_QUEUE_CONCURRENT);&amp;#10;    &amp;#10;    dispatch_async(queue, ^&amp;#123;&amp;#10;        NSLog(@&amp;#34;reading data1&amp;#34;);&amp;#10;    &amp;#125;);&amp;#10;    dispatch_async(queue, ^&amp;#123;&amp;#10;        NSLog(@&amp;#34;reading data2&amp;#34;);&amp;#10;    &amp;#125;);&amp;#10;    dispatch_barrier_async(queue, ^&amp;#123;&amp;#10;        NSLog(@&amp;#34;writing data1&amp;#34;);&amp;#10;        [NSThread sleepForTimeInterval:1];&amp;#10;        &amp;#10;    &amp;#125;);&amp;#10;    dispatch_async(queue, ^&amp;#123;&amp;#10;        [NSThread sleepForTimeInterval:1];&amp;#10;        NSLog(@&amp;#34;reading data3&amp;#34;);&amp;#10;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行结果如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[13360:584316] reading data2&amp;#10;GCDTests[13360:584317] reading data1&amp;#10;GCDTests[13360:584317] writing data1&amp;#10;GCDTests[13360:584317] reading data3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们将写数据的操作放在dispatch_barrier_async中，这样能确保在写数据的时候会等待前面的读操作完成，而后续的读操作也会等到写操作完成后才能继续执行，提高文件读写的执行效率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_queue_set_specific 、dispatch_get_specific&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个API类似于objc_setAssociatedObject跟objc_getAssociatedObject，FMDB里就用到这个来防止死锁，来看看FMDB的部分源码&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static const void * const kDispatchQueueSpecificKey = &amp;#38;kDispatchQueueSpecificKey;&amp;#10;//&amp;#21019;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#20018;&amp;#34892;&amp;#38431;&amp;#21015;&amp;#26469;&amp;#25191;&amp;#34892;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#30340;&amp;#25152;&amp;#26377;&amp;#25805;&amp;#20316;&amp;#10; _queue = dispatch_queue_create([[NSString stringWithFormat:@&amp;#34;fmdb.%@&amp;#34;, self] UTF8String], NULL);&amp;#10;&amp;#10; //&amp;#36890;&amp;#36807;key&amp;#26631;&amp;#31034;&amp;#38431;&amp;#21015;&amp;#65292;&amp;#35774;&amp;#32622;context&amp;#20026;self&amp;#10; dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当要执行数据库操作时，如果在queue里面的block执行过程中，又调用了 indatabase方法，需要检查是不是同一个queue，因为同一个queue的话会产生死锁情况&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)inDatabase:(void (^)(FMDatabase *db))block &amp;#123;&amp;#10;    FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);&amp;#10;    assert(currentSyncQueue != self &amp;#38;&amp;#38; &amp;#34;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&amp;#34;);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_apply&lt;br&gt;dispatch_apply类似一个for循环，会在指定的dispatch queue中运行block任务n次，如果队列是并发队列，则会并发执行block任务，dispatch_apply是一个同步调用，block任务执行n次后才返回。&lt;br&gt;简单的使用方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;myqueue&amp;#34;, DISPATCH_QUEUE_CONCURRENT);&amp;#10;//&amp;#24182;&amp;#21457;&amp;#30340;&amp;#36816;&amp;#34892;&amp;#19968;&amp;#20010;block&amp;#20219;&amp;#21153;5&amp;#27425;&amp;#10;dispatch_apply(5, queue, ^(size_t i) &amp;#123;&amp;#10;    NSLog(@&amp;#34;do a job %zu times&amp;#34;,i+1);&amp;#10;&amp;#125;);&amp;#10;NSLog(@&amp;#34;go on&amp;#34;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[10029:760640] do a job 2 times&amp;#10;GCDTests[10029:760640] do a job 1 times&amp;#10;GCDTests[10029:760640] do a job 3 times&amp;#10;GCDTests[10029:760640] do a job 5 times&amp;#10;GCDTests[10029:760640] do a job 4 times&amp;#10;GCDTests[10029:760640] go on&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在某些场景下使用dispatch_apply会对性能有很大的提升，比如你的代码需要以每个像素为基准来处理计算image图片。同时dispatch apply能够避免一些线程爆炸的情况发生（创建很多线程）&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#21361;&amp;#38505;&amp;#65292;&amp;#21487;&amp;#33021;&amp;#23548;&amp;#33268;&amp;#32447;&amp;#31243;&amp;#29190;&amp;#28856;&amp;#20197;&amp;#21450;&amp;#27515;&amp;#38145;&amp;#10;for (int i = 0; i &amp;#60; 999; i++)&amp;#123;&amp;#10;   dispatch_async(q, ^&amp;#123;...&amp;#125;);&amp;#10;&amp;#125;&amp;#10;dispatch_barrier_sync(q, ^&amp;#123;&amp;#125;);&amp;#10;&amp;#10;// &amp;#36739;&amp;#20248;&amp;#36873;&amp;#25321;&amp;#65292; GCD &amp;#20250;&amp;#31649;&amp;#29702;&amp;#24182;&amp;#21457;&amp;#10;dispatch_apply(999, q, ^(size_t i)&amp;#123;...&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Dispatch-Block&quot;&gt;&lt;a href=&quot;#Dispatch-Block&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Block&quot;&gt;&lt;/a&gt;Dispatch Block&lt;/h4&gt;&lt;p&gt;添加到gcd队列中执行的任务是以block的形式添加的，block封装了需要执行功能，block带来的开发效率提升就不说了，gcd跟block可以说是一对好基友，能够很好的配合使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建block&lt;br&gt;我们可以自己创建block并添加到queue中去执行&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;//&amp;#21019;&amp;#24314;block&amp;#10;dispatch_block_t block = dispatch_block_create(0, ^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; NSLog(@&amp;#34;do something&amp;#34;);&amp;#10;&amp;#160; &amp;#160; &amp;#125;);&amp;#10;dispatch_async(queue, block);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在创建block的时候我们也可以通过设置QoS，指定block对应的优先级，在dispatch_block_create_with_qos_class中指定QoS类别即可：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;dispatch_block_t block = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INITIATED, -1, ^&amp;#123;&amp;#10;        NSLog(@&amp;#34;do something with QoS&amp;#34;);&amp;#10;    &amp;#125;);&amp;#10;dispatch_async(queue, block);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_block_wait&lt;br&gt;当需要等待前面的任务执行完毕时，我们可以使用dispatch_block_wait这个接口，设置等待时间DISPATCH_TIME_FOREVER会一直等待直到前面的任务完成：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;dispatch_block_t block = dispatch_block_create(0, ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;before sleep&amp;#34;);&amp;#10;    [NSThread sleepForTimeInterval:1];&amp;#10;    NSLog(@&amp;#34;after sleep&amp;#34;);&amp;#10;&amp;#125;);&amp;#10;dispatch_async(queue, block);&amp;#10;//&amp;#31561;&amp;#24453;&amp;#21069;&amp;#38754;&amp;#30340;&amp;#20219;&amp;#21153;&amp;#25191;&amp;#34892;&amp;#23436;&amp;#27605;&amp;#10;dispatch_block_wait(block, DISPATCH_TIME_FOREVER);&amp;#10;NSLog(@&amp;#34;coutinue&amp;#34;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;程序运行结果:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[16679:863641] before sleep&amp;#10;GCDTests[16679:863641] after sleep&amp;#10;GCDTests[16679:863529] coutinue&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_block_notify&lt;br&gt;dispatch_block_notify当观察的某个block执行结束之后立刻通知提交另一特定的block到指定的queue中执行，该函数有三个参数，第一参数是需要观察的block，第二个参数是被通知block提交执行的queue，第三参数是当需要被通知执行的block，函数的原型:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void dispatch_block_notify(dispatch_block_t block, dispatch_queue_t queue,&amp;#10;&amp;#9;&amp;#9;dispatch_block_t notification_block);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体使用的方法:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;dispatch_block_t previousBlock = dispatch_block_create(0, ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;previousBlock begin&amp;#34;);&amp;#10;    [NSThread sleepForTimeInterval:1];&amp;#10;    NSLog(@&amp;#34;previousBlock done&amp;#34;);&amp;#10;&amp;#125;);&amp;#10;dispatch_async(queue, previousBlock);&amp;#10;dispatch_block_t notifyBlock = dispatch_block_create(0, ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;notifyBlock&amp;#34;);&amp;#10;&amp;#125;);&amp;#10;//&amp;#24403;previousBlock&amp;#25191;&amp;#34892;&amp;#23436;&amp;#27605;&amp;#21518;&amp;#65292;&amp;#25552;&amp;#20132;notifyBlock&amp;#21040;global queue&amp;#20013;&amp;#25191;&amp;#34892;&amp;#10;dispatch_block_notify(previousBlock, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), notifyBlock);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行结果：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[17129:895673] previousBlock begin&amp;#10;GCDTests[17129:895673] previousBlock done&amp;#10;GCDTests[17129:895673] notifyBlock&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_block_cancel&lt;br&gt;之前在介绍nsopreration的时候提到它的一个优点是可以取消某个operation，现在在iOS8之后，提交到gcd队列中的dispatch block也可取消了，只需要简单的调用dispatch_block_cancel传入想要取消的block即可:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;dispatch_block_t block1 = dispatch_block_create(0, ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;block1 begin&amp;#34;);&amp;#10;    [NSThread sleepForTimeInterval:1];&amp;#10;    NSLog(@&amp;#34;block1 done&amp;#34;);&amp;#10;&amp;#125;);&amp;#10;dispatch_block_t block2 = dispatch_block_create(0, ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;block2 &amp;#34;);&amp;#10;&amp;#125;);&amp;#10;dispatch_async(queue, block1);&amp;#10;dispatch_async(queue, block2);&amp;#10;dispatch_block_cancel(block2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到如下的执行结果，block2不再执行了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[17271:902981] block1 begin&amp;#10;GCDTests[17271:902981] block1 done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Dispatch-Group&quot;&gt;&lt;a href=&quot;#Dispatch-Group&quot; class=&quot;headerlink&quot; title=&quot;# Dispatch Group&quot;&gt;&lt;/a&gt;# Dispatch Group&lt;/h3&gt;&lt;p&gt;当我们想在gcd queue中所有的任务执行完毕之后做些特定事情的时候，也就是队列的同步问题，如果队列是串行的话，那将该操作最后添加到队列中即可，但如果队列是并行队列的话，这时候就可以利用dispatch_group来实现了，dispatch_group能很方便的解决同步的问题。dispatch_group_create可以创建一个group对象，然后可以添加block到该组里面，下面看下它的一些用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_group_wait&lt;br&gt;dispatch_group_wait会同步地等待group中所有的block执行完毕后才继续执行,类似于dispatch barrier&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, DISPATCH_QUEUE_CONCURRENT);&amp;#10;dispatch_group_t group = dispatch_group_create();&amp;#10;//&amp;#23558;&amp;#20219;&amp;#21153;&amp;#24322;&amp;#27493;&amp;#22320;&amp;#28155;&amp;#21152;&amp;#21040;group&amp;#20013;&amp;#21435;&amp;#25191;&amp;#34892;&amp;#10;dispatch_group_async(group,queue,^&amp;#123; NSLog(@&amp;#34;block1&amp;#34;); &amp;#125;);&amp;#10;dispatch_group_async(group,queue,^&amp;#123; NSLog(@&amp;#34;block2&amp;#34;); &amp;#125;);&amp;#10;dispatch_group_wait(group,DISPATCH_TIME_FOREVER);&amp;#10;NSLog(@&amp;#34;go on&amp;#34;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行结果如下，只有block1跟block2执行完毕后才会执行dispatch_group_wait后面的内容。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[954:41031] block2&amp;#10;GCDTests[954:41032] block1&amp;#10;GCDTests[954:40847] go on&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_group_notify&lt;br&gt;功能与dispatch_group_wait类似，不过该过程是异步的，不会阻塞该线程，dispatch_group_notify有三个参数&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void dispatch_group_notify(dispatch_group_t group, //&amp;#35201;&amp;#35266;&amp;#23519;&amp;#30340;group&amp;#10;                           dispatch_queue_t queue,   //block&amp;#25191;&amp;#34892;&amp;#30340;&amp;#38431;&amp;#21015;&amp;#10;                           dispatch_block_t block);   //&amp;#24403;group&amp;#20013;&amp;#25152;&amp;#26377;&amp;#20219;&amp;#21153;&amp;#25191;&amp;#34892;&amp;#23436;&amp;#27605;&amp;#20043;&amp;#21518;&amp;#35201;&amp;#25191;&amp;#34892;&amp;#30340;block&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单的示意用法:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, DISPATCH_QUEUE_CONCURRENT);&amp;#10;dispatch_group_t group = dispatch_group_create();&amp;#10;dispatch_group_async(group,queue,^&amp;#123; NSLog(@&amp;#34;block1&amp;#34;); &amp;#125;);&amp;#10;dispatch_group_async(group,queue,^&amp;#123; NSLog(@&amp;#34;block2&amp;#34;); &amp;#125;);&amp;#10;dispatch_group_notify(group, dispatch_get_main_queue(), ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;done&amp;#34;);&amp;#10;&amp;#125;);&amp;#10;NSLog(@&amp;#34;go on&amp;#34;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到如下的执行结果&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[1046:45104] go on&amp;#10;GCDTests[1046:45153] block1&amp;#10;GCDTests[1046:45152] block2&amp;#10;GCDTests[1046:45104] done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_group_enter dispatch_group_leave&lt;br&gt;假如我们不想使用dispatch_group_async异步的将任务丢到group中去执行，这时候就需要用到dispatch_group_enter跟dispatch_group_leave方法，这两个方法要配对出现，以下这两种方法是等价的：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(group, queue, ^&amp;#123; &amp;#10;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等价于&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_enter(group);&amp;#10;dispatch_async(queue, ^&amp;#123;&amp;#10;&amp;#12288;&amp;#12288;dispatch_group_leave(group);&amp;#10;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;简单的使用方法，可以自己试试没有写dispatch_group_leave会发生什么。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_t group = dispatch_group_create();&amp;#10;for (int i =0 ; i&amp;#60;3; i++) &amp;#123;&amp;#10;    dispatch_group_enter(group);&amp;#10;    NSLog(@&amp;#34;do block:%d&amp;#34;,i);&amp;#10;    dispatch_group_leave(group);&amp;#10;&amp;#125;&amp;#10;//&amp;#31561;&amp;#24453;&amp;#19978;&amp;#38754;&amp;#30340;&amp;#20219;&amp;#21153;&amp;#23436;&amp;#25104;&amp;#10;dispatch_group_wait(group, DISPATCH_TIME_FOREVER);&amp;#10;NSLog(@&amp;#34;go on&amp;#34;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Dispatch-Semaphore&quot;&gt;&lt;a href=&quot;#Dispatch-Semaphore&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Semaphore&quot;&gt;&lt;/a&gt;Dispatch Semaphore&lt;/h4&gt;&lt;p&gt;dispatch semaphore也是用来做解决一些同步的问题，dispatch_semaphore_create会创建一个信号量，该函数需要传递一个信号值，dispatch_semaphore_signal会使信号值加1，如果信号值的大小等于1，dispatch_semaphore_wait会使信号值减1，并继续往下走，如果信号值为0，则等待。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#21019;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#65292;&amp;#21021;&amp;#22987;&amp;#20540;&amp;#20026;0&amp;#10;dispatch_semaphore_t sema = dispatch_semaphore_create(0);&amp;#10;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;do some job&amp;#34;);&amp;#10;    sleep(1);&amp;#10;    NSLog(@&amp;#34;increase the semaphore&amp;#34;);&amp;#10;    dispatch_semaphore_signal(sema); //&amp;#20449;&amp;#21495;&amp;#20540;&amp;#21152;1&amp;#10;&amp;#125;);&amp;#10;dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);//&amp;#31561;&amp;#24453;&amp;#30452;&amp;#21040;&amp;#20449;&amp;#21495;&amp;#20540;&amp;#22823;&amp;#20110;&amp;#31561;1&amp;#10;NSLog(@&amp;#34;go on&amp;#34;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;执行结果如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[1394:92383] do some job&amp;#10;GCDTests[1394:92383] increase the semaphore&amp;#10;GCDTests[1394:92326] go on&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Dispatch-Timer&quot;&gt;&lt;a href=&quot;#Dispatch-Timer&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Timer&quot;&gt;&lt;/a&gt;Dispatch Timer&lt;/h4&gt;&lt;p&gt;dispatch timer通常配合dispatch_after使用，完成一些延时的任务：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#24310;&amp;#36831;5&amp;#31186;&amp;#21518;&amp;#25191;&amp;#34892;&amp;#20219;&amp;#21153;&amp;#10;dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC));&amp;#10;dispatch_after(time, dispatch_get_main_queue(), ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;do job afer 5 seconds&amp;#34;);&amp;#10;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Dispatch-IO&quot;&gt;&lt;a href=&quot;#Dispatch-IO&quot; class=&quot;headerlink&quot; title=&quot;Dispatch IO&quot;&gt;&lt;/a&gt;Dispatch IO&lt;/h4&gt;&lt;p&gt;当我们要读取一份较大文件的时候，多个线程同时去读肯定比一个线程去读的速度要快，要实现这样的功能可以通过dispatch io跟dispatch data来实现，通过dispatch io去读文件时，会使用global dispatch queue将一个文件按照一个指定的分块大小同时去读取数据，类似于：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(queue, ^&amp;#123;/* &amp;#35835;&amp;#21462;0-99&amp;#23383;&amp;#33410; */&amp;#125;);&amp;#10;dispatch_async(queue, ^&amp;#123;/* &amp;#35835;&amp;#21462;100-199&amp;#23383;&amp;#33410; */&amp;#125;);&amp;#10;dispatch_async(queue, ^&amp;#123;/* &amp;#35835;&amp;#21462;200-299&amp;#23383;&amp;#33410; */&amp;#125;);&amp;#10;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将文件分成一块一块并行的去读取，读取的数据通过Dispatch Data可以更为简单地进行结合和分割 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_io_create&lt;br&gt;生成Dispatch IO,指定发生错误时用来执行处理的Block,以及执行该Block的Dispatch Queue&lt;/li&gt;
&lt;li&gt;dispatch_io_set_low_water&lt;br&gt;设定一次读取的大小（分割的大小）&lt;/li&gt;
&lt;li&gt;dispatch_io_read&lt;br&gt;使用Global Dispatch Queue开始并列读取，当每个分割的文件块读取完毕时，会将含有文件数据的dispatch data返回到dispatch_io_read设定的block，在block中需要分析传递过来的dispatch data进行合并处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看下苹果的系统日志API(Libc-763.11 gen/asl.c)的源代码使用到了dispatch IO：&lt;a href=&quot;https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码地址&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#10;//dispatch_io_create&amp;#20986;&amp;#38169;&amp;#26102;handler&amp;#25191;&amp;#34892;&amp;#30340;&amp;#38431;&amp;#21015;&amp;#10;pipe_q = dispatch_queue_create(&amp;#34;PipeQ&amp;#34;, NULL);&amp;#10;pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM, fd, pipe_q, ^(int err)&amp;#123;&amp;#10;&amp;#9;//&amp;#20986;&amp;#38169;&amp;#26102;&amp;#25191;&amp;#34892;&amp;#30340;handler&amp;#10;&amp;#9;close(fd);&amp;#10;&amp;#125;);&amp;#10;*out_fd = fdpair[1];&amp;#10;&amp;#10;//&amp;#35774;&amp;#23450;&amp;#19968;&amp;#27425;&amp;#35835;&amp;#21462;&amp;#30340;&amp;#22823;&amp;#23567;(&amp;#20998;&amp;#21106;&amp;#22823;&amp;#23567;)&amp;#10;dispatch_io_set_low_water(pipe_channel, SIZE_MAX);&amp;#10;dispatch_io_read(pipe_channel, 0, SIZE_MAX, pipe_q, ^(bool done, dispatch_data_t pipedata, int err)&amp;#123;&amp;#10;&amp;#9;if (error)&amp;#10;&amp;#9;&amp;#9;return;&amp;#10;&amp;#9;if (err == 0)&amp;#10;&amp;#9;&amp;#123;&amp;#10;&amp;#9;&amp;#9;//&amp;#27599;&amp;#27425;&amp;#35835;&amp;#21462;&amp;#21040;&amp;#25968;&amp;#25454;&amp;#36827;&amp;#34892;&amp;#25968;&amp;#25454;&amp;#30340;&amp;#22788;&amp;#29702;&amp;#10;&amp;#9;&amp;#9;size_t len = dispatch_data_get_size(pipedata);&amp;#10;&amp;#9;&amp;#9;if (len &amp;#62; 0)&amp;#10;&amp;#9;&amp;#9;&amp;#123;&amp;#10;&amp;#9;&amp;#9;&amp;#9;const char *bytes = NULL;&amp;#10;&amp;#9;&amp;#9;&amp;#9;char *encoded;&amp;#10;&amp;#9;&amp;#9;&amp;#9;uint32_t eval;&amp;#10;&amp;#9;&amp;#9;&amp;#9;dispatch_data_t md = dispatch_data_create_map(pipedata, (const void **)&amp;#38;bytes, &amp;#38;len);&amp;#10;&amp;#9;&amp;#9;&amp;#9;encoded = asl_core_encode_buffer(bytes, len);&amp;#10;&amp;#9;&amp;#9;&amp;#9;asl_msg_set_key_val(aux, ASL_KEY_AUX_DATA, encoded);&amp;#10;&amp;#9;&amp;#9;&amp;#9;free(encoded);&amp;#10;&amp;#9;&amp;#9;&amp;#9;eval = _asl_evaluate_send(NULL, (aslmsg)aux, -1);&amp;#10;&amp;#9;&amp;#9;&amp;#9;_asl_send_message(NULL, eval, aux, NULL);&amp;#10;&amp;#9;&amp;#9;&amp;#9;asl_msg_release(aux);&amp;#10;&amp;#9;&amp;#9;&amp;#9;dispatch_release(md);&amp;#10;&amp;#9;&amp;#9;&amp;#125;&amp;#10;&amp;#9;&amp;#125;&amp;#10;&amp;#9;if (done)&amp;#10;&amp;#9;&amp;#123;&amp;#10;&amp;#9;&amp;#9;//&amp;#24182;&amp;#21457;&amp;#35835;&amp;#21462;&amp;#23436;&amp;#27605;&amp;#10;&amp;#9;&amp;#9;dispatch_semaphore_signal(sem);&amp;#10;&amp;#9;&amp;#9;dispatch_release(pipe_channel);&amp;#10;&amp;#9;&amp;#9;dispatch_release(pipe_q);&amp;#10;&amp;#9;&amp;#125;&amp;#10;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假如你的数据文件比较大，可以考虑采用dispatch IO的方式来提高读取的速率。&lt;/p&gt;
&lt;h4 id=&quot;Dispatch-Source&quot;&gt;&lt;a href=&quot;#Dispatch-Source&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Source&quot;&gt;&lt;/a&gt;Dispatch Source&lt;/h4&gt;&lt;p&gt;dispatch框架提供一套接口用于监听系统底层对象(如文件描述符、Mach端口、信号量等)，当这些对象有事件产生时会自动把事件的处理block函数提交到dispatch队列中执行，这套接口就是Dispatch Source API，Dispatch Source其实就是对kqueue功能的封装，可以去查看dispatch_source的c源码实现(什么是kqueue？Google，什么是Mach端口? Google Again)，Dispatch Source主要处理以下几种事件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_SOURCE_TYPE_DATA_ADD   &amp;#21464;&amp;#37327;&amp;#22686;&amp;#21152;&amp;#10;DISPATCH_SOURCE_TYPE_DATA_OR    &amp;#21464;&amp;#37327;OR&amp;#10;DISPATCH_SOURCE_TYPE_MACH_SEND  Mach&amp;#31471;&amp;#21475;&amp;#21457;&amp;#36865;&amp;#10;DISPATCH_SOURCE_TYPE_MACH_RECV  Mach&amp;#31471;&amp;#21475;&amp;#25509;&amp;#25910;&amp;#10;DISPATCH_SOURCE_TYPE_MEMORYPRESSURE &amp;#20869;&amp;#23384;&amp;#21387;&amp;#21147;&amp;#24773;&amp;#20917;&amp;#21464;&amp;#21270;&amp;#10;DISPATCH_SOURCE_TYPE_PROC       &amp;#19982;&amp;#36827;&amp;#31243;&amp;#30456;&amp;#20851;&amp;#30340;&amp;#20107;&amp;#20214;&amp;#10;DISPATCH_SOURCE_TYPE_READ       &amp;#21487;&amp;#35835;&amp;#21462;&amp;#25991;&amp;#20214;&amp;#26144;&amp;#20687;&amp;#10;DISPATCH_SOURCE_TYPE_SIGNAL     &amp;#25509;&amp;#25910;&amp;#20449;&amp;#21495;&amp;#10;DISPATCH_SOURCE_TYPE_TIMER      &amp;#23450;&amp;#26102;&amp;#22120;&amp;#20107;&amp;#20214;&amp;#10;DISPATCH_SOURCE_TYPE_VNODE      &amp;#25991;&amp;#20214;&amp;#31995;&amp;#32479;&amp;#21464;&amp;#26356;&amp;#10;DISPATCH_SOURCE_TYPE_WRITE      &amp;#21487;&amp;#20889;&amp;#20837;&amp;#25991;&amp;#20214;&amp;#26144;&amp;#20687;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当有事件发生时，dispatch source自动将一个block放入一个dispatch queue执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;dispatch_source_create&lt;br&gt;创建一个dispatch source，需要指定事件源的类型,handler的执行队列，dispatch source创建完之后将处于挂起状态。此时dispatch source会接收事件，但是不会进行处理，你需要设置事件处理的handler，并执行额外的配置；同时为了防止事件堆积到dispatch queue中，dispatch source还会对事件进行合并，如果新事件在上一个事件处理handler执行之前到达，dispatch source会根据事件的类型替换或者合并新旧事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dispatch_source_set_event_handler&lt;br&gt;给指定的dispatch source设置事件发生的处理handler&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;dispatch_source_set_cancel_handler&lt;br&gt;给指定的dispatch source设置一个取消处理handler，取消处理handler会在dispatch soruce释放之前做些清理工作，比如关闭文件描述符:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_source_set_cancel_handler(mySource, ^&amp;#123; &amp;#10;   close(fd); //&amp;#20851;&amp;#38381;&amp;#25991;&amp;#20214;&amp;#31186;&amp;#36895;&amp;#31526; &amp;#10;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_source_cancel&lt;br&gt;异步地关闭dispatch source，这样后续的事件发生时不去调用对应的事件处理handler，但已经在执行的handler不会被取消。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多第三方库会用到dispatch source的功能，比如著名的IM框架XMPPFramework在涉及到定时器的时候都采用这种方法，比如发送心跳包的时候(&lt;a href=&quot;https://github.com/robbiehanson/XMPPFramework/blob/master/Core/XMPPStream.m&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;setupKeepAliveTimer&lt;/a&gt;)。&lt;br&gt;一个简单的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#22914;&amp;#26524;dispatch source&amp;#26159;&amp;#26412;&amp;#22320;&amp;#21464;&amp;#37327;&amp;#65292;&amp;#20250;&amp;#34987;&amp;#37322;&amp;#25918;&amp;#25481;&amp;#65292;&amp;#38656;&amp;#35201;&amp;#36825;&amp;#20040;&amp;#22768;&amp;#26126;&amp;#10;@property (nonatomic)dispatch_source_t timerSource;&amp;#10;&amp;#10;//&amp;#20107;&amp;#20214;handler&amp;#30340;&amp;#22788;&amp;#29702;&amp;#38431;&amp;#21015;&amp;#10;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;myqueue&amp;#34;, NULL);&amp;#10;&amp;#10;//&amp;#10;_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);&amp;#10;&amp;#10;//&amp;#23450;&amp;#26102;&amp;#22120;&amp;#38388;&amp;#38548;&amp;#26102;&amp;#38388;&amp;#10;uint64_t interval = 2 * NSEC_PER_SEC;&amp;#10;//&amp;#35774;&amp;#32622;&amp;#23450;&amp;#26102;&amp;#22120;&amp;#20449;&amp;#24687;&amp;#10;dispatch_source_set_timer(_timerSource,DISPATCH_TIME_NOW, interval , 0);&amp;#10;&amp;#10;//&amp;#35774;&amp;#32622;&amp;#20107;&amp;#20214;&amp;#30340;&amp;#22788;&amp;#29702;handler&amp;#10;dispatch_source_set_event_handler(_timerSource, ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;receive time event&amp;#34;);&amp;#10;    //if (done) &amp;#10;    //   dispatch_source_cancel(_timerSource); &amp;#10;&amp;#125;);&amp;#10;//&amp;#24320;&amp;#22987;&amp;#22788;&amp;#29702;&amp;#23450;&amp;#26102;&amp;#22120;&amp;#20107;&amp;#20214;&amp;#65292;dispatch_suspend&amp;#26242;&amp;#20572;&amp;#22788;&amp;#29702;&amp;#20107;&amp;#20214;&amp;#10;dispatch_resume(_timerSource);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;定时器还可以通过NSTimer实现，不过NSTimer会跟runloop关联在一起，主线层默认有一个runloop，假如你nstimer是运行在子线程，就需要自己手动开启一个runloop，而且nstimer默认是在NSDefaultRunLoopMode模式下的，所以当runloop切换到其它模式nstimer就不会运行，需要手动将nstimer添加到NSRunLoopCommonModes模式下；而dispatch source timer不跟runloop关联，所以有些场景可以使用这种方法。&lt;/p&gt;
&lt;p&gt;本文总结了GCD的一些用法，不过有些API可能iOS8之后才可以用，如有还有什么可以补充的，欢迎提出～&lt;/p&gt;
&lt;p&gt;####部分参考&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch源码地址：&lt;a href=&quot;http://libdispatch.macosforge.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://libdispatch.macosforge.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015-718/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Building Responsive and Efficient Apps with GCD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Grand Central Dispatch (GCD) Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.amazon.cn/Objective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-iOS%E4%B8%8EOS-X%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%9D%82%E6%9C%AC%E4%B8%80%E6%A0%91/dp/B00DE60G3S/ref=sr_1_8?ie=UTF8&amp;amp;qid=1447952737&amp;amp;sr=8-8&amp;amp;keywords=iOS&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Objective-C高级编程:iOS与OS X多线程和内存管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在之前我们介绍过NSOperation的一些东西，这次我们来聊一聊另一个iOS开发最经常使用的技术之一 — GCD，GCD将线程的管理移到系统级别，你只需要定义好要执行的任务，然后丢到合适的Dispatch queue，GCD会负责创建线程来执行你的代码，由于这部分是处于系统级别，所以执行的性能通常非常高。GCD这部分代码苹果已开源，有兴趣的可以去下载了解一下:&lt;a href=&quot;http://libdispatch.macosforge.org/&quot;&gt;地址&lt;/a&gt;&lt;br&gt;在介绍GCD之前我们先了解一下Quality of Service：&lt;/p&gt;
&lt;h3 id=&quot;Quality-of-Service-QoS&quot;&gt;&lt;a href=&quot;#Quality-of-Service-QoS&quot; class=&quot;headerlink&quot; title=&quot;Quality of Service(QoS)&quot;&gt;&lt;/a&gt;Quality of Service(QoS)&lt;/h3&gt;&lt;p&gt;这是在iOS8之后提供的新功能，苹果提供了几个Quality of Service枚举来使用:user interactive, user initiated, utility 和 background，通过这告诉系统我们在进行什么样的工作，然后系统会通过合理的资源控制来最高效的执行任务代码，其中主要涉及到CPU调度的优先级、IO优先级、任务运行在哪个线程以及运行的顺序等等，我们通过一个抽象的Quality of Service参数来表明任务的意图以及类别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSQualityOfServiceUserInteractive&lt;br&gt;与用户交互的任务，这些任务通常跟UI级别的刷新相关，比如动画，这些任务需要在一瞬间完成&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceUserInitiated&lt;br&gt;由用户发起的并且需要立即得到结果的任务，比如滑动scroll view时去加载数据用于后续cell的显示，这些任务通常跟后续的用户交互相关，在几秒或者更短的时间内完成&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceUtility&lt;br&gt;一些可能需要花点时间的任务，这些任务不需要马上返回结果，比如下载的任务，这些任务可能花费几秒或者几分钟的时间&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceBackground&lt;br&gt;这些任务对用户不可见，比如后台进行备份的操作，这些任务可能需要较长的时间，几分钟甚至几个小时&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceDefault&lt;br&gt;优先级介于user-initiated 和 utility，当没有 QoS信息时默认使用，开发者不应该使用这个值来设置自己的任务&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="GCD" scheme="http://freemind-lj.github.io/tags/GCD/"/>
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>NSOperation和NSOperationQueue的一些事儿</title>
    <link href="http://freemind-lj.github.io/2015/11/02/NSOperation%E5%92%8CNSOperationQueue%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://freemind-lj.github.io/2015/11/02/NSOperation和NSOperationQueue的一些事儿/</id>
    <published>2015-11-02T08:06:56.000Z</published>
    <updated>2016-02-14T10:08:28.000Z</updated>
    
    <content type="html">&lt;p&gt;在面对多线程的时候，大多数会选择NSOperation或者GCD来实现，GCD由于使用起来非常方便，应该是很多开发者的首选，不过你会发现其实很多开源代码都是使用NSOpertaion来执行异步任务,所以这次我们来说说NSOperation跟NSOperationQueue，以及它的强大之处。&lt;/p&gt;
&lt;h3 id=&quot;NSOPerationQueue&quot;&gt;&lt;a href=&quot;#NSOPerationQueue&quot; class=&quot;headerlink&quot; title=&quot;NSOPerationQueue&quot;&gt;&lt;/a&gt;NSOPerationQueue&lt;/h3&gt;&lt;p&gt;NSOperation可以通过调用start方法同步地执行相应的任务，不过通常NSOprtaion都是配合NSOPerationQueue来使用的，NSOperationQueue可以看作是一种高级的dispatch queue，将NSOperation加入到queue中，queue会自动异步的执行该NSOperation&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#21019;&amp;#24314;&amp;#38431;&amp;#21015;&amp;#10;NSOperationQueue *queue = [[NSOperationQueue alloc] init];  &amp;#10;&amp;#10;//&amp;#23558;NSOperation&amp;#21152;&amp;#20837;&amp;#38431;&amp;#21015;&amp;#20043;&amp;#21518;&amp;#65292;queue&amp;#20250;&amp;#33258;&amp;#21160;&amp;#25191;&amp;#34892;&amp;#35813;operation&amp;#10;[queue addOperation:operation];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在gcd编程的时候，我们无法取消block对应的任务，不过NSOPerationQueue之所以称为高级的dispatch queue除了能异步的执行任务之外，还能够:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取消操作&lt;br&gt;当NSOperation加入到NSOperationQueue之后，可以通过调用cancel方法取消单个任务，如果想取消所有的任务可以调用cancelAllOperations方法;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#21462;&amp;#28040;&amp;#19968;&amp;#20010;&amp;#20219;&amp;#21153; &amp;#10;[operation cancel];  &amp;#10;  &amp;#10;// &amp;#21462;&amp;#28040;queue&amp;#20013;&amp;#25152;&amp;#26377;&amp;#30340;&amp;#20219;&amp;#21153;  &amp;#10;[queue cancelAllOperations];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;设置最大并发数&lt;br&gt;我们可以通过设置maxConcurrentOperationCount来设置队列的最大并发数，比如当网络为Wi-Fi时设置为6，3G时设置为2：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#35774;&amp;#32622;&amp;#24182;&amp;#21457;&amp;#25968;&amp;#30446;&amp;#20026;2&amp;#10;queue.maxConcurrentOperationCount = 2;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假如maxConcurrentOperationCount的值设为1，可以看作该队列为串行队列，每次只能执行一个任务。不过NSOPerationQueue不是先进先出（FIFO）队列，这点跟dispatch queue有点区别，dispatch queue中的block会按照FIFO的顺序去执行，NSOPerationQueue会根据Operation的状态(是否Ready)以及优先级来确定执行的NSOperation的顺序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;暂停跟继续&lt;br&gt;假如想要暂停NSOperation的执行，可以调用queue的setSuspended:方法暂停queue继续调度运行新的任务，不过正在执行的任务无法暂停&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#26242;&amp;#20572;&amp;#38431;&amp;#21015;&amp;#36816;&amp;#34892;&amp;#20219;&amp;#21153;&amp;#10;[queue setSuspended:YES];&amp;#10;&amp;#10;// &amp;#32487;&amp;#32493;&amp;#10;[queue setSuspended:NO];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;队列优先级&lt;br&gt;iOS8之后引入了QualityOfService的概念，类似于线程的优先级，设置不同的QualityOfService值后系统会分配不同的CPU时间、网络资源和硬盘资源等，因此我们可以通过这个设置队列的优先级，NSQualityOfService定义了几个枚举值：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;UserInteractive&lt;/strong&gt;: 任务跟界面的一些UI相关，比如绘制屏幕内容跟处理点击事件等，处于最高优先级的任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UserInitiated&lt;/strong&gt; : 用户一些请求的任务，关系到后面的交互，比如用户点击消息按钮后获取邮件列表的任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Utility:&lt;/strong&gt; 处理一些用户并不立即需要结果的任务，比如定期的内容更新之类的任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Background&lt;/strong&gt;:后台任务，用户不会察觉到这些任务，比如后台对文件进行索引方便后续搜索，优先级最低；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Default:&lt;/strong&gt; 默认值，介于UserInitiated跟Utility之间&lt;/p&gt;
&lt;h3 id=&quot;NSOperaion&quot;&gt;&lt;a href=&quot;#NSOperaion&quot; class=&quot;headerlink&quot; title=&quot;NSOperaion&quot;&gt;&lt;/a&gt;NSOperaion&lt;/h3&gt;&lt;p&gt;NSOperation可以看作是高级的dispatch block(dispatch_block_t),我们可以将一个任务封装成一个NSOperation对象，然后放到NSOperationQueue中去异步执行。NSOperation分为concurrent(并发任务)跟non-concurrent(非并发任务)两种，两者主要是生命周期的管理有些区别，NSOperation是一个抽象类，我们需要继承于它并实现一些方法。(当任务相对简单的时候，可以直接使用NSInvocationOperation或是NSBlockOperation，这两者也都继承自NSOperation)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;non-concurrent operation&lt;br&gt;实现一个non-concurrent operation只需要简单的继承NSOperation并实现main方法即可,NSOperationQueue会调用NSOperation的start方法，然后在start方法中调用main方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface NonConcurrentOperation : NSOperation&amp;#10;@end&amp;#10;@implementation NonConcurrentOperation&amp;#10;&amp;#10;-(void)main&amp;#10;&amp;#123;&amp;#10;    NSLog(@&amp;#34;main called&amp;#34;);&amp;#10;    &amp;#10;    dispatch_time_t time=dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);&amp;#10;    __weak typeof(self) weakSelf = self;&amp;#10;    dispatch_after(time, dispatch_get_main_queue(), ^&amp;#123;&amp;#10;        &amp;#10;        NSLog(@&amp;#34;weakSelf:%@&amp;#34;,weakSelf);&amp;#10;    &amp;#125;);&amp;#10;&amp;#125;&amp;#10;-(void)dealloc&amp;#10;&amp;#123;&amp;#10;    NSLog(@&amp;#34;dealloc called&amp;#34;);&amp;#10;&amp;#125;&amp;#10;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;non-concurrent operation会同步的运行main方法，不管期间的任务需要运行多长时间，当在执行完main方法后该operation对象会被释放。假如你在main方法中执行了异步的操作时会出现错误，比如上述的代码可以发现main方法运行完后就调用dealloc方法释放了，导致weakSelf的值为空。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSOperations[1467:91483] main called&amp;#10;NSOperations[1467:91483] dealloc called&amp;#10;NSOperations[1467:91218] weakSelf:(null)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;concurrent operation&lt;br&gt;当你的任务是并发的任务是异步任务时，你需要的是继承NSOperation并至少实现start、isExecuting和isFinished方法，其中isExecuting跟isFinished两个属性值的改变需要做KVO通知。&lt;br&gt;concurrent operation的生命周期跟non-concurrent operation不一样，可以在start方法中执行异步的方法，当start方法执行完之后该operation对象不会被释放，直到该operation执行结束，收到isFinished的kvo通知。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#29366;&amp;#24577;&amp;#26522;&amp;#20030;&amp;#10;typedef NS_ENUM(NSInteger, ConcurrentOperationState) &amp;#123;&amp;#10;    ConcurrentOperationReadyState = 1,&amp;#10;    ConcurrentOperationExecutingState,&amp;#10;    ConcurrentOperationFinishedState&amp;#10;&amp;#125;;&amp;#10;&amp;#10;@interface ConcurrentOperation ()&amp;#10;@property (nonatomic, assign) ConcurrentOperationState state;&amp;#10;@end&amp;#10;&amp;#10;@implementation ConcurrentOperation&amp;#10;&amp;#10;- (BOOL)isReady &amp;#123;&amp;#10;    self.state = ConcurrentOperationReadyState;&amp;#10;    return self.state == ConcurrentOperationReadyState;&amp;#10;&amp;#125;&amp;#10;- (BOOL)isExecuting&amp;#123;&amp;#10;    return self.state == ConcurrentOperationExecutingState;&amp;#10;&amp;#125;&amp;#10;- (BOOL)isFinished&amp;#123;&amp;#10;    return self.state == ConcurrentOperationFinishedState;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)start &amp;#123;&amp;#10;    __weak typeof(self) weakSelf = self;&amp;#10;    dispatch_time_t time=dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);&amp;#10;    dispatch_after(time, dispatch_get_main_queue(), ^&amp;#123;&amp;#10;&amp;#10;        //kvo&amp;#65306;&amp;#32467;&amp;#26463;&amp;#10;        [weakSelf willChangeValueForKey:@&amp;#34;isFinished&amp;#34;];&amp;#10;        weakSelf.state = ConcurrentOperationFinishedState;&amp;#10;        [weakSelf didChangeValueForKey:@&amp;#34;isFinished&amp;#34;];&amp;#10;        &amp;#10;        NSLog(@&amp;#34;finished :%@&amp;#34;,weakSelf);&amp;#10;    &amp;#125;);&amp;#10;    NSLog(@&amp;#34;start called&amp;#34;);&amp;#10;&amp;#10;    //kvo&amp;#65306;&amp;#27491;&amp;#22312;&amp;#25191;&amp;#34892;&amp;#10;    [weakSelf willChangeValueForKey:@&amp;#34;isExecuting&amp;#34;];&amp;#10;    weakSelf.state = ConcurrentOperationExecutingState;&amp;#10;    [weakSelf didChangeValueForKey:@&amp;#34;isExecuting&amp;#34;];&amp;#10;&amp;#125;&amp;#10;&amp;#10;-(void)dealloc&amp;#123;&amp;#10;    NSLog(@&amp;#34;dealloc called&amp;#34;);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以从打印的日志看到，当start方法结束后对象并没有立即被释放，只有发出isFinished的kvo通知后，该operation对象才会被释放&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSOperations[1556:103301] start called&amp;#10;NSOperations[1556:103242] finished :&amp;#60;ConcurrentOperation: 0x79a47bf0&amp;#62;&amp;#10;NSOperations[1556:103242] dealloc called&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSOperation状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-0d86e44aeae2c0d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600&quot; alt=&quot;NSOperation状态&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上面的图可以看到nsoperation的几种状态，当这几个状态值改变时需要使用KVO通知，其中处于Pending、Ready跟Executing状态的operation是可以被cancel的，而当operation处于finished状态是无法被取消的。当operation成功结束、失败或者被取消了，isFinished的值都会被设置为yes,所以不能仅仅靠isFinished==YES认为operation成功执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置优先级&lt;br&gt;我们可以设置operation运行的优先级，优先级的选择主要有:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &amp;#123;&amp;#10;&amp;#9;NSOperationQueuePriorityVeryLow = -8L,&amp;#10;&amp;#9;NSOperationQueuePriorityLow = -4L,&amp;#10;&amp;#9;NSOperationQueuePriorityNormal = 0,&amp;#10;&amp;#9;NSOperationQueuePriorityHigh = 4,&amp;#10;&amp;#9;NSOperationQueuePriorityVeryHigh = 8&amp;#10;&amp;#125;;&amp;#10;&amp;#10;//&amp;#35774;&amp;#32622;&amp;#20248;&amp;#20808;&amp;#32423;&amp;#10;[operation1 setQueuePriority:NSOperationQueuePriorityVeryLow];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当operation被添加到队列之后，NSOperationQueue会浏览所有的operation，优先运行那些处于ready状态且优先级较高的操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dependencies&lt;br&gt;NSOperation的另一个强大之处就是可以添加依赖，当operation1依赖于operation2的时候，系统可以保证只有当operation2结束的时候，operation1才会运行，而且依赖不局限于一个队列，你可以依赖一个不同队列的NSOperation。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#9;&amp;#10;@interface NonConcurrentOperation ()&amp;#10;@property(nonatomic,strong)NSNumber *number;&amp;#10;@end&amp;#10;&amp;#10;@implementation NonConcurrentOperation&amp;#10;&amp;#10;-(id)initWithNumber:(NSNumber *)number&amp;#123;&amp;#10;    self = [super init];&amp;#10;    if (self) &amp;#123;&amp;#10;        self.number = number;&amp;#10;    &amp;#125;&amp;#10;    return self;&amp;#10;&amp;#125;&amp;#10;&amp;#10;-(void)main&amp;#10;&amp;#123;&amp;#10;    NSLog(@&amp;#34;main called, %@&amp;#34;,self.number);&amp;#10;&amp;#125;&amp;#10;@end&amp;#10;&amp;#10;//&amp;#27979;&amp;#35797;&amp;#20195;&amp;#30721;&amp;#10;NSOperationQueue  *queue1 = [NSOperationQueue new];&amp;#10;NSOperationQueue  *queue2 = [NSOperationQueue new];&amp;#10;    &amp;#10;NonConcurrentOperation *op1 = [[NonConcurrentOperation alloc] initWithNumber:@(1)];&amp;#10;NonConcurrentOperation *op2 = [[NonConcurrentOperation alloc] initWithNumber:@(2)];&amp;#10;NonConcurrentOperation *op3 = [[NonConcurrentOperation alloc] initWithNumber:@(3)];&amp;#10;NonConcurrentOperation *op4 = [[NonConcurrentOperation alloc] initWithNumber:@(4)];&amp;#10;&amp;#10;//&amp;#28155;&amp;#21152;&amp;#20381;&amp;#36182;&amp;#10;[op1 addDependency:op2];&amp;#10;[op2 addDependency:op3];&amp;#10;&amp;#10;//&amp;#21487;&amp;#20197;&amp;#20381;&amp;#36182;&amp;#19981;&amp;#21516;&amp;#38431;&amp;#21015;&amp;#30340;operation&amp;#10;[op3 addDependency:op4];&amp;#10;    &amp;#10;[queue1 addOperation:op1];&amp;#10;[queue1 addOperation:op2];&amp;#10;[queue1 addOperation:op3];&amp;#10;[queue2 addOperation:op4]; //&amp;#28155;&amp;#21152;&amp;#21040;&amp;#19981;&amp;#21516;&amp;#38431;&amp;#21015;&amp;#20013;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出结果:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSOperations[2105:179596] main called, 4&amp;#10;NSOperations[2105:179596] main called, 3&amp;#10;NSOperations[2105:179596] main called, 2&amp;#10;NSOperations[2105:179596] main called, 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;添加依赖的时候需要注意不要相互依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[op1 addDependency:op2];&amp;#10;[op2 addDependency:op1];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果相互依赖，双方都会等待对方结束导致相互之间都无法执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-9cc429e3905433e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;互相依赖.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象化逻辑&lt;br&gt;NSOperation可以用来抽象化一些业务逻辑，业务之间有依赖的情况可以通过dependency来简化。比如有的业务场景需要收藏一篇文章，由于收藏文章需要用户的信息，而获取用户的信息又需要去登陆获取，所以我们可以将登陆、获取用户信息以及收藏文章抽象封装封装成3个operation，而其中的逻辑关系通过dependency来实现，降低逻辑复杂度，而且业务之间的关系变得可组装：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#33719;&amp;#21462;&amp;#29992;&amp;#25143;&amp;#20449;&amp;#24687;&amp;#38656;&amp;#35201;&amp;#30331;&amp;#38470;&amp;#23436;&amp;#25165;&amp;#33021;&amp;#25191;&amp;#34892;&amp;#10;[userInfoOperation addDependency:loginOperation];&amp;#10;&amp;#10;//&amp;#25910;&amp;#34255;&amp;#38656;&amp;#35201;&amp;#33719;&amp;#21462;&amp;#21040;&amp;#29992;&amp;#25143;&amp;#20449;&amp;#24687;&amp;#21518;&amp;#25165;&amp;#33021;&amp;#25191;&amp;#34892;&amp;#10;[favorOperation addDependency:userInfoOperation];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-336d7239c6b42a10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;业务间的联系.png&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;不过NSOperation跟NSOperation底层也是基于GCD实现的，它是更高层次的抽象，当你框架设计涉及到这块内容的时候应该优先考虑使用NSOperations，这样框架的结构相对会好些，类似SDwebimgag跟AFNetworking等很多开源框架都在使用NSOperations。不过不可否认gcd代码编写更简便，这边就当抛砖引玉吧～&lt;/p&gt;
&lt;h5 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h5&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/index.html#//apple_ref/doc/uid/TP40004591&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSOperation&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://greenchiu.github.io/blog/2013/08/06/ren-shi-nsoperation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;認識NSOperation&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015-226/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Advanced NSOperations&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在面对多线程的时候，大多数会选择NSOperation或者GCD来实现，GCD由于使用起来非常方便，应该是很多开发者的首选，不过你会发现其实很多开源代码都是使用NSOpertaion来执行异步任务,所以这次我们来说说NSOperation跟NSOperationQueue，以及它的强大之处。&lt;/p&gt;
&lt;h3 id=&quot;NSOPerationQueue&quot;&gt;&lt;a href=&quot;#NSOPerationQueue&quot; class=&quot;headerlink&quot; title=&quot;NSOPerationQueue&quot;&gt;&lt;/a&gt;NSOPerationQueue&lt;/h3&gt;&lt;p&gt;NSOperation可以通过调用start方法同步地执行相应的任务，不过通常NSOprtaion都是配合NSOPerationQueue来使用的，NSOperationQueue可以看作是一种高级的dispatch queue，将NSOperation加入到queue中，queue会自动异步的执行该NSOperation&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#21019;&amp;#24314;&amp;#38431;&amp;#21015;&amp;#10;NSOperationQueue *queue = [[NSOperationQueue alloc] init];  &amp;#10;&amp;#10;//&amp;#23558;NSOperation&amp;#21152;&amp;#20837;&amp;#38431;&amp;#21015;&amp;#20043;&amp;#21518;&amp;#65292;queue&amp;#20250;&amp;#33258;&amp;#21160;&amp;#25191;&amp;#34892;&amp;#35813;operation&amp;#10;[queue addOperation:operation];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在gcd编程的时候，我们无法取消block对应的任务，不过NSOPerationQueue之所以称为高级的dispatch queue除了能异步的执行任务之外，还能够:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取消操作&lt;br&gt;当NSOperation加入到NSOperationQueue之后，可以通过调用cancel方法取消单个任务，如果想取消所有的任务可以调用cancelAllOperations方法;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#21462;&amp;#28040;&amp;#19968;&amp;#20010;&amp;#20219;&amp;#21153; &amp;#10;[operation cancel];  &amp;#10;  &amp;#10;// &amp;#21462;&amp;#28040;queue&amp;#20013;&amp;#25152;&amp;#26377;&amp;#30340;&amp;#20219;&amp;#21153;  &amp;#10;[queue cancelAllOperations];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="GCD" scheme="http://freemind-lj.github.io/tags/GCD/"/>
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage源码剖析（二）</title>
    <link href="http://freemind-lj.github.io/2015/05/10/SDWebImage%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://freemind-lj.github.io/2015/05/10/SDWebImage源码剖析（二）/</id>
    <published>2015-05-10T08:29:07.000Z</published>
    <updated>2016-02-14T08:32:12.000Z</updated>
    
    <content type="html">&lt;p&gt;SDWebImageCache管理着SDWebImage的缓存，其中内存缓存采用NSCache，同时会创建一个ioQueue负责对硬盘的读写，并且会添加观察者，在收到内存警告、关闭或进入后台时完成对应的处理:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)init &amp;#123;&amp;#10;     _memCache = [[NSCache alloc] init];&amp;#10;     _ioQueue = dispatch_queue_create(&amp;#34;com.hackemist.SDWebImageCache&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;     //&amp;#25910;&amp;#21040;&amp;#20869;&amp;#23384;&amp;#35686;&amp;#21578;&amp;#26102;&amp;#65292;&amp;#28165;&amp;#38500;NSCache&amp;#65306;[self.memCache removeAllObjects];&amp;#10;     [[NSNotificationCenter defaultCenter] addObserver:self&amp;#10;                                                 selector:@selector(clearMemory)&amp;#10;                                              name:UIApplicationDidReceiveMemoryWarningNotification&amp;#10;                                                   object:nil];&amp;#10;      //&amp;#31243;&amp;#24207;&amp;#20851;&amp;#38381;&amp;#26102;&amp;#65292;&amp;#20250;&amp;#23545;&amp;#30828;&amp;#30424;&amp;#25991;&amp;#20214;&amp;#20570;&amp;#19968;&amp;#20123;&amp;#22788;&amp;#29702;&amp;#10;      [[NSNotificationCenter defaultCenter] addObserver:self&amp;#10;                                                 selector:@selector(cleanDisk)&amp;#10;                                                     name:UIApplicationWillTerminateNotification&amp;#10;                                                   object:nil];&amp;#10;      //&amp;#31243;&amp;#24207;&amp;#36827;&amp;#20837;&amp;#21518;&amp;#21488;&amp;#26102;&amp;#65292;&amp;#20063;&amp;#20250;&amp;#36827;&amp;#34892;&amp;#30828;&amp;#30424;&amp;#25991;&amp;#20214;&amp;#22788;&amp;#29702;&amp;#10;      [[NSNotificationCenter defaultCenter] addObserver:self&amp;#10;                                                 selector:@selector(backgroundCleanDisk)&amp;#10;                                                     name:UIApplicationDidEnterBackgroundNotification&amp;#10;                                                   object:nil];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;查询图片&quot;&gt;&lt;a href=&quot;#查询图片&quot; class=&quot;headerlink&quot; title=&quot;查询图片&quot;&gt;&lt;/a&gt;查询图片&lt;/h3&gt;&lt;p&gt;每次向SDWebImageCache索取图片的时候，会先根据图片URL对应的key值先检查内存中是否有对应的图片，如果有则直接返回；如果没有则在ioQueue中去硬盘中查找，其中文件名是是根据URL生成的MD5值，找到之后先将图片缓存在内存中，然后在把图片返回：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock &amp;#123;&amp;#10;    /*...*/&amp;#10;    // &amp;#39318;&amp;#20808;&amp;#26597;&amp;#25214;&amp;#20869;&amp;#23384;&amp;#32531;&amp;#23384;&amp;#10;    UIImage *image = [self imageFromMemoryCacheForKey:key];&amp;#10;    if (image) &amp;#123;&amp;#10;        doneBlock(image, SDImageCacheTypeMemory);&amp;#10;        return nil;&amp;#10;    &amp;#125;&amp;#10;    //&amp;#30828;&amp;#30424;&amp;#26597;&amp;#25214;&amp;#10;    NSOperation *operation = [NSOperation new];&amp;#10;    dispatch_async(self.ioQueue, ^&amp;#123;&amp;#10;        //&amp;#21019;&amp;#24314;&amp;#33258;&amp;#21160;&amp;#37322;&amp;#25918;&amp;#27744;&amp;#65292;&amp;#20869;&amp;#23384;&amp;#21450;&amp;#26102;&amp;#37322;&amp;#25918;&amp;#10;        @autoreleasepool &amp;#123;&amp;#10;            UIImage *diskImage = [self diskImageForKey:key];&amp;#10;            if (diskImage) &amp;#123;&amp;#10;                CGFloat cost = diskImage.size.height * diskImage.size.width * diskImage.scale * diskImage.scale;&amp;#10;                //&amp;#32531;&amp;#23384;&amp;#21040;NSCache&amp;#20013;&amp;#10;                [self.memCache setObject:diskImage forKey:key cost:cost];&amp;#10;            &amp;#125;&amp;#10;            dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&amp;#10;                doneBlock(diskImage, SDImageCacheTypeDisk);&amp;#10;            &amp;#125;);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;);&amp;#10;    return operation;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在硬盘查询的时候，会在后台将NSData转成UIImage，并完成相关的解码工作:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (UIImage *)diskImageForKey:(NSString *)key &amp;#123;&amp;#10;    NSData *data = [self diskImageDataBySearchingAllPathsForKey:key];&amp;#10;    if (data) &amp;#123;&amp;#10;        UIImage *image = [UIImage sd_imageWithData:data];&amp;#10;        image = [self scaledImageForKey:key image:image];&amp;#10;        if (self.shouldDecompressImages) &amp;#123;&amp;#10;            image = [UIImage decodedImageWithImage:image];&amp;#10;        &amp;#125;&amp;#10;        return image;&amp;#10;    &amp;#125;&amp;#10;    else &amp;#123;&amp;#10;        return nil;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;保存图片&quot;&gt;&lt;a href=&quot;#保存图片&quot; class=&quot;headerlink&quot; title=&quot;保存图片&quot;&gt;&lt;/a&gt;保存图片&lt;/h3&gt;&lt;p&gt;当下载完图片后，会先将图片保存到NSCache中，并把图片像素大小作为该对象的cost值，同时如果需要保存到硬盘，会先判断图片的格式，PNG或者JPEG，并保存对应的NSData到缓存路径中，文件名为URL的MD5值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSString *)cachedFileNameForKey:(NSString *)key &amp;#123;&amp;#10;    //&amp;#26681;&amp;#25454;key&amp;#29983;&amp;#25104;&amp;#23545;&amp;#24212;&amp;#30340;MD5&amp;#20540;&amp;#20316;&amp;#20026;&amp;#25991;&amp;#20214;&amp;#21517;&amp;#10;    const char *str = [key UTF8String];&amp;#10;    if (str == NULL) &amp;#123;&amp;#10;        str = &amp;#34;&amp;#34;;&amp;#10;    &amp;#125;&amp;#10;    unsigned char r[CC_MD5_DIGEST_LENGTH];&amp;#10;    CC_MD5(str, (CC_LONG)strlen(str), r);&amp;#10;    NSString *filename = [NSString stringWithFormat:@&amp;#34;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x&amp;#34;,&amp;#10;                                                    r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15]];&amp;#10;&amp;#10;    return filename;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk &amp;#10;&amp;#123;&amp;#10;    //&amp;#20445;&amp;#23384;&amp;#21040;NSCache&amp;#65292;cost&amp;#20026;&amp;#20687;&amp;#32032;&amp;#20540;&amp;#10;&amp;#160; &amp;#160; [self.memCache setObject:image forKey:key cost:image.size.height * image.size.width * image.scale * image.scale];&amp;#10;&amp;#160; &amp;#160; if (toDisk) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; dispatch_async(self.ioQueue, ^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; NSData *data = imageData;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; if (image &amp;#38;&amp;#38; (recalculate || !data)) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160;//&amp;#21028;&amp;#26029;&amp;#22270;&amp;#29255;&amp;#26684;&amp;#24335;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; BOOL imageIsPng = YES;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; // &amp;#26597;&amp;#30475;imagedata&amp;#30340;&amp;#21069;&amp;#32512;&amp;#26159;&amp;#21542;&amp;#26159;PNG&amp;#30340;&amp;#21069;&amp;#32512;&amp;#26684;&amp;#24335;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; if ([imageData length] &amp;#62;= [kPNGSignatureData length]) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; imageIsPng = ImageDataHasPNGPreffix(imageData);&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#125;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; if (imageIsPng) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; data = UIImagePNGRepresentation(image);&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#125;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; else &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; data = UIImageJPEGRepresentation(image, (CGFloat)1.0);&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#125;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#125;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; if (data) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; if (![_fileManager fileExistsAtPath:_diskCachePath]) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#125;&amp;#10;                //&amp;#20445;&amp;#23384;data&amp;#21040;&amp;#25351;&amp;#23450;&amp;#30340;&amp;#36335;&amp;#24452;&amp;#20013;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [_fileManager createFileAtPath:[self defaultCachePathForKey:key] contents:data attributes:nil];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#125;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#125;);&amp;#10;&amp;#160; &amp;#160; &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;硬盘文件的管理&quot;&gt;&lt;a href=&quot;#硬盘文件的管理&quot; class=&quot;headerlink&quot; title=&quot;硬盘文件的管理&quot;&gt;&lt;/a&gt;硬盘文件的管理&lt;/h3&gt;&lt;p&gt;在程序退出或者进入后台时，会出图片文件进行管理，具体的策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;清除过期的文件，默认一星期 &lt;/li&gt;
&lt;li&gt;如果设置了最大缓存，并且当前缓存的文件超过了这个限制，则删除最旧的文件，直到当前缓存文件的大小为最大缓存大小的一半&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &amp;#123;&amp;#10;    dispatch_async(self.ioQueue, ^&amp;#123;&amp;#10;        NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];&amp;#10;        NSArray *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey];&amp;#10;&amp;#10;        // This enumerator prefetches useful properties for our cache files.&amp;#10;        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL&amp;#10;                                                   includingPropertiesForKeys:resourceKeys&amp;#10;                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles&amp;#10;                                                                 errorHandler:NULL];&amp;#10;&amp;#10;        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.maxCacheAge];&amp;#10;        NSMutableDictionary *cacheFiles = [NSMutableDictionary dictionary];&amp;#10;        NSUInteger currentCacheSize = 0;&amp;#10;&amp;#10;        // Enumerate all of the files in the cache directory.  This loop has two purposes:&amp;#10;        //&amp;#10;        //  1. Removing files that are older than the expiration date.&amp;#10;        //  2. Storing file attributes for the size-based cleanup pass.&amp;#10;        NSMutableArray *urlsToDelete = [[NSMutableArray alloc] init];&amp;#10;        for (NSURL *fileURL in fileEnumerator) &amp;#123;&amp;#10;            NSDictionary *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:NULL];&amp;#10;&amp;#10;            // Skip directories.&amp;#10;            if ([resourceValues[NSURLIsDirectoryKey] boolValue]) &amp;#123;&amp;#10;                continue;&amp;#10;            &amp;#125;&amp;#10;&amp;#10;            // Remove files that are older than the expiration date;&amp;#10;            NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];&amp;#10;            if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &amp;#123;&amp;#10;                [urlsToDelete addObject:fileURL];&amp;#10;                continue;&amp;#10;            &amp;#125;&amp;#10;&amp;#10;            // Store a reference to this file and account for its total size.&amp;#10;            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];&amp;#10;            currentCacheSize += [totalAllocatedSize unsignedIntegerValue];&amp;#10;            [cacheFiles setObject:resourceValues forKey:fileURL];&amp;#10;        &amp;#125;&amp;#10;        &amp;#10;        for (NSURL *fileURL in urlsToDelete) &amp;#123;&amp;#10;            [_fileManager removeItemAtURL:fileURL error:nil];&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        // If our remaining disk cache exceeds a configured maximum size, perform a second&amp;#10;        // size-based cleanup pass.  We delete the oldest files first.&amp;#10;        if (self.maxCacheSize &amp;#62; 0 &amp;#38;&amp;#38; currentCacheSize &amp;#62; self.maxCacheSize) &amp;#123;&amp;#10;            // Target half of our maximum cache size for this cleanup pass.&amp;#10;            const NSUInteger desiredCacheSize = self.maxCacheSize / 2;&amp;#10;&amp;#10;            // Sort the remaining cache files by their last modification time (oldest first).&amp;#10;            NSArray *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent&amp;#10;                                                            usingComparator:^NSComparisonResult(id obj1, id obj2) &amp;#123;&amp;#10;                                                                return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];&amp;#10;                                                            &amp;#125;];&amp;#10;&amp;#10;            // Delete files until we fall below our desired cache size.&amp;#10;            for (NSURL *fileURL in sortedFiles) &amp;#123;&amp;#10;                if ([_fileManager removeItemAtURL:fileURL error:nil]) &amp;#123;&amp;#10;                    NSDictionary *resourceValues = cacheFiles[fileURL];&amp;#10;                    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];&amp;#10;                    currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];&amp;#10;&amp;#10;                    if (currentCacheSize &amp;#60; desiredCacheSize) &amp;#123;&amp;#10;                        break;&amp;#10;                    &amp;#125;&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;        if (completionBlock) &amp;#123;&amp;#10;            dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&amp;#10;                completionBlock();&amp;#10;            &amp;#125;);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;接口设计简单&lt;br&gt;通常我们使用较多的UIImageView分类：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.imageView sd_setImageWithURL:[NSURL URLWithString:@&amp;#34;url&amp;#34;]&amp;#10;                  placeholderImage:[UIImage imageNamed:@&amp;#34;placeholder&amp;#34;]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个简单的接口将其中复杂的实现细节全部隐藏：简单就是美。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用NSCache作为内存缓&lt;/li&gt;
&lt;li&gt;耗时较长的请求，都采用异步形式，在回调函数块中处理请求结果&lt;/li&gt;
&lt;li&gt;NSOperation和NSOperationQueue：可以取消任务处理队列中的任务，设置最大并发数，设置operation之间的依赖关系。&lt;/li&gt;
&lt;li&gt;图片缓存清理的策略&lt;/li&gt;
&lt;li&gt;dispatch_barrier_sync：前面的任务执行结束后它才执行，而且它后面的任务要等它执行完成之后才会执行。&lt;/li&gt;
&lt;li&gt;使用weak self  strong self 防止retain circle&lt;/li&gt;
&lt;li&gt;如果子线程进需要不断处理一些事件，那么设置一个Run Loop是最好的处理方式&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;SDWebImageCache管理着SDWebImage的缓存，其中内存缓存采用NSCache，同时会创建一个ioQueue负责对硬盘的读写，并且会添加观察者，在收到内存警告、关闭或进入后台时完成对应的处理:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)init &amp;#123;&amp;#10;     _memCache = [[NSCache alloc] init];&amp;#10;     _ioQueue = dispatch_queue_create(&amp;#34;com.hackemist.SDWebImageCache&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;     //&amp;#25910;&amp;#21040;&amp;#20869;&amp;#23384;&amp;#35686;&amp;#21578;&amp;#26102;&amp;#65292;&amp;#28165;&amp;#38500;NSCache&amp;#65306;[self.memCache removeAllObjects];&amp;#10;     [[NSNotificationCenter defaultCenter] addObserver:self&amp;#10;                                                 selector:@selector(clearMemory)&amp;#10;                                              name:UIApplicationDidReceiveMemoryWarningNotification&amp;#10;                                                   object:nil];&amp;#10;      //&amp;#31243;&amp;#24207;&amp;#20851;&amp;#38381;&amp;#26102;&amp;#65292;&amp;#20250;&amp;#23545;&amp;#30828;&amp;#30424;&amp;#25991;&amp;#20214;&amp;#20570;&amp;#19968;&amp;#20123;&amp;#22788;&amp;#29702;&amp;#10;      [[NSNotificationCenter defaultCenter] addObserver:self&amp;#10;                                                 selector:@selector(cleanDisk)&amp;#10;                                                     name:UIApplicationWillTerminateNotification&amp;#10;                                                   object:nil];&amp;#10;      //&amp;#31243;&amp;#24207;&amp;#36827;&amp;#20837;&amp;#21518;&amp;#21488;&amp;#26102;&amp;#65292;&amp;#20063;&amp;#20250;&amp;#36827;&amp;#34892;&amp;#30828;&amp;#30424;&amp;#25991;&amp;#20214;&amp;#22788;&amp;#29702;&amp;#10;      [[NSNotificationCenter defaultCenter] addObserver:self&amp;#10;                                                 selector:@selector(backgroundCleanDisk)&amp;#10;                                                     name:UIApplicationDidEnterBackgroundNotification&amp;#10;                                                   object:nil];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="SDWebimage" scheme="http://freemind-lj.github.io/tags/SDWebimage/"/>
    
      <category term="源码解析" scheme="http://freemind-lj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage源码剖析（－）</title>
    <link href="http://freemind-lj.github.io/2015/05/10/SDWebImage%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%88%EF%BC%8D%EF%BC%89/"/>
    <id>http://freemind-lj.github.io/2015/05/10/SDWebImage源码剖析（－）/</id>
    <published>2015-05-10T04:15:45.000Z</published>
    <updated>2016-02-14T10:06:23.000Z</updated>
    
    <content type="html">&lt;p&gt;  在开发项目的过程中会用到很多第三方库，比如AFNetWorking,SDWebImage,FMDB等，但一直都没去好好的研究一下，最近刚好项目不是太紧，闲下来可以给自己充充电，先研究一下SDWebImage的底层实现，源码地址：&lt;a href=&quot;https://github.com/rs/SDWebImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SDWebImage&lt;/a&gt;&lt;br&gt;  先介绍一下SDWebImage，我们使用较多的是它提供的UIImageView分类，支持从远程服务器下载并缓存图片。自从iOS5.0开始，NSURLCache也可以处理磁盘缓存，那么SDWebImage的优势在哪？首先NSURLCache是缓存原始数据(raw data)到磁盘或内存，因此每次使用的时候需要将原始数据转换成具体的对象，如UIImage等，这会导致额外的数据解析以及内存占用等，而SDWebImage则是缓存UIImage对象在内存，缓存在NSCache中，同时直接保存压缩过的图片到磁盘中；还有一个问题是当你第一次在UIImageView中使用image对象的时候，图片的解码是在主线程中运行的！而SDWebImage会强制将解码操作放到子线程中。下图是SDWebImage简单的类图关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-c1788a3eb9134b64.png&quot; alt=&quot;SDWebImage.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面从UIImageView的图片加载开始看起，Let’s go!&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;首先我们在给UIImageView设置图片的时候会调用方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中url为远程图片的地址，而placeholder为预显示的图片。&lt;br&gt;其实还可以添加一些额外的参数，比如图片选项SDWebImageOptions&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) {
    SDWebImageRetryFailed = 1 &lt;&lt; 0,//下载失败了会再次尝试下载
    WebImageLowPriority = 1 &lt;&lt; 1,//当UIScrollView等正在滚动时，延迟下载图片（放置scrollView滚动卡）
    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,//只缓存到内存中
    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,// 图片会边下边显示
    SDWebImageRefreshCached = 1 &lt;&lt; 4,//将硬盘缓存交给系统自带的NSURLCache去处理
    SDWebImageContinueInBackground = 1 &lt;&lt; 5,//后台下载
    SDWebImageHandleCookies = 1 &lt;&lt; 6,// 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES来处理存储在NSHTTPCookieStore中的cookie
    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,// 允许不受信任的SSL证书。主要用于测试目的。
    SDWebImageHighPriority = 1 &lt;&lt; 8,
    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,
    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般使用的是SDWebImageRetryFailed | SDWebImageLowPriority，下面看看具体的函数调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock 
{
    [self sd_cancelCurrentImageLoad];//取消正在下载的操作
    objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//关联该view对应的图片URL  
   /*...*/ 
    if (url) {
        __weak UIImageView *wself = self;//防止retain cricle
        //由SDWebImageManager负责图片的获取
        id &lt;sdwebimageoperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {
              /*获取图片到主线层显示*/ 
        }];
        [self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];
    } 
}
&lt;/sdwebimageoperation&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出图片是从服务端、内存或者硬盘获取是由SDWebImageManager管理的，这个类有几个重要的属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@property (strong, nonatomic, readwrite) SDImageCache *imageCache;//负责管理cache，涉及内存缓存和硬盘保存
@property (strong, nonatomic, readwrite) SDWebImageDownloader *imageDownloader;//负责从网络下载图片
@property (strong, nonatomic) NSMutableArray *runningOperations;//包含所有当前正在下载的操作对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;manager会根据URL先去imageCache中查找对应的图片，如果没有在使用downloader去下载，并在下载完成缓存图片到imageCache，接着看实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
- (id &lt;sdwebimageoperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageOptions)options
                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock
 {
     /*...*/
    //根据URL生成对应的key，没有特殊处理为[url absoluteString];
    NSString *key = [self cacheKeyForURL:url];
    //去imageCache中寻找图片
    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) 
    {
       /*...*/
       //如果图片没有找到，或者采用的SDWebImageRefreshCached选项，则从网络下载
        if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) {
                dispatch_main_sync_safe(^{
                  //如果图片找到了，但是采用的SDWebImageRefreshCached选项，通知获取到了图片，并再次从网络下载，使NSURLCache重新刷新
                     completedBlock(image, nil, cacheType, YES, url);
                });
            }
            /*下载选项设置*/ 
            //使用imageDownloader开启网络下载
            id &lt;sdwebimageoperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) {
                /*...*/
               if (downloadedImage &amp;&amp; finished) {
                     //下载完成后，先将图片保存到imageCache中，然后主线程返回
                     [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];
                        }
                     dispatch_main_sync_safe(^{
                            if (!weakOperation.isCancelled) {
                                completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);
                            }
                        });
                    }
                }
          /*...*/
       }
        else if (image) {
          //在cache中找到图片了，直接返回
            dispatch_main_sync_safe(^{
                if (!weakOperation.isCancelled) {
                    completedBlock(image, nil, cacheType, YES, url);
                }
            });
        }
    }];
    return operation;
}
&lt;/sdwebimageoperation&gt;&lt;/sdwebimageoperation&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面先看downloader从网络下载的过程，下载是放在NSOperationQueue中进行的，默认maxConcurrentOperationCount为6，timeout时间为15s：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id &amp;#60;SDWebImageOperation&amp;#62;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &amp;#123;&amp;#10;    __block SDWebImageDownloaderOperation *operation;&amp;#10;    __weak SDWebImageDownloader *wself = self;&amp;#10;    /*...*/&amp;#10;    //&amp;#38450;&amp;#27490;NSURLCache&amp;#21644;SDImageCache&amp;#37325;&amp;#22797;&amp;#32531;&amp;#23384;&amp;#10;    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp;#38; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy :NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];&amp;#10;    request.HTTPShouldHandleCookies = (options &amp;#38; SDWebImageDownloaderHandleCookies);&amp;#10;    request.HTTPShouldUsePipelining = YES;&amp;#10;    request.allHTTPHeaderFields = wself.HTTPHeaders;//&amp;#35774;&amp;#32622;http&amp;#22836;&amp;#37096;&amp;#10;    //SDWebImageDownloaderOperation&amp;#27966;&amp;#29983;&amp;#33258;NSOperation&amp;#65292;&amp;#36127;&amp;#36131;&amp;#22270;&amp;#29255;&amp;#19979;&amp;#36733;&amp;#24037;&amp;#20316;&amp;#10;    operation = [[SDWebImageDownloaderOperation alloc] initWithRequest:request&amp;#10;                                                          options:options&amp;#10;                                                         progress:^(NSInteger receivedSize, NSInteger expectedSize) &amp;#123;&amp;#125;&amp;#10;                                                        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &amp;#123;&amp;#125;&amp;#10;                                                        cancelled:^&amp;#123;&amp;#125;];&amp;#10;    operation.shouldDecompressImages = wself.shouldDecompressImages;//&amp;#26159;&amp;#21542;&amp;#38656;&amp;#35201;&amp;#35299;&amp;#30721;&amp;#10;    if (wself.username &amp;#38;&amp;#38; wself.password) &amp;#123;&amp;#10;            operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];&amp;#10;    &amp;#125;&amp;#10;    if (options &amp;#38; SDWebImageDownloaderHighPriority) &amp;#123;&amp;#10;            operation.queuePriority = NSOperationQueuePriorityHigh;&amp;#10;        &amp;#125; else if (options &amp;#38; SDWebImageDownloaderLowPriority) &amp;#123;&amp;#10;            operation.queuePriority = NSOperationQueuePriorityLow;&amp;#10;    &amp;#125;&amp;#10;        [wself.downloadQueue addOperation:operation];&amp;#10;        if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &amp;#123;&amp;#10;            // &amp;#22914;&amp;#26524;&amp;#19979;&amp;#36733;&amp;#39034;&amp;#24207;&amp;#26159;&amp;#21518;&amp;#38754;&amp;#28155;&amp;#21152;&amp;#30340;&amp;#20808;&amp;#36816;&amp;#34892;&amp;#10;            [wself.lastAddedOperation addDependency:operation];&amp;#10;            wself.lastAddedOperation = operation;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;];&amp;#10;    return operation;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;SDWebImageDownloaderOperation派生自NSOperation，通过NSURLConnection进行图片的下载，为了确保能够处理下载的数据，需要在后台运行runloop：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)start &amp;#123;&amp;#10;&amp;#160; /*...*/&amp;#10;#if TARGET_OS_IPHONE &amp;#38;&amp;#38; __IPHONE_OS_VERSION_MAX_ALLOWED &amp;#62;= __IPHONE_4_0&amp;#10;        //&amp;#24320;&amp;#21551;&amp;#21518;&amp;#21488;&amp;#19979;&amp;#36733;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; if ([self shouldContinueWhenAppEntersBackground]) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; __weak __typeof__ (self) wself = self;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; self.backgroundTaskId = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; __strong __typeof (wself) sself = wself;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; if (sself) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [sself cancel];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [[UIApplication sharedApplication] endBackgroundTask:sself.backgroundTaskId];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; sself.backgroundTaskId = UIBackgroundTaskInvalid;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#125;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#125;];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#125;&amp;#10;#endif&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; self.executing = YES;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];&amp;#10;&amp;#160; &amp;#160; &amp;#125;&amp;#10;&amp;#160; &amp;#160; [self.connection start];&amp;#10;&amp;#10;&amp;#160; &amp;#160; if (self.connection) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; if (self.progressBlock) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; self.progressBlock(0, NSURLResponseUnknownLength);&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#125;&amp;#10;       //&amp;#22312;&amp;#20027;&amp;#32447;&amp;#31243;&amp;#21457;&amp;#36890;&amp;#30693;&amp;#65292;&amp;#36825;&amp;#26679;&amp;#20063;&amp;#20445;&amp;#35777;&amp;#22312;&amp;#20027;&amp;#32447;&amp;#31243;&amp;#25910;&amp;#21040;&amp;#36890;&amp;#30693;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#125;);&amp;#10;       CFRunLoopRun();//&amp;#22312;&amp;#40664;&amp;#35748;&amp;#27169;&amp;#24335;&amp;#19979;&amp;#36816;&amp;#34892;&amp;#24403;&amp;#21069;runlooprun&amp;#65292;&amp;#30452;&amp;#21040;&amp;#35843;&amp;#29992;CFRunLoopStop&amp;#20572;&amp;#27490;&amp;#36816;&amp;#34892;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; if (!self.isFinished) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [self.connection cancel];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@&amp;#123;NSURLErrorFailingURLErrorKey : self.request.URL&amp;#125;]];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#125;&amp;#10;&amp;#160; &amp;#160; &amp;#125;&amp;#10;#if TARGET_OS_IPHONE &amp;#38;&amp;#38; __IPHONE_OS_VERSION_MAX_ALLOWED &amp;#62;= __IPHONE_4_0&amp;#10;&amp;#160; &amp;#160; if (self.backgroundTaskId != UIBackgroundTaskInvalid) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [[UIApplication sharedApplication] endBackgroundTask:self.backgroundTaskId];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; self.backgroundTaskId = UIBackgroundTaskInvalid;&amp;#10;&amp;#160; &amp;#160; &amp;#125;&amp;#10;#endif&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下载过程中，在代理 － (void)connection:(NSURLConnection &lt;em&gt;)connection didReceiveData:(NSData &lt;/em&gt;)data中将接收到的数据保存到NSMutableData中，[self.imageData appendData:data]，下载完成后在该线程完成图片的解码，并在完成的completionBlock中进行imageCache的缓存：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection &amp;#123;&amp;#10;    SDWebImageDownloaderCompletedBlock completionBlock = self.completedBlock;&amp;#10;    @synchronized(self) &amp;#123;&amp;#10;        CFRunLoopStop(CFRunLoopGetCurrent());//&amp;#20572;&amp;#27490;&amp;#24403;&amp;#21069;&amp;#23545;runloop&amp;#10;        /*...*/&amp;#10;        if (completionBlock) &amp;#123;&amp;#10;            /*...*/&amp;#10;            UIImage *image = [UIImage sd_imageWithData:self.imageData];&amp;#10;            NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];&amp;#10;            image = [self scaledImageForKey:key image:image];&amp;#10;            &amp;#10;              // Do not force decoding animated GIFs&amp;#10;             if (!image.images) &amp;#123;&amp;#10;                 if (self.shouldDecompressImages) &amp;#123;&amp;#10;                    image = [UIImage decodedImageWithImage:image];//&amp;#22270;&amp;#29255;&amp;#35299;&amp;#30721;&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;            if (CGSizeEqualToSize(image.size, CGSizeZero)) &amp;#123;&amp;#10;                completionBlock(nil, nil, [NSError errorWithDomain:@&amp;#34;SDWebImageErrorDomain&amp;#34; code:0 userInfo:@&amp;#123;NSLocalizedDescriptionKey : @&amp;#34;Downloaded image has 0 pixels&amp;#34;&amp;#125;], YES);&amp;#10;            &amp;#125;&amp;#10;            else &amp;#123;&amp;#10;                completionBlock(image, self.imageData, nil, YES);&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    self.completionBlock = nil;&amp;#10;    [self done];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;  在开发项目的过程中会用到很多第三方库，比如AFNetWorking,SDWebImage,FMDB等，但一直都没去好好的研究一下，最近刚好项目不是太紧，闲下来可以给自己充充电，先研究一下SDWebImage的底层实现，源码地址：&lt;a href=&quot;https://github.com/rs/SDWebImage&quot;&gt;SDWebImage&lt;/a&gt;&lt;br&gt;  先介绍一下SDWebImage，我们使用较多的是它提供的UIImageView分类，支持从远程服务器下载并缓存图片。自从iOS5.0开始，NSURLCache也可以处理磁盘缓存，那么SDWebImage的优势在哪？首先NSURLCache是缓存原始数据(raw data)到磁盘或内存，因此每次使用的时候需要将原始数据转换成具体的对象，如UIImage等，这会导致额外的数据解析以及内存占用等，而SDWebImage则是缓存UIImage对象在内存，缓存在NSCache中，同时直接保存压缩过的图片到磁盘中；还有一个问题是当你第一次在UIImageView中使用image对象的时候，图片的解码是在主线程中运行的！而SDWebImage会强制将解码操作放到子线程中。下图是SDWebImage简单的类图关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/458529-c1788a3eb9134b64.png&quot; alt=&quot;SDWebImage.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面从UIImageView的图片加载开始看起，Let’s go!&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="SDWebimage" scheme="http://freemind-lj.github.io/tags/SDWebimage/"/>
    
      <category term="源码解析" scheme="http://freemind-lj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
