<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>树下的老男孩</title>
  <subtitle>工匠之行，在行动中体悟修行的乐趣</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://freemind-lj.github.io/"/>
  <updated>2016-02-15T02:52:13.000Z</updated>
  <id>http://freemind-lj.github.io/</id>
  
  <author>
    <name>树下的老男孩</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS应用程序间共享数据</title>
    <link href="http://freemind-lj.github.io/2016/02/02/iOS%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/"/>
    <id>http://freemind-lj.github.io/2016/02/02/iOS应用程序间共享数据/</id>
    <published>2016-02-02T09:39:59.000Z</published>
    <updated>2016-02-15T02:52:13.000Z</updated>
    
    <content type="html">&lt;p&gt;我们知道iOS由于沙盒的存在，应用程序不能越过自己的区域去访问别的存储空间的内容，不过可能有许多场景我们需要在应用程序之间共享数据，比如多个应用共用用户名密码进行登录等。虽然我们不能直接通过文件系统来分享数据，不过还是有些方法可以实现，为了方便说明，这里同时创建了两个工程Example1和Example2，实现这两个app之间的信息共享，Example1负责写数据，Example2负责读数据，具体的demo代码可以到&lt;a href=&quot;https://github.com/FreeMind-LJ/SharedDataDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;获取&lt;/p&gt;
&lt;h4 id=&quot;UIPasteboard&quot;&gt;&lt;a href=&quot;#UIPasteboard&quot; class=&quot;headerlink&quot; title=&quot;UIPasteboard&quot;&gt;&lt;/a&gt;UIPasteboard&lt;/h4&gt;&lt;p&gt;剪贴板是应用程序之间传递数据的简单方式，建议不要使用全局的粘贴板，而是自己根据名字创建一个新的粘贴板，防止其它地方全局拷贝的影响。然后把需要共享的内容复制到粘贴板，粘贴板的内容可以是文本、URL、图片和UIColor等，另一个app就可以根据粘贴板的名字去读取相关的信息。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Example1设置粘贴板的内容:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIPasteboard *pasteboard = [UIPasteboard pasteboardWithName:@&amp;#34;myPasteboard&amp;#34; create:YES];&amp;#10;pasteboard.string = @&amp;#34;myShareData&amp;#34;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example2读取粘贴板的内容:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIPasteboard *pasteboard = [UIPasteboard pasteboardWithName:@&amp;#34;myPasteboard&amp;#34; create:NO];&amp;#10;NSString *content = pasteboard.string;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Custom-URL-Scheme&quot;&gt;&lt;a href=&quot;#Custom-URL-Scheme&quot; class=&quot;headerlink&quot; title=&quot;Custom URL Scheme&quot;&gt;&lt;/a&gt;Custom URL Scheme&lt;/h4&gt;&lt;p&gt;URL Scheme能够让我们通过自定义的协议在应用程序间传递信息，当你想要发送数据给一个实现了自定义URL Scheme的应用时，只需要创建好合适格式的URL，然后调用openURL:方法，系统就会载入注册了该scheme的应用然后将你的URL传递给他，比如如下的代码,todolist是一个其它应用注册的scheme，通过openURL便可以将服务请求发送到该应用（自定义的URL Scheme要能够唯一标示该APP，如果你的URL Scheme跟别人冲突了，那么你的app就不一定会被调起，iOS并不保证调用哪个应用）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSURL *myURL = [NSURL URLWithString:@&amp;#34;todolist://newid=20&amp;#34;];&amp;#10;[[UIApplication sharedApplication] openURL:myURL];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;注册URL Scheme&lt;br&gt;为了能够处理URL请求，我们需要先注册自定义的URL Scheme，只需要在Info tab下的URL Types添加即可，比如我们这里注册Example2的URL Scheme。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/16-2-15%2F13214719.jpg&quot; alt=&quot;注册URL scheme&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;Identifier用于标示名称，为了唯一性可以采用反转域名的形式，另外我们设置URL Scheme为Example2，以及role为Viewer(Viewer表示只能读取改URL但不能修改，Editor可以对URL进行读写)，这样Example2就能够接受类似”Example2:\“的URL请求了，可以在浏览器中输入”Example2:\“链接打开app。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理URL请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当有URL请求到来时，所有的URL都会传递给你的app delegate，我们需要实现application:openURL:sourceApplication:annotation:方法来接收处理对应的URL，所以假如你想通过URL方式来传递数据，只需要将数据添加到URL中即可，另外的通过解析该URL来获取对应的数据。&lt;/p&gt;
&lt;p&gt;Eaxmple1发送携带参数的URL到Example2:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *string = @&amp;#34;Example2://name=jiangbin#age=1&amp;#34;;&amp;#10;NSURL *url = [NSURL URLWithString:string];&amp;#10;[[UIApplication sharedApplication] openURL:url];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Example2处理URL请求并解析:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&amp;#10;&amp;#123;&amp;#10;&amp;#160; &amp;#160; if ([[url scheme] isEqualToString:@&amp;#34;Example2&amp;#34;]) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; NSString *content = [url resourceSpecifier];&amp;#10;        //&amp;#35299;&amp;#26512;content&amp;#33719;&amp;#21462;&amp;#25968;&amp;#25454;&amp;#10;        //...&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; return YES;&amp;#10;&amp;#160; &amp;#160; &amp;#125;&amp;#10;&amp;#160; &amp;#160; return NO;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Shared-Keychain-Access&quot;&gt;&lt;a href=&quot;#Shared-Keychain-Access&quot; class=&quot;headerlink&quot; title=&quot;Shared Keychain Access&quot;&gt;&lt;/a&gt;Shared Keychain Access&lt;/h4&gt;&lt;p&gt;iOS的keychain提供一种安全保存信息的方式，可以保存密码等数据，而且keychain中的数据不会因为你删除app而丢失，你可以在重新安装后继续读取keychain中的数据。通常每个应用程序只允许访问自己在keychain中保存的数据，不过假如你使用同一个证书的话，不同的app也可以通过keychain来实现应用间的数据共享。&lt;/p&gt;
&lt;p&gt;为了实现keychain共享数据，我们需要开启Keychain Sharing，开启方法如下，然后添加设置相同的Keychain Group，不过别忘记了添加Security.framework。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/458529-00ce1a0c8ccf752c.png&quot; alt=&quot;Example1&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/2.png&quot; alt=&quot;Example2&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;Example1保存数据到keychain(为了简单使用&lt;a href=&quot;https://github.com/soffes/sskeychain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SSKeychian&lt;/a&gt;)&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)setKeyChain&amp;#10;&amp;#123;&amp;#10;    [SSKeychain setPassword:@&amp;#34;shareData&amp;#34; forService:@&amp;#34;myservice&amp;#34; account:@&amp;#34;jiangbin&amp;#34;];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example2读取数据&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (IBAction)getByKeychain:(id)sender&amp;#10;&amp;#123;&amp;#10;    NSString *myData = [SSKeychain passwordForService:@&amp;#34;myservice&amp;#34; account:@&amp;#34;jiangbin&amp;#34;];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;App-Groups&quot;&gt;&lt;a href=&quot;#App-Groups&quot; class=&quot;headerlink&quot; title=&quot;App Groups&quot;&gt;&lt;/a&gt;App Groups&lt;/h4&gt;&lt;p&gt;iOS8之后苹果加入了App Groups功能，应用程序之间可以通过同一个group来共享资源，app group可以通过NSUserDefaults进行小量数据的共享，如果需要共享较大的文件可以通过NSFileCoordinator、NSFilePresenter等方式。&lt;br&gt;开启app groups，需要添加一个group name，app之间通过这个group共享数据：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/16-2-15%2F66665066.jpg&quot; alt=&quot;App Groups&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;Example1根据group name设置内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)setAppGroup&amp;#10;&amp;#123;&amp;#10;    NSUserDefaults *myDefaults = [[NSUserDefaults alloc]&amp;#10;                                  initWithSuiteName:@&amp;#34;group.com.jiangbin.SharedData&amp;#34;];&amp;#10;    [myDefaults setObject:@&amp;#34;shared data&amp;#34; forKey:@&amp;#34;mykey&amp;#34;];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example2根据group name读取数据&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)getByAppGroup&amp;#10; &amp;#123;&amp;#10;    NSUserDefaults *myDefaults = [[NSUserDefaults alloc]&amp;#10;                                  initWithSuiteName:@&amp;#34;group.com.jiangbin.SharedData&amp;#34;];&amp;#10;    NSString *content = [myDefaults objectForKey:@&amp;#34;mykey&amp;#34;];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道iOS由于沙盒的存在，应用程序不能越过自己的区域去访问别的存储空间的内容，不过可能有许多场景我们需要在应用程序之间共享数据，比如多个应用共用用户名密码进行登录等。虽然我们不能直接通过文件系统来分享数据，不过还是有些方法可以实现，为了方便说明，这里同时创建了两个工程Example1和Example2，实现这两个app之间的信息共享，Example1负责写数据，Example2负责读数据，具体的demo代码可以到&lt;a href=&quot;https://github.com/FreeMind-LJ/SharedDataDemo&quot;&gt;这里&lt;/a&gt;获取&lt;/p&gt;
&lt;h4 id=&quot;UIPasteboard&quot;&gt;&lt;a href=&quot;#UIPasteboard&quot; class=&quot;headerlink&quot; title=&quot;UIPasteboard&quot;&gt;&lt;/a&gt;UIPasteboard&lt;/h4&gt;&lt;p&gt;剪贴板是应用程序之间传递数据的简单方式，建议不要使用全局的粘贴板，而是自己根据名字创建一个新的粘贴板，防止其它地方全局拷贝的影响。然后把需要共享的内容复制到粘贴板，粘贴板的内容可以是文本、URL、图片和UIColor等，另一个app就可以根据粘贴板的名字去读取相关的信息。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>细说@synchronized和dispatch_once</title>
    <link href="http://freemind-lj.github.io/2016/01/07/%E7%BB%86%E8%AF%B4-synchronized%E5%92%8Cdispatch-once/"/>
    <id>http://freemind-lj.github.io/2016/01/07/细说-synchronized和dispatch-once/</id>
    <published>2016-01-07T09:43:12.000Z</published>
    <updated>2016-02-15T02:54:57.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;工欲善其事&lt;/em&gt;,&lt;em&gt;必先利其器&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  通常我们在实现单例时候都会使用synchronized或者dispatch_once方法，初始化往往是下面的样子：&lt;br&gt;使用synchronized方法实现：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static id obj = nil;&amp;#10;+(instancetype)shareInstance&amp;#10;&amp;#123;&amp;#10;    @synchronized(self) &amp;#123;&amp;#10;        if (!obj) &amp;#123;&amp;#10;            obj = [[SingletonObj alloc] init];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    return obj;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用dispatch_once方法实现：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static id obj = nil;&amp;#10;+(instancetype)shareInstance&amp;#10;&amp;#123;&amp;#10;    static dispatch_once_t onceToken;&amp;#10;    dispatch_once(&amp;#38;onceToken, ^&amp;#123;&amp;#10;        obj = [[SingletonObj alloc] init];&amp;#10;    &amp;#125;);&amp;#10;    return obj;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&quot;性能差异&quot;&gt;&lt;a href=&quot;#性能差异&quot; class=&quot;headerlink&quot; title=&quot;性能差异&quot;&gt;&lt;/a&gt;性能差异&lt;/h5&gt;&lt;p&gt;  上面的这些写法大家应该都很熟悉，既然两种方式都能实现，我们来看看两者的性能差异，这里简单写了个测试的&lt;a href=&quot;https://github.com/FreeMind-LJ/SingletonTest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo&lt;/a&gt;，使用两个方法分单线程跟多线程(采用dispatch_apply方式，性能相对较高)去访问一个单例对象一百万次，对比这期间的耗时，从iPod跟5s测试得到如下的结果&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//ipod&amp;#65292;&amp;#20027;&amp;#32447;&amp;#31243;&amp;#10;   SingletonTest[4285:446820] synchronized time cost:2.202945s&amp;#10;   SingletonTest[4285:446820] dispatch_once time cost:0.761034s&amp;#10;   &amp;#10;   //5s&amp;#65292;&amp;#20027;&amp;#32447;&amp;#31243;&amp;#10;   SingletonTest[5372:2394430] synchronized time cost:0.466293s&amp;#10;   SingletonTest[5372:2394430] dispatch_once time cost:0.070822s&amp;#10;&amp;#10;   //ipod&amp;#65292;&amp;#22810;&amp;#32447;&amp;#31243;&amp;#10;   SingletonTest[4315:448499] synchronized time cost:3.385109s&amp;#10;   SingletonTest[4315:448499] dispatch_once time cost:0.908009s&amp;#10;   &amp;#10;   //5s&amp;#65292;&amp;#22810;&amp;#32447;&amp;#31243;&amp;#10;   SingletonTest[5391:2399069] synchronized time cost:0.507504s&amp;#10;   SingletonTest[5391:2399069] dispatch_once time cost:0.169934s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  可以发现dispatch_once方法的性能要明显优于synchronized方法(多线程不采用dispathc_apply方式差距更明显)，所以在实际的应用中我们可以多采用dispatch_once方式来实现单例。通常使用的时候了解这些就够了，不过想知道两者的具体差异就需要我们再迈进一步。&lt;/p&gt;
&lt;h5 id=&quot;深入-synchronized-object&quot;&gt;&lt;a href=&quot;#深入-synchronized-object&quot; class=&quot;headerlink&quot; title=&quot;深入@synchronized(object)&quot;&gt;&lt;/a&gt;深入@synchronized(object)&lt;/h5&gt;&lt;p&gt;  翻看苹果的&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;可以发现 @synchronized指令内部使用锁来实现多线程的安全访问，并且隐式添加了一个异常处理的handler，当异常发生时会自动释放锁。在&lt;a href=&quot;http://stackoverflow.com/questions/1215330/how-does-synchronized-lock-unlock-in-objective-c/6047218#6047218&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow&lt;/a&gt;上看到@synchronized指令其实可以转换成objc_sync_enter跟objc_sync_exit，可以在&lt;objc objc-sync.h=&quot;&quot;&gt;头文件中找到这两个函数:&lt;/objc&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//Allocates recursive pthread_mutex associated with &amp;#39;obj&amp;#39; if needed&amp;#10;int objc_sync_enter(id obj)&amp;#10;&amp;#10;//End synchronizing on &amp;#39;obj&amp;#39;&amp;#10;int objc_sync_exit(id obj)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  根据注释文档，objc_sync_enter会根据需要给每个传进来的对象创建一个互斥锁并lock，然后objc_sync_exit的时候unlock，这样就可以通过这个锁来实现多线程的安全访问，所以结合苹果文档可以认为&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@synchronized(self) &amp;#123;&amp;#10;&amp;#9;//thread safe code&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等价于&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@try &amp;#123;&amp;#10;    objc_sync_enter(self);&amp;#10;    // thread safe code&amp;#10;&amp;#125; @finally &amp;#123;&amp;#10;    objc_sync_exit(self);    &amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;  庆幸的是苹果已经将objc-runtime这部分开源，所以我们可以更进一步了解内部的实现，源码在&lt;a href=&quot;http://www.opensource.apple.com/source/objc4/objc4-680/runtime/objc-sync.mm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;，有兴趣也可以自己去查阅，这里简单介绍一下。&lt;br&gt;让我们先来看看几个数据结构，其中有些涉及到缓存，我们就不去考虑了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct SyncData &amp;#123;&amp;#10;    struct SyncData* nextData;&amp;#10;    DisguisedPtr&amp;#60;objc_object&amp;#62; object;&amp;#10;    int32_t threadCount;  // number of THREADS using this block&amp;#10;    recursive_mutex_t mutex;&amp;#10;&amp;#125; SyncData;&amp;#10;&amp;#10;struct SyncList &amp;#123;&amp;#10;    SyncData *data;&amp;#10;    spinlock_t lock;&amp;#10;&amp;#125;;&amp;#10;&amp;#10;#define LOCK_FOR_OBJ(obj) sDataLists[obj].lock&amp;#10;#define LIST_FOR_OBJ(obj) sDataLists[obj].data&amp;#10;static StripedMap&amp;#60;SyncList&amp;#62; sDataLists;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;  首先看看SyncData这个数据结构，包含一个指向object的指针，这个object对象就是我们@synchronized时传进来的对象，也包含一个跟object关联的递归互斥锁recursive_mutex_t，该锁用来互斥访问object对象；同时还包含一个指向下一个SyncData的指针nextData，可以看出SyncData是一个链表中的节点；至于threadCount，这个值标示有几个线程正在访问这个对象，当threadCount==0的时候，会重用该SyncData对象，这是为了节省内存。&lt;br&gt;  接下来看看SyncList，SyncList其实就是一个链表，data指向第一个SyncData节点，lock则是为了多线程安全访问该链表。&lt;br&gt;  最后看下sDataLists静态哈希表对象，它以obj的指针为key,对应的value为SyncList链表。&lt;br&gt;  了解上面之后，我们就可以看看objc_sync_enter跟objc_sync_exit的具体实现（摘取部分代码）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#10;//&amp;#26681;&amp;#25454;object&amp;#23545;&amp;#35937;&amp;#21435;&amp;#26597;&amp;#35810;&amp;#30456;&amp;#24212;&amp;#30340;SyncData&amp;#23545;&amp;#35937;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#27809;&amp;#26377;&amp;#21017;&amp;#21019;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#26032;&amp;#30340;&amp;#10;static SyncData* id2data(id object, enum usage why)&amp;#10;&amp;#123;&amp;#10;    spinlock_t *lockp = &amp;#38;LOCK_FOR_OBJ(object);&amp;#10;    SyncData **listp = &amp;#38;LIST_FOR_OBJ(object);&amp;#10;    SyncData* result = NULL;&amp;#10;    &amp;#10;    //lock&amp;#65292;&amp;#22810;&amp;#32447;&amp;#31243;&amp;#23433;&amp;#20840;&amp;#35775;&amp;#38382;SyncList&amp;#10;    lockp-&amp;#62;lock();&amp;#10;    &amp;#123;&amp;#10;        SyncData* p;&amp;#10;        SyncData* firstUnused = NULL;&amp;#10;        for (p = *listp; p != NULL; p = p-&amp;#62;nextData) &amp;#123;&amp;#10;            //&amp;#25214;&amp;#21040;object&amp;#23545;&amp;#35937;&amp;#23545;&amp;#24212;&amp;#30340;SyncData&amp;#23545;&amp;#35937;&amp;#65292;&amp;#22686;&amp;#21152;&amp;#20854;threadCount&amp;#35745;&amp;#25968;&amp;#65292;&amp;#28982;&amp;#21518;&amp;#36820;&amp;#22238;&amp;#10;            if ( p-&amp;#62;object == object ) &amp;#123;&amp;#10;                result = p;&amp;#10;                OSAtomicIncrement32Barrier(&amp;#38;result-&amp;#62;threadCount);&amp;#10;                goto done;&amp;#10;            &amp;#125;&amp;#10;            //&amp;#24403;threadCount == 0&amp;#26102;&amp;#65292;&amp;#35774;&amp;#32622;&amp;#24403;&amp;#21069;SyncData&amp;#20026;&amp;#21487;&amp;#37325;&amp;#29992;&amp;#10;            if ( (firstUnused == NULL) &amp;#38;&amp;#38; (p-&amp;#62;threadCount == 0) )&amp;#10;                firstUnused = p;&amp;#10;        &amp;#125;&amp;#10;        // &amp;#22914;&amp;#26524;&amp;#26377;&amp;#21487;&amp;#37325;&amp;#29992;&amp;#30340;&amp;#33410;&amp;#28857;&amp;#65292;&amp;#21017;&amp;#20351;&amp;#29992;&amp;#24403;&amp;#21069;SyncData&amp;#33410;&amp;#28857;&amp;#65292;SyncData&amp;#30340;object&amp;#25351;&amp;#38024;&amp;#25351;&amp;#21521;&amp;#26032;&amp;#30340;object&amp;#23545;&amp;#35937;&amp;#10;        if ( firstUnused != NULL ) &amp;#123;&amp;#10;            result = firstUnused;&amp;#10;            result-&amp;#62;object = (objc_object *)object;&amp;#10;            result-&amp;#62;threadCount = 1;&amp;#10;            goto done;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    //&amp;#22914;&amp;#26524;&amp;#27809;&amp;#26377;&amp;#21487;&amp;#37325;&amp;#29992;&amp;#30340;&amp;#33410;&amp;#28857;&amp;#65292;&amp;#21017;&amp;#21019;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#26032;&amp;#30340;SyncData&amp;#33410;&amp;#28857;&amp;#10;    result = (SyncData*)calloc(sizeof(SyncData), 1);&amp;#10;&amp;#10;    //&amp;#23558;&amp;#26032;&amp;#30340;SyncData&amp;#33410;&amp;#28857;&amp;#30340;object&amp;#25351;&amp;#38024;&amp;#25351;&amp;#21521;&amp;#20256;&amp;#36827;&amp;#26469;&amp;#30340;object&amp;#23545;&amp;#35937;&amp;#10;    result-&amp;#62;object = (objc_object *)object;&amp;#10;    result-&amp;#62;threadCount = 1;&amp;#10;&amp;#10;    //&amp;#21019;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#26032;&amp;#30340;&amp;#19982;&amp;#35813;object&amp;#20851;&amp;#32852;&amp;#30340;&amp;#36882;&amp;#24402;&amp;#20114;&amp;#26021;&amp;#38145;&amp;#10;    new (&amp;#38;result-&amp;#62;mutex) recursive_mutex_t();&amp;#10;    result-&amp;#62;nextData = *listp;&amp;#10;    *listp = result;&amp;#10;    &amp;#10; done:&amp;#10;    lockp-&amp;#62;unlock();&amp;#10;    return result;&amp;#10;&amp;#125;&amp;#10;&amp;#10;int objc_sync_enter(id obj)&amp;#10;&amp;#123;&amp;#10;    int result = OBJC_SYNC_SUCCESS;&amp;#10;    if (obj) &amp;#123;&amp;#10;        //&amp;#26681;&amp;#25454;obj&amp;#25351;&amp;#38024;&amp;#30340;&amp;#21704;&amp;#24076;&amp;#20540;&amp;#26597;&amp;#25214;&amp;#23545;&amp;#24212;&amp;#30340;SyncData,threadcount&amp;#35745;&amp;#25968;&amp;#21152;&amp;#19968;&amp;#10;        SyncData* data = id2data(obj, ACQUIRE);&amp;#10;&amp;#10;        //&amp;#20351;&amp;#29992;SyncData&amp;#30340;&amp;#20114;&amp;#26021;&amp;#38145;&amp;#19978;&amp;#38145;&amp;#10;        data-&amp;#62;mutex.lock();&amp;#10;    &amp;#125; else &amp;#123;&amp;#10;        // @synchronized(nil) &amp;#20256;&amp;#20837;nil&amp;#26102;&amp;#20160;&amp;#20040;&amp;#20063;&amp;#19981;&amp;#22788;&amp;#29702;&amp;#10;    &amp;#125;&amp;#10;    return result;&amp;#10;&amp;#125;&amp;#10;&amp;#10;int objc_sync_exit(id obj)&amp;#10;&amp;#123;&amp;#10;    int result = OBJC_SYNC_SUCCESS;&amp;#10;    if (obj) &amp;#123;&amp;#10;        //&amp;#26681;&amp;#25454;obj&amp;#25351;&amp;#38024;&amp;#30340;&amp;#21704;&amp;#24076;&amp;#20540;&amp;#26597;&amp;#25214;&amp;#23545;&amp;#24212;&amp;#30340;SyncData&amp;#65292;threadcount&amp;#35745;&amp;#25968;&amp;#20943;&amp;#19968;&amp;#10;        SyncData* data = id2data(obj, RELEASE);&amp;#10;&amp;#10;        //&amp;#20351;&amp;#29992;SyncData&amp;#30340;&amp;#20114;&amp;#26021;&amp;#38145;&amp;#35299;&amp;#38145; &amp;#10;        bool okay = data-&amp;#62;mutex.tryUnlock();&amp;#10;        if (!okay) &amp;#123;&amp;#10;           result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125; else &amp;#123;&amp;#10;        // @synchronized(nil) &amp;#20256;&amp;#20837;nil&amp;#26102;&amp;#20160;&amp;#20040;&amp;#20063;&amp;#19981;&amp;#22788;&amp;#29702;&amp;#10;    &amp;#125;&amp;#10;    return result;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  简单来说，调用objc_sync_enter(obj)时，会根据obj指针在哈希表sDataLists对应的链表SyncList，然后在链表中查询对应obj的SyncData对象，如果查询不到则创建一个新的SyncData对象（包含创建跟obj相关的递归互斥锁）并添加到链表中，然后使用SyncData对象上锁；调用objc_sync_exit(obj)时，使用SyncData对象解锁，因此通过这个锁便可确保@synchronized之间的代码线程安全。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/sDataLists.png&quot; alt=&quot;sDataLists&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h5 id=&quot;深入dispatch-once&quot;&gt;&lt;a href=&quot;#深入dispatch-once&quot; class=&quot;headerlink&quot; title=&quot;深入dispatch_once&quot;&gt;&lt;/a&gt;深入dispatch_once&lt;/h5&gt;&lt;p&gt;探讨了synchronized之后，我们再来说说dispatch_once。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;  根据&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/#//apple_ref/c/func/dispatch_once&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;,dispatch_once可以用来初始化一些全局的数据，它能够确保block代码在app的生命周期内仅被运行一次，而且还是线程安全的，不需要额外加锁；predicate必须指向一个全局或者静态的变量，不过使用predicate的话结果是未定义的，不过predicate有啥作用，如何实现block在整个生命周期执行一次？那我们只能从源码查找(源码地址：&lt;a href=&quot;http://opensource.apple.com/source/libdispatch/libdispatch-84.5/src/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;once&lt;/a&gt;)。&lt;br&gt;不过在这之前先简要介绍一下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;bool __sync_bool_compare_and_swap (type &lt;em&gt;ptr, type oldval type newval, …)&lt;br&gt;提供原子的比较和交换操作，如果当前值&lt;/em&gt;ptr == oldval，就将newval写入*ptr，当比较赋值操作成功后返回true&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;*__sync_synchronize (…)&lt;br&gt;调用这个函数会产生一个full &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_barrier&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;memory barrier&lt;/a&gt; ，用于保证CPU按照我们代码编写的顺序来执行代码，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;doJob1();&amp;#10; doJob2();&amp;#10; __sync_synchronize();  //Job3&amp;#20250;&amp;#22312;Job1&amp;#36319;Job2&amp;#23436;&amp;#25104;&amp;#21518;&amp;#25165;&amp;#25191;&amp;#34892;&amp;#10;doJob3();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;type __sync_swap(type *ptr, type value, …)&lt;br&gt;提供原子交换操作的函数，交换第一个跟第二个参数的值，然后返回交换前第一个参数的旧值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;_dispatch_hardware_pause()&lt;br&gt;调用这个函数主要是暗示处理器不要做额外的优化处理等，提高性能，节省CPU时间，可以查看&lt;a href=&quot;http://www.searchtb.com/2011/06/spinlock%E5%89%96%E6%9E%90%E4%B8%8E%E6%94%B9%E8%BF%9B.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;了解更多&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;信号量&lt;br&gt;信号量是一个非负整数，定义了两种原子操作：wait跟signal来进行访，信号量主要用于线程同步。当一个线程调用wait操作时，如果信号量的值大于0，则获得资源并将信号量值减一，如果等于0线程睡眠直到信号量值大于0或者超时；singal将信号量的值加1，如果这时候有正在等待的线程，唤醒该线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#21019;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#65292;&amp;#20854;&amp;#20540;&amp;#20026;0        &amp;#10;dispatch_semaphore_t sema = dispatch_semaphore_create(0);&amp;#10;ABAddressBookRequestAccessWithCompletion(addressBook, ^(bool granted, CFErrorRef error) &amp;#123;&amp;#10;&amp;#9;//&amp;#25805;&amp;#20316;&amp;#23436;&amp;#25104;&amp;#21518;&amp;#65292;&amp;#35843;&amp;#29992;signal&amp;#20449;&amp;#21495;&amp;#37327;+1&amp;#10;    dispatch_semaphore_signal(sema);&amp;#10;&amp;#125;);&amp;#10;//&amp;#31561;&amp;#24453;dispatch_semaphore_signal&amp;#23558;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#20540;&amp;#21152;1&amp;#21518;&amp;#25165;&amp;#32487;&amp;#32493;&amp;#36816;&amp;#34892;&amp;#10;dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  接下来看看具体代码，当我们调用dispatch_once时候，内部是调用dispatch_once_f函数，其中val就是外部传入的predicate值，ctxt为Block的指针，func则是Block内部具体实现的函数指针，由于源码比较短，所以我直接把源码贴出来(为了方便查看，有些不使用宏定义)。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct _dispatch_once_waiter_s &amp;#123;&amp;#10;    volatile struct _dispatch_once_waiter_s *volatile dow_next;&amp;#10;    _dispatch_thread_semaphore_t dow_sema;&amp;#10;&amp;#125;;&amp;#10;#define DISPATCH_ONCE_DONE ((struct _dispatch_once_waiter_s *)~0l)&amp;#10;void dispatch_once(dispatch_once_t *val, dispatch_block_t block)&amp;#10;&amp;#123;&amp;#10;    struct Block_basic *bb = (void *)block;&amp;#10;    dispatch_once_f(val, block, (void *)bb-&amp;#62;Block_invoke);&amp;#10;&amp;#125;&amp;#10;&amp;#10;void dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func)&amp;#10;&amp;#123;&amp;#10;    //volatile&amp;#65292;&amp;#26631;&amp;#31034;&amp;#35813;&amp;#21464;&amp;#37327;&amp;#38543;&amp;#26102;&amp;#21487;&amp;#33021;&amp;#25913;&amp;#21464;&amp;#65292;&amp;#32534;&amp;#35793;&amp;#22120;&amp;#19981;&amp;#20250;&amp;#23545;&amp;#35775;&amp;#38382;&amp;#35813;&amp;#21464;&amp;#37327;&amp;#30340;&amp;#20195;&amp;#30721;&amp;#36827;&amp;#34892;&amp;#20248;&amp;#21270;&amp;#65292;&amp;#27599;&amp;#27425;&amp;#37117;&amp;#20174;&amp;#20869;&amp;#23384;&amp;#21435;&amp;#35835;&amp;#21462;&amp;#65292;&amp;#32780;&amp;#19981;&amp;#20351;&amp;#29992;&amp;#23492;&amp;#23384;&amp;#22120;&amp;#37324;&amp;#30340;&amp;#20540;&amp;#10;    struct _dispatch_once_waiter_s * volatile *vval =&amp;#10;            (struct _dispatch_once_waiter_s**)val;&amp;#10;    struct _dispatch_once_waiter_s dow = &amp;#123; NULL, 0 &amp;#125;;&amp;#10;    struct _dispatch_once_waiter_s *tail, *tmp;&amp;#10;    _dispatch_thread_semaphore_t sema;&amp;#10;&amp;#10;    //&amp;#31532;&amp;#19968;&amp;#27425;&amp;#25191;&amp;#34892;&amp;#30340;&amp;#26102;&amp;#20505;&amp;#65292;predicate&amp;#30340;&amp;#20540;&amp;#20026;0&amp;#65292;&amp;#25152;&amp;#20197;vval&amp;#65309;NULL&amp;#65292;&amp;#21407;&amp;#23376;&amp;#27604;&amp;#36739;&amp;#20132;&amp;#25442;&amp;#20989;&amp;#25968;&amp;#36820;&amp;#22238;true&amp;#10;    //&amp;#28982;&amp;#21518;vval&amp;#25351;&amp;#21521;dow(dispatch_once_waiter_s&amp;#65292;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#30340;&amp;#20540;&amp;#20026;0&amp;#65292;&amp;#21363;&amp;#31561;&amp;#24453;&amp;#20013;)&amp;#10;    if (__sync_bool_compare_and_swap(vval, NULL, &amp;#38;dow)) &amp;#123;&amp;#10;&amp;#10;        //&amp;#31354;&amp;#30340;&amp;#23439;&amp;#23450;&amp;#20041;&amp;#65292;&amp;#21861;&amp;#20063;&amp;#19981;&amp;#20570;&amp;#10;        dispatch_atomic_acquire_barrier();&amp;#10;&amp;#10;        //&amp;#25191;&amp;#34892;dispatch_once&amp;#20256;&amp;#36827;&amp;#26469;&amp;#30340;block&amp;#10;        _dispatch_client_callout(ctxt, func);&amp;#10;        &amp;#10;        //&amp;#21518;&amp;#38754;&amp;#35299;&amp;#37322;&amp;#10;        dispatch_atomic_maximally_synchronizing_barrier();&amp;#10;        &amp;#10;        //&amp;#25191;&amp;#34892;&amp;#23436;block&amp;#20043;&amp;#21518;&amp;#65292;&amp;#23558;vval&amp;#30340;&amp;#20540;&amp;#35774;&amp;#20026;DISPATCH_ONCE_DONE(&amp;#21363;predicate&amp;#35774;&amp;#20026;~0l&amp;#65289;&amp;#10;        tmp = __sync_swap(vval, DISPATCH_ONCE_DONE);  &amp;#10;        tail = &amp;#38;dow;&amp;#10;&amp;#10;        //1.&amp;#22914;&amp;#26524;&amp;#22312;block&amp;#30340;&amp;#25191;&amp;#34892;&amp;#36807;&amp;#31243;&amp;#20013;&amp;#65292;&amp;#27809;&amp;#26377;&amp;#20854;&amp;#32447;&amp;#31243;&amp;#35843;&amp;#29992;&amp;#35813;&amp;#20989;&amp;#25968;&amp;#31561;&amp;#24453;&amp;#65292;tmp&amp;#30340;&amp;#20540;&amp;#20063;&amp;#20026;&amp;#38;dow,tail==tmp&amp;#65292;&amp;#24490;&amp;#29615;&amp;#30340;&amp;#26465;&amp;#20214;&amp;#19981;&amp;#28385;&amp;#36275;&amp;#65292;&amp;#20989;&amp;#25968;&amp;#25191;&amp;#34892;&amp;#23436;&amp;#27605;&amp;#10;        //2.&amp;#22914;&amp;#26524;&amp;#22312;block&amp;#30340;&amp;#25191;&amp;#34892;&amp;#36807;&amp;#31243;&amp;#20013;&amp;#65292;&amp;#26377;&amp;#20854;&amp;#32447;&amp;#31243;&amp;#35843;&amp;#29992;&amp;#35813;&amp;#20989;&amp;#25968;&amp;#31561;&amp;#24453;&amp;#65292;&amp;#21382;&amp;#36941;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#38142;&amp;#34920;&amp;#65292;&amp;#36880;&amp;#20010;&amp;#21796;&amp;#37266;&amp;#32447;&amp;#31243;&amp;#32487;&amp;#32493;&amp;#36816;&amp;#34892;&amp;#10;        while (tail != tmp) &amp;#123;&amp;#10;            //&amp;#22914;&amp;#26524;&amp;#20013;&amp;#36884;&amp;#26377;&amp;#20854;&amp;#23427;&amp;#32447;&amp;#31243;&amp;#23558;vval&amp;#36171;&amp;#20540;&amp;#38;dow&amp;#65292;&amp;#36825;&amp;#26399;&amp;#38388;dow_next&amp;#20540;&amp;#20026;NULL&amp;#65292;&amp;#38656;&amp;#35201;&amp;#31561;&amp;#24453;&amp;#65292;&amp;#21442;&amp;#35265;else&amp;#20998;&amp;#25903;&amp;#30340;__sync_bool_compare_and_swap&amp;#35843;&amp;#29992;&amp;#10;            while (!tmp-&amp;#62;dow_next) &amp;#123;&amp;#10;                _dispatch_hardware_pause();&amp;#10;            &amp;#125;&amp;#10;            sema = tmp-&amp;#62;dow_sema;&amp;#10;            tmp = (struct _dispatch_once_waiter_s*)tmp-&amp;#62;dow_next;&amp;#10;            _dispatch_thread_semaphore_signal(sema);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    else &amp;#10;    &amp;#123;   &amp;#10;        //&amp;#22914;&amp;#26524;vval&amp;#19981;&amp;#31561;NULL&amp;#65292;&amp;#36208;&amp;#36825;&amp;#20010;&amp;#20998;&amp;#25903;&amp;#65292;&amp;#38750;&amp;#31532;&amp;#19968;&amp;#27425;&amp;#35843;&amp;#29992;dispatch_once&amp;#65292;&amp;#20854;&amp;#23427;&amp;#32447;&amp;#31243;&amp;#35843;&amp;#29992;&amp;#10;        //&amp;#33719;&amp;#21462;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#26377;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#21017;&amp;#36820;&amp;#22238;&amp;#35813;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#27809;&amp;#26377;&amp;#21017;&amp;#22312;&amp;#24403;&amp;#21069;&amp;#32447;&amp;#31243;&amp;#21019;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#26032;&amp;#30340;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#10;        dow.dow_sema = _dispatch_get_thread_semaphore();&amp;#10;        for (;;) &amp;#123;&amp;#10;            tmp = *vval;&amp;#10;&amp;#10;            //vval&amp;#24050;&amp;#32463;&amp;#34987;&amp;#36171;&amp;#20540;&amp;#20026;~0l&amp;#65292;&amp;#35777;&amp;#26126;block&amp;#24050;&amp;#32463;&amp;#34987;&amp;#25191;&amp;#34892;&amp;#20102;&amp;#65292;&amp;#36864;&amp;#20986;&amp;#28982;&amp;#21518;&amp;#35843;&amp;#29992;_dispatch_put_thread_semaphore&amp;#38144;&amp;#27585;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#10;            if (tmp == DISPATCH_ONCE_DONE) &amp;#123;&amp;#10;                break;&amp;#10;            &amp;#125;&amp;#10;            //&amp;#31354;&amp;#30340;&amp;#23439;&amp;#23450;&amp;#20041;&amp;#65292;&amp;#21861;&amp;#20063;&amp;#19981;&amp;#20570;&amp;#10;            dispatch_atomic_store_barrier();&amp;#10;&amp;#10;            //&amp;#23558;&amp;#24403;&amp;#21069;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#21152;&amp;#20837;&amp;#21040;&amp;#20449;&amp;#21495;&amp;#38142;&amp;#34920;&amp;#20013;&amp;#65292;&amp;#28982;&amp;#21518;&amp;#32447;&amp;#31243;&amp;#31561;&amp;#24453;&amp;#65292;&amp;#10;            if (__sync_bool_compare_and_swap(vval, tmp, &amp;#38;dow)) &amp;#123;&amp;#10;                dow.dow_next = tmp;&amp;#10;                _dispatch_thread_semaphore_wait(dow.dow_sema);&amp;#10;            &amp;#125;&amp;#10;&amp;#10;            //&amp;#22914;&amp;#26524;vval&amp;#30340;&amp;#25351;&amp;#21521;&amp;#20540;&amp;#19981;&amp;#20877;&amp;#26159;tmp&amp;#65292;&amp;#21487;&amp;#33021;&amp;#20854;&amp;#23427;&amp;#32447;&amp;#31243;&amp;#21516;&amp;#26102;&amp;#36827;&amp;#20837;&amp;#35813;&amp;#20998;&amp;#25903;&amp;#65292;&amp;#28982;&amp;#21518;&amp;#35843;&amp;#29992;__sync_bool_compare_and_swap&amp;#21407;&amp;#23376;&amp;#25805;&amp;#20316;&amp;#23558;vval&amp;#25351;&amp;#21521;&amp;#20102;&amp;#26032;&amp;#30340;&amp;#33410;&amp;#28857;&amp;#65292;&amp;#10;            //&amp;#21017;&amp;#37325;&amp;#26032;&amp;#24320;&amp;#22987;for&amp;#24490;&amp;#29615;&amp;#10;        &amp;#125;&amp;#10;        _dispatch_put_thread_semaphore(dow.dow_sema);&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;让我们来看看dispatch_once是如何确保block只执行一次。简单来说，当线程A在调用执行block并设置predicate为DISPATCH_ONCE_DONE(~0l)期间，如果有其他线程也在调用disptach_once，则这些线程会等待，各线程对应的信号量会加入到信号量链表中，等predicate设置为DISPATCH_ONCE_DONE后，也就是block执行完了，会根据信号量链表唤醒各个线程使其继续执行。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%93%BE%E8%A1%A8.png&quot; alt=&quot;信号量链表.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;  不过有一种临界情况，假如线程A在执行block，但是创建单例对象obj还未完成，这时候线程B获取该obj对象，此时obj＝nil，而线程B在线程A将predicate设为DISPATCH_ONCE_DONE之后读取predicate，这是线程B会认为单例对象已经初始化完成，然后使用空的obj对象，这就会导致错误发生。因此dispatch_once会在执行完block之后会执行dispatch_atomic_maximally_synchronizing_barrier()调用，这个调用会执行一些cpuid指令，确保线程A创建单例对象obj以及置predicate为DISPATCH_ONCE_DONE的时间TimeA大于线程B进入block并读取predicate值的时间TimeB。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define dispatch_atomic_maximally_synchronizing_barrier() \&amp;#10;    do &amp;#123; unsigned long _clbr; __asm__ __volatile__( \&amp;#10;    &amp;#34;cpuid&amp;#34; \&amp;#10;    : &amp;#34;=a&amp;#34; (_clbr) : &amp;#34;0&amp;#34; (0) : &amp;#34;ebx&amp;#34;, &amp;#34;ecx&amp;#34;, &amp;#34;edx&amp;#34;, &amp;#34;cc&amp;#34;, &amp;#34;memory&amp;#34; \&amp;#10;    ); &amp;#125; while(0)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;  除此之外，每次调用dispatch_once的时候，都会先判断predicate的值是否是~0l(也就是DISPATCH_ONCE_DONE)，如果是则意味着block已经执行过了，便不再执行，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block);&amp;#10;#ifdef __GNUC__&amp;#10;#define dispatch_once(x, ...) do &amp;#123; if (__builtin_expect(*(x), ~0l) != ~0l) dispatch_once((x), (__VA_ARGS__)); &amp;#125; while (0)&amp;#10;#endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;让我们看看这里面的__builtin_expect((x), (v))，这又是一个优化的地方。。。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__builtin_expect()&amp;#30446;&amp;#30340;&amp;#26159;&amp;#23558;&amp;#8220;&amp;#20998;&amp;#25903;&amp;#36716;&amp;#31227;&amp;#8221;&amp;#30340;&amp;#20449;&amp;#24687;&amp;#25552;&amp;#20379;&amp;#32473;&amp;#32534;&amp;#35793;&amp;#22120;&amp;#65292;&amp;#36825;&amp;#26679;&amp;#32534;&amp;#35793;&amp;#22120;&amp;#21487;&amp;#20197;&amp;#23545;&amp;#20195;&amp;#30721;&amp;#36827;&amp;#34892;&amp;#20248;&amp;#21270;&amp;#65292;&amp;#10;&amp;#20197;&amp;#20943;&amp;#23569;&amp;#25351;&amp;#20196;&amp;#36339;&amp;#36716;&amp;#24102;&amp;#26469;&amp;#30340;&amp;#24615;&amp;#33021;&amp;#19979;&amp;#38477;&amp;#12290;&amp;#10;__builtin_expect((x),1) &amp;#34920;&amp;#31034; x &amp;#30340;&amp;#20540;&amp;#20026;&amp;#30495;&amp;#30340;&amp;#21487;&amp;#33021;&amp;#24615;&amp;#26356;&amp;#22823;&amp;#65307; &amp;#10;__builtin_expect((x),0) &amp;#34920;&amp;#31034; x &amp;#30340;&amp;#20540;&amp;#20026;&amp;#20551;&amp;#30340;&amp;#21487;&amp;#33021;&amp;#24615;&amp;#26356;&amp;#22823;&amp;#12290;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;  由于dispatch_once的只执行block一次，所以我们更期望的是已经block已经执行完了，也就是predict的值为~0l的可能性更大。&lt;br&gt;  现在我们清楚dispatch_once是如何确保block只执行一次了，关键就在predict这个值，通过比较这个值等于0或者~0l来判断block是否执行过，这也就是为啥我们需要将这个值设为static或者全局的缘故，因为各个线程都要去访问这个predict，有兴趣的可以试试把predicate的初始值设为非0或者非静态全局变量会发生什么～～&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h4&gt;&lt;p&gt;  通过上面的分析，我们知道@synchronized采用的是递归互斥锁来实现线程安全，而dispatch_once的内部则使用了很多原子操作来替代锁，以及通过信号量来实现线程同步，而且有很多针对处理器优化的地方，甚至在if判断语句上也做了优化(逼格有点高)，使得其效率有很大的提升，虽然其源码很短，但里面包含的东西却很多，所以苹果也推荐使用dispatch_once来创建单例。通过这个简短的dispatch_once，你也可以清楚为什么GCD的性能会这么高了，感兴趣可以再去看看libdispatch的其它源码。。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.opensource.apple.com/source/objc4/objc4-680/runtime/objc-sync.mm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;objc-sync&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://rykap.com/objective-c/2015/05/09/synchronized.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;synchronized&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/#//apple_ref/c/func/dispatch_once&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dispatch_once&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html#Atomic-Builtins&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Built-in functions for atomic memory access&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://kernelnewbies.org/FAQ/LikelyUnlikely&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;__builtin_expect&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;工欲善其事&lt;/em&gt;,&lt;em&gt;必先利其器&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  通常我们在实现单例时候都会使用synchronized或者dispatch_once方法，初始化往往是下面的样子：&lt;br&gt;使用synchronized方法实现：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static id obj = nil;&amp;#10;+(instancetype)shareInstance&amp;#10;&amp;#123;&amp;#10;    @synchronized(self) &amp;#123;&amp;#10;        if (!obj) &amp;#123;&amp;#10;            obj = [[SingletonObj alloc] init];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    return obj;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用dispatch_once方法实现：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static id obj = nil;&amp;#10;+(instancetype)shareInstance&amp;#10;&amp;#123;&amp;#10;    static dispatch_once_t onceToken;&amp;#10;    dispatch_once(&amp;#38;onceToken, ^&amp;#123;&amp;#10;        obj = [[SingletonObj alloc] init];&amp;#10;    &amp;#125;);&amp;#10;    return obj;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&quot;性能差异&quot;&gt;&lt;a href=&quot;#性能差异&quot; class=&quot;headerlink&quot; title=&quot;性能差异&quot;&gt;&lt;/a&gt;性能差异&lt;/h5&gt;&lt;p&gt;  上面的这些写法大家应该都很熟悉，既然两种方式都能实现，我们来看看两者的性能差异，这里简单写了个测试的&lt;a href=&quot;https://github.com/FreeMind-LJ/SingletonTest&quot;&gt;demo&lt;/a&gt;，使用两个方法分单线程跟多线程(采用dispatch_apply方式，性能相对较高)去访问一个单例对象一百万次，对比这期间的耗时，从iPod跟5s测试得到如下的结果&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码剖析" scheme="http://freemind-lj.github.io/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>谈谈面向对象设计(OOD)原则</title>
    <link href="http://freemind-lj.github.io/2015/12/23/%E8%B0%88%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1-OOD-%E5%8E%9F%E5%88%99/"/>
    <id>http://freemind-lj.github.io/2015/12/23/谈谈面向对象设计-OOD-原则/</id>
    <published>2015-12-23T09:46:39.000Z</published>
    <updated>2016-02-15T02:59:52.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;拥有一把锤子未必能成为建筑师&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  最近在项目开发过程中碰到了一些问题，发现在每波迭代开发过程中，经常需要去修改之前的代码，虽然出现这样的情形很正常，新的需求必然会带来新的功能新的设计，导致之前的代码受到影响。记得看过一个笑话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“杀一个程序员不需要用枪，改三次需求就可以了”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  其实需求设计是一个方面，另外我们作为设计开发人员有时候也需要去反省，反省一下代码的设计是否合理，为什么新功能的在原有代码上扩展会那么难，为什么我们的代码这么不稳定，牵一发而动全身？&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;  我觉得能成为一名程序员，至少不会是一个笨的人，要完成一个功能，总能想办法实现（不然早被开除啦～），但实现的方法思路却有好有坏，不过认为思路可以被引导，软件开发不是才刚开始，它已经存在一段时间，我们可以吸收前人的一些经验教训来提高自己，比如GOF的《设计模式：可复用面向对象软件的基础》，帮我们总结了很多问题的解决思路。这段时间也花了点时间学习面向对象设计的一些思想，也谈谈自己的一些理解。&lt;br&gt;  提到设计模式，我想很多人都看过这块的一些书籍，不过不知道会不会有跟我一样的困惑：看的时候都理解，但是实际开发的时候却无法融入，后面慢慢就忘记了。尴尬，可能我们只是看到了某个模式的表面，而隐藏在模式后面的一些“真理”却没有去挖掘，这个模式是要解决什么问题？其实模式设计的背后都是为了遵循某种设计原则。&lt;/p&gt;
&lt;h4 id=&quot;“比设计模式更重要的是设计原则”&quot;&gt;&lt;a href=&quot;#“比设计模式更重要的是设计原则”&quot; class=&quot;headerlink&quot; title=&quot;“比设计模式更重要的是设计原则”&quot;&gt;&lt;/a&gt;“比设计模式更重要的是设计原则”&lt;/h4&gt;&lt;p&gt;  面相对象设计的概念大家也都知道，它的设计目标就是希望软件系统能做到以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可扩展：新特性能够很容易的添加到现有系统中，不会影响原本的东西&lt;/li&gt;
&lt;li&gt;可修改：当修改某一部分的代码时，不会影响到其它不相关的部分&lt;/li&gt;
&lt;li&gt;可替代：将系统中某部分的代码用其它有相同接口的类替换时，不会影响到现有系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这几个可以用来检测我们的软件系统是不是设计得合理，而如何设计出易于维护和扩展的软件系统是有设计原则可以遵循指导的，&lt;a href=&quot;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Robert C. Martin&lt;/a&gt;提出了面相对象设计的五个基本原则（SOLID）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S－单一职责原则&lt;/li&gt;
&lt;li&gt;O－开放关闭原则&lt;/li&gt;
&lt;li&gt;L－里氏替换原则&lt;/li&gt;
&lt;li&gt;I－接口隔离原则&lt;/li&gt;
&lt;li&gt;D－依赖倒置原则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  我们在进行面相对象设计的时候应该牢记这几个原则，这能让你成为更优秀的设计开发人员－－－至少你的代码不会那么烂，下面来简单了解一下这几个原则。&lt;/p&gt;
&lt;h3 id=&quot;单一职责原则：Single-Responsibility-Principle&quot;&gt;&lt;a href=&quot;#单一职责原则：Single-Responsibility-Principle&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则：Single Responsibility Principle&quot;&gt;&lt;/a&gt;单一职责原则：Single Responsibility Principle&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个类有且仅有一个职责，只有一个引起它变化的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  简单来说一个类只做好一件事就行，不去管跟自己不相干的，狗拿耗子多管闲事，其核心就是解耦以及高内聚。这个原则看着很简单，我们在写代码的时候即便不知道这个原则也会往这个方向靠拢，写出功能相对单一的类，不过这个原则很容易违背，因为可能由于某种原因，原来功能单一的类需要被细化成颗粒更小的职责1跟职责2，所以在每次迭代过程中可能需要重新梳理重构之前编写的代码，将不同的职责封装到不同的类或者模块中。&lt;br&gt;举个栗子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface DataTransfer : NSObject&amp;#10;-(void)upload:(NSData *)data; //&amp;#19978;&amp;#20256;&amp;#25968;&amp;#25454;&amp;#10;-(void)download(NSString*)url;  //&amp;#26681;&amp;#25454;URL&amp;#19979;&amp;#36733;&amp;#19996;&amp;#35199;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  DataTransfer包含上传跟下载功能，仔细考虑可以发现这相当于实现了两个功能，一个负责上传的相关逻辑，另一个负责下载的逻辑，而这个两个功能相对对立，当有一个功能改变的时候，比如我们之前是使用AFNetworking，现在想换成其它第三方或者nsurlconnection来实现上传跟下载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上传方式变更，导致DataTransfer变更&lt;/li&gt;
&lt;li&gt;下载方式变更，导致 DataTransfer变更&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  这就违反了单一职责的原则，所以需要将不同的功能拆解成两个不同的类，来负责各自的职责，不过这个拆的粒度可能因人而已，有时候并不需要拆的过细，不要成了为设计而设计。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3.png&quot; alt=&quot;单一职责&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;  在我们项目中经常看到很多违反这条原则的代码，而且违反的比较明显，许多类都是丰富功能的超级集合，整个类变得臃肿难以理解，这时候就需要我们有意识地去重构了。&lt;/p&gt;
&lt;p&gt;###开放关闭原则：Open Closed Principle&lt;br&gt;  开闭原则的定义是说一个软件实体如类，模块和函数应该对扩展开放，而对修改关闭，具体来说就是你应该通过扩展来实现变化，而不是通过修改原有的代码来实现变化，该原则是面相对象设计最基本的原则。&lt;br&gt;  之前说过在项目中每当需求需改的时候经常需要对代码有很大的改动，很大程度上就是因为我们对这个原则理解的不够透彻。&lt;br&gt;  开闭原则的关键在于抽象，我们需要抽象出那些不会变化或者基本不变的东西，这部分东西相对稳定，这也就是对修改关闭的地方（这并不意味着不可以再修改），而对于那些容易变化的部分我们也对其封装，但是这部分是可以动态修改的，这也就是对扩展开发的地方，比如设计模式中的策略模式和模板模式就是在实现这个原则（现在应该对模式有更感性的认识了吧～）。&lt;/p&gt;
&lt;p&gt;  举个例子：我们需要保存对象到数据库当中，其中有个类似save()的保存方法，这部分应该是不变的，接口相对稳定，而具体保存的实现却有可能不同，我们现在可能是保存在Sqlite数据库中，假如以后如果想保存到一个自己实现的数据库中时，我们只需要实现一个拥有同样接口的扩展类添加进去即可，这就是对扩展开放，不会对之前的代码造成任何影响，就可以实现保存到新数据库的功能，保证了系统的稳定性。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99.png&quot; alt=&quot;开闭原则&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;实现开闭原则的指导思想就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象出相对稳定的接口，这部分应该不改动或者很少改动&lt;/li&gt;
&lt;li&gt;封装变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  不过在软件开发过程中，要一开始就完全按照开闭原则来可能比较困难，更多的情况是在不断的迭代重构过程中去改进，在可预见的变化范围内去做设计。&lt;/p&gt;
&lt;h3 id=&quot;里氏替代原则：Liskov-Substitution-Principle&quot;&gt;&lt;a href=&quot;#里氏替代原则：Liskov-Substitution-Principle&quot; class=&quot;headerlink&quot; title=&quot;里氏替代原则：Liskov Substitution Principle&quot;&gt;&lt;/a&gt;里氏替代原则：Liskov Substitution Principle&lt;/h3&gt;&lt;p&gt;  该原则的定义：所有引用基类的地方必须能透明地使用其子类的对象。简单来说，所有使用基类代码的地方，如果换成子类对象的时候还能够正常运行，则满足这个原则，否则就是继承关系有问题，应该废除两者的继承关系，这个原则可以用来判断我们的对象继承关系是否合理。&lt;br&gt;比如有一个鲸鱼的类，我们让鲸鱼继承于鱼类，然后鱼类有个呼吸的功能：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E9%B2%B8%E9%B1%BC%E7%BB%A7%E6%89%BF%E8%87%AA%E9%B1%BC%E7%B1%BB.png&quot; alt=&quot;鲸鱼继承自鱼类&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;然后在水里的时候，鱼能够进行呼吸：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if(isInwater)&amp;#123;&amp;#10;    //&amp;#22312;&amp;#27700;&amp;#20013;&amp;#20102;&amp;#65292;&amp;#24320;&amp;#22987;&amp;#21628;&amp;#21560;&amp;#10;    fish.breath();&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;  当我们把鲸鱼这个子对象替换原来的基类鱼对象，鲸鱼在水里开始呼吸，这时问题就出现了，鲸鱼是哺乳动物，在水里呼吸是没法呼吸的，一直在水里就GG思密达了，所以这违反了该原则，我们就可以判断鲸鱼继承于鱼类不合理，需要去重新设计。&lt;br&gt;  通常在设计的时候，我们都会优先采用组合而不是继承，因为继承虽然减少了代码，提高了代码的重用性，但是父类跟子类会有很强的耦合性，破坏了封装。&lt;/p&gt;
&lt;h3 id=&quot;接口隔离原则：Interface-Segregation-Principle&quot;&gt;&lt;a href=&quot;#接口隔离原则：Interface-Segregation-Principle&quot; class=&quot;headerlink&quot; title=&quot;接口隔离原则：Interface Segregation Principle&quot;&gt;&lt;/a&gt;接口隔离原则：Interface Segregation Principle&lt;/h3&gt;&lt;p&gt;  该原则的定义：不能强迫用户去依赖那些他们不使用的接口。简单来说就是客户端需要什么接口，就提供给它什么样的接口，其它多余的接口就不要提供，不要让接口变得臃肿，否则当对象一个没有使用的方法被改变了，这个对象也将会受到影响。接口的设计应该遵循最小接口原则，其实这也是高内聚的一种表现，换句话说，使用多个功能单一、高内聚的接口总比使用一个庞大的接口要好。&lt;br&gt;  举个简单的例子：比如我们有个自行车接口，这个接口包含了很多方法，包括GPS定位，以及换挡的方法&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E4%B8%8D%E6%BB%A1%E8%B6%B3ISP%E5%8E%9F%E5%88%99.png&quot; alt=&quot;不满足ISP原则&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt; 然后我们发现即便普通的自行车也需要实现GPS定位以及换挡的功能，显然这违背了接口隔离的原则。遵循接口最小化的原则，我们重新设计：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E6%BB%A1%E8%B6%B3ISP%E5%8E%9F%E5%88%99.png&quot; alt=&quot;满足ISP原则&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;  这样一来每个接口的功能相对单一，使用多个专门的接口比使用一个总的接口要好，假如我们的山地车没有没有GPS定位的功能，我们不去继承实现对应的接口即可，在iOS开发中有很多这样的例子，比如UITalbleView的代理有两个不同的接口，UITableViewDataSource专门负责需要显示的内容，UITableViewDelegate专门负责一些view的自定义显示，然后我们会继承多个接口，这就满足了ISP原则。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController () &amp;#60;UITableViewDataSource,UITableViewDelegate,OtherProtocol&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;依赖倒置原则：Dependence-Inversion-Principle&quot;&gt;&lt;a href=&quot;#依赖倒置原则：Dependence-Inversion-Principle&quot; class=&quot;headerlink&quot; title=&quot;依赖倒置原则：Dependence Inversion Principle&quot;&gt;&lt;/a&gt;依赖倒置原则：Dependence Inversion Principle&lt;/h3&gt;&lt;p&gt;  该原则的定义：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。其实这就是我们经常说的“针对接口编程”，这里的接口就是抽象，我们应该依赖接口，而不是依赖具体的实现来编程。&lt;br&gt;  如你在Sqlite数据库的基础上开发一套新的数据库系统AWEDatabase，这时候Sqlite相当于底层模块，而你的AWEDatabase就属于高层模块；而从AWEDatabase开发使用者来看，他的业务层就相当于高层模块，而AWEDatabase就变成底层模块了，所以模块的高低应该是从开发者当前的角度来看的，不过DIP原则从不同角度来看它都适合且需要被遵守。假如我们高层模块直接依赖于底层模块，带来的后果是每次底层模块改动，高层模块就会受到影响，整个系统就变得不稳定，这也违反了开放关闭原则。&lt;br&gt;  通常我们会通过引入中间层的方式来解决这个问题，这个中间层相当于一个抽象接口层，高层模块和底层模块都依赖于这个中间层来交互，这样只要中间抽象层保持不变，底层模块改变不会影响到高层模块，这就满足了开放关闭原则；而且假如高层模块跟底层模块同时处于开发阶段，这样有了中间抽象层之后，每个模块都可以针对这个抽象层的接口同时开发，高层模块就不需要等到底层模块开发完毕才能继续了。&lt;br&gt;  比如在我们项目中有涉及IM的功能，现在这个IM模块采用的是XMPP协议来实现，客户端通过这个模块来实现消息的收发，但是假如后面我们想要换成其它协议，比如MQTT等，针对接口编程的话就可以让我们很轻松的实现模块替换：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E9%92%88%E5%AF%B9%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B.png&quot; alt=&quot;针对接口编程&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@protocol MessageDelegate &amp;#60;NSObject&amp;#62;&amp;#10;@required&amp;#10;-(void)goOnline;&amp;#10;-(void)sendMessage:(NSString*)content;&amp;#10;@end&amp;#10;&amp;#10;//xmpp&amp;#23454;&amp;#29616;&amp;#10;@interface XMPPMessageCenter &amp;#60;MessageDelegate&amp;#62;&amp;#10;@end&amp;#10;&amp;#10;//MQTT&amp;#23454;&amp;#29616;&amp;#10;@interface MQTTMessageCenter &amp;#60;MessageDelegate&amp;#62;&amp;#10;@end&amp;#10;&amp;#10;//&amp;#19994;&amp;#21153;&amp;#23618;&amp;#10;@interface BussinessLayer&amp;#10;//&amp;#20351;&amp;#29992;&amp;#36981;&amp;#24490;MessageDelegate&amp;#21327;&amp;#35758;&amp;#30340;&amp;#23545;&amp;#35937;&amp;#65292;&amp;#38024;&amp;#23545;&amp;#25509;&amp;#21475;&amp;#32534;&amp;#31243;&amp;#65292;&amp;#20197;&amp;#21518;&amp;#26367;&amp;#25442;&amp;#20063;&amp;#24456;&amp;#26041;&amp;#20415;&amp;#10;@property(nonatomic,strong)id&amp;#60;MessageDelegate&amp;#62; messageCenter;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  当我们在进行面向对象设计的时候应该充分考虑上面这几个原则，一开始可能设计并不完美，不过可以在重构的过程中不断完善。但其实很多人都跳过了设计这个环节，拿到一个模块直接动手编写代码，更不用说去思考设计了，项目中也有很多这样的例子。当然对于简单的模块或许不用什么设计，不过假如模块相对复杂的话，能够在动手写代码之前好好设计思考一下，养成这个习惯，肯定会对编写出可读性、稳定性以及可扩展性较高的代码有帮助。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最关键的软件开发工具是受过良好设计原则训练的思维。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;拥有一把锤子未必能成为建筑师&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  最近在项目开发过程中碰到了一些问题，发现在每波迭代开发过程中，经常需要去修改之前的代码，虽然出现这样的情形很正常，新的需求必然会带来新的功能新的设计，导致之前的代码受到影响。记得看过一个笑话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“杀一个程序员不需要用枪，改三次需求就可以了”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  其实需求设计是一个方面，另外我们作为设计开发人员有时候也需要去反省，反省一下代码的设计是否合理，为什么新功能的在原有代码上扩展会那么难，为什么我们的代码这么不稳定，牵一发而动全身？&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="面向对象设计" scheme="http://freemind-lj.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>有意义的命名</title>
    <link href="http://freemind-lj.github.io/2015/12/16/%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D/"/>
    <id>http://freemind-lj.github.io/2015/12/16/有意义的命名/</id>
    <published>2015-12-16T01:37:01.000Z</published>
    <updated>2016-02-14T10:04:25.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;名副其实：&quot;&gt;&lt;a href=&quot;#名副其实：&quot; class=&quot;headerlink&quot; title=&quot;名副其实：&quot;&gt;&lt;/a&gt;名副其实：&lt;/h3&gt;&lt;p&gt;变量、函数或类的名称就能够说明为什么它存在，做什么事，怎么用，如果需要注释来补充，就不算名副其实:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#28040;&amp;#36893;&amp;#30340;&amp;#26102;&amp;#38388;&amp;#65292;&amp;#20197;&amp;#26085;&amp;#35745;, bad!&amp;#10;int d;&amp;#10;&amp;#10;//good&amp;#10;int daysSinceCreation;&amp;#160;&amp;#10;int daysSinceModification;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;避免误导&quot;&gt;&lt;a href=&quot;#避免误导&quot; class=&quot;headerlink&quot; title=&quot;避免误导&quot;&gt;&lt;/a&gt;避免误导&lt;/h3&gt;&lt;p&gt;避免留下隐藏代码本意的错误线索。&lt;br&gt;accountList  一组账号，如果类型不是List会引起误判，accountGroup或bunchOfAccoutns,甚至accounts，更可怕的例子：使用小些字母l跟字母O作为变量名&lt;/p&gt;
&lt;h3 id=&quot;做有意义的区分&quot;&gt;&lt;a href=&quot;#做有意义的区分&quot; class=&quot;headerlink&quot; title=&quot;做有意义的区分&quot;&gt;&lt;/a&gt;做有意义的区分&lt;/h3&gt;&lt;p&gt;代码是写给人看的,仅仅是满足编译器的要求,就会引起混乱&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以数字系列命名：void copyChars(char a1[],char a2[]) ==&amp;gt; void copyChars(char source[],char destination[])&lt;/li&gt;
&lt;li&gt;说废话： a, an, the, Info, Data&lt;/li&gt;
&lt;li&gt;使用可读的名字：避免过度使用缩写，genymdhms (生成日期，年月日时分秒)&lt;/li&gt;
&lt;li&gt;使用便于搜索的名称：避免使用Magic Number，避免使用单字母,或出现频率极高的短字母组合(注意度的把握)；MAX_CLASSER_PER_STUDENT  跟  “7” “e”&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类名&quot;&gt;&lt;a href=&quot;#类名&quot; class=&quot;headerlink&quot; title=&quot;类名&quot;&gt;&lt;/a&gt;类名&lt;/h3&gt;&lt;p&gt;类名和对象名应该是名词或名词短语，Customer、Account&lt;/p&gt;
&lt;h3 id=&quot;方法名&quot;&gt;&lt;a href=&quot;#方法名&quot; class=&quot;headerlink&quot; title=&quot;方法名&quot;&gt;&lt;/a&gt;方法名&lt;/h3&gt;&lt;p&gt;动词或动词短语：deletePage、save,属性访问、修改和断言：加上get、set和is&lt;/p&gt;
&lt;h3 id=&quot;别装可爱&quot;&gt;&lt;a href=&quot;#别装可爱&quot; class=&quot;headerlink&quot; title=&quot;别装可爱&quot;&gt;&lt;/a&gt;别装可爱&lt;/h3&gt;&lt;p&gt;使用俗语或俚语, eatMyShorts()表示abort()  eatMyShorts：去死吧&lt;/p&gt;
&lt;h3 id=&quot;每个概念对应一个词&quot;&gt;&lt;a href=&quot;#每个概念对应一个词&quot; class=&quot;headerlink&quot; title=&quot;每个概念对应一个词&quot;&gt;&lt;/a&gt;每个概念对应一个词&lt;/h3&gt;&lt;p&gt;给每个抽象概念选一个词，并一以贯之。比如获取数据可以使用fetch、retrive、get这些词语，但最好能够统一使用一种(controller、manager类似)&lt;/p&gt;
&lt;h3 id=&quot;名字尽量来自解决方案领域或问题领域：&quot;&gt;&lt;a href=&quot;#名字尽量来自解决方案领域或问题领域：&quot; class=&quot;headerlink&quot; title=&quot;名字尽量来自解决方案领域或问题领域：&quot;&gt;&lt;/a&gt;名字尽量来自解决方案领域或问题领域：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用解决方案领域名称：使用计算机领域的科学术语、算法名、模式名等。如AccountVisitor：Visitor模式实现的Account类。&lt;/li&gt;
&lt;li&gt;使用问题领域的名称：如果不能用程序员熟悉的术语来命名，就采用所涉问题领域的名称。排序==&amp;gt; sort&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;适当使用有意义的语境：&quot;&gt;&lt;a href=&quot;#适当使用有意义的语境：&quot; class=&quot;headerlink&quot; title=&quot;适当使用有意义的语境：&quot;&gt;&lt;/a&gt;适当使用有意义的语境：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;良好命名的类、函数、名称空间来放置名称，给读者提供语境&lt;/li&gt;
&lt;li&gt;给名称前加前缀：firstName、lastName、street、houseNumber、city、state和zipcode，和在一起知道是地址，孤零零时无法推断， state＝》addrState&lt;/li&gt;
&lt;li&gt;事不过三，如果传递给函数的变量超过三个，考虑封装成概念,添加struct或class&lt;/li&gt;
&lt;li&gt;不要添加没用的语境&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;名副其实：&quot;&gt;&lt;a href=&quot;#名副其实：&quot; class=&quot;headerlink&quot; title=&quot;名副其实：&quot;&gt;&lt;/a&gt;名副其实：&lt;/h3&gt;&lt;p&gt;变量、函数或类的名称就能够说明为什么它存在，做什么事，怎么用，如果需要注释来补充，就不算名副其实:&lt;br&gt;&lt;figu
    
    </summary>
    
      <category term="others" scheme="http://freemind-lj.github.io/categories/others/"/>
    
    
      <category term="代码整洁之道" scheme="http://freemind-lj.github.io/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>整洁代码</title>
    <link href="http://freemind-lj.github.io/2015/12/14/%E6%95%B4%E6%B4%81%E4%BB%A3%E7%A0%81/"/>
    <id>http://freemind-lj.github.io/2015/12/14/整洁代码/</id>
    <published>2015-12-14T07:16:01.000Z</published>
    <updated>2016-02-14T09:57:05.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;为什么要写糟糕的代码？&quot;&gt;&lt;a href=&quot;#为什么要写糟糕的代码？&quot; class=&quot;headerlink&quot; title=&quot;为什么要写糟糕的代码？&quot;&gt;&lt;/a&gt;为什么要写糟糕的代码？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;赶时间完成任务 ，期望后面再清理.&lt;/li&gt;
&lt;li&gt;勒布朗法则：稍后等于永不（Later equals never）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;混乱的代价：&quot;&gt;&lt;a href=&quot;#混乱的代价：&quot; class=&quot;headerlink&quot; title=&quot;混乱的代价：&quot;&gt;&lt;/a&gt;混乱的代价：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;代码变的无法管理，团队生产力下降，&lt;/li&gt;
&lt;li&gt;增加人力？Brooks定律(人月神话)：向进度落后的项目中增加人手，只会使进度更加落后。&lt;/li&gt;
&lt;li&gt;破窗理论：假如原来的代码很优秀，新加入的代码会害怕破坏这美妙的整体而变的更好，反之则不会去在意。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;开始新设计&quot;&gt;&lt;a href=&quot;#开始新设计&quot; class=&quot;headerlink&quot; title=&quot;开始新设计:&quot;&gt;&lt;/a&gt;开始新设计:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;新系统设计与旧系统维护竞赛，时间可持续十年之久，完成时成员早不知去向&lt;/li&gt;
&lt;li&gt;花时间保持代码整洁不但关乎效率，还关乎生存&lt;/li&gt;
&lt;li&gt;制造混乱无助于赶上工期，只会拖累，唯一方法就是始终尽可能保持代码整洁&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是整洁代码？&quot;&gt;&lt;a href=&quot;#什么是整洁代码？&quot; class=&quot;headerlink&quot; title=&quot;什么是整洁代码？&quot;&gt;&lt;/a&gt;什么是整洁代码？&lt;/h2&gt;&lt;h4 id=&quot;Bjarne-stroustrup：&quot;&gt;&lt;a href=&quot;#Bjarne-stroustrup：&quot; class=&quot;headerlink&quot; title=&quot;Bjarne stroustrup：&quot;&gt;&lt;/a&gt;Bjarne stroustrup：&lt;/h4&gt;&lt;p&gt;我喜欢优雅和高效的代码，代码逻辑应直截了当，叫缺陷难以隐藏；尽量减少依赖，使之便于维护；依据某种分成战略完善错误代码处理；性能调至最优，省的引诱别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做好一件事。&lt;/p&gt;
&lt;h4 id=&quot;Michael-Feathers-修改代码的艺术作者-：&quot;&gt;&lt;a href=&quot;#Michael-Feathers-修改代码的艺术作者-：&quot; class=&quot;headerlink&quot; title=&quot;Michael Feathers(修改代码的艺术作者)：&quot;&gt;&lt;/a&gt;Michael Feathers(修改代码的艺术作者)：&lt;/h4&gt;&lt;p&gt;我可以列出我留意到的整洁代码的所有特点，但其中有一条是根本性的。整洁的代码总是看起来像是某位特别在意它的人写的，几乎没有什么改进的余地，代码作者什么都想到了，如果你企图改进它，总会回到原点，赞叹某人留给你的代码———全心头人的某人留下的代码。&lt;/p&gt;
&lt;h4 id=&quot;Ron（c-极限编程探险作者）&quot;&gt;&lt;a href=&quot;#Ron（c-极限编程探险作者）&quot; class=&quot;headerlink&quot; title=&quot;Ron（c#极限编程探险作者）:&quot;&gt;&lt;/a&gt;Ron（c#极限编程探险作者）:&lt;/h4&gt;&lt;p&gt;不要重复的代码（表示某种想法未在代码中得到良好的体现），只做一件事，提早构建简单抽象（在集合中查找某物）&lt;/p&gt;
&lt;h4 id=&quot;美国童子军军规：让营地比你来时更干净。&quot;&gt;&lt;a href=&quot;#美国童子军军规：让营地比你来时更干净。&quot; class=&quot;headerlink&quot; title=&quot;美国童子军军规：让营地比你来时更干净。&quot;&gt;&lt;/a&gt;美国童子军军规：让营地比你来时更干净。&lt;/h4&gt;&lt;p&gt;改好一个变量名，拆分一个过长的函数，消除一点点重复代码&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要写糟糕的代码？&quot;&gt;&lt;a href=&quot;#为什么要写糟糕的代码？&quot; class=&quot;headerlink&quot; title=&quot;为什么要写糟糕的代码？&quot;&gt;&lt;/a&gt;为什么要写糟糕的代码？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;赶时间完成任务 ，期望后面再清理.&lt;/li&gt;
&lt;li&gt;勒
    
    </summary>
    
      <category term="others" scheme="http://freemind-lj.github.io/categories/others/"/>
    
    
      <category term="代码整洁之道" scheme="http://freemind-lj.github.io/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>开源许可证的一些区别</title>
    <link href="http://freemind-lj.github.io/2015/11/24/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/"/>
    <id>http://freemind-lj.github.io/2015/11/24/开源许可证的一些区别/</id>
    <published>2015-11-24T01:49:32.000Z</published>
    <updated>2016-02-15T03:01:52.000Z</updated>
    
    <content type="html">&lt;p&gt;我们在看一些开源项目的时候，一般很少去关注开源的许可证，不过有些时候我们需要对这些证书有一定的了解，一张图胜过千言万语：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81.jpg&quot; alt=&quot;开源许可证&quot;&gt;&lt;br&gt;&lt;/center&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;我们在看一些开源项目的时候，一般很少去关注开源的许可证，不过有些时候我们需要对这些证书有一定的了解，一张图胜过千言万语：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E5%BC%80%E6
    
    </summary>
    
      <category term="others" scheme="http://freemind-lj.github.io/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>关于GCD开发的一些事儿</title>
    <link href="http://freemind-lj.github.io/2015/11/20/%E5%85%B3%E4%BA%8EGCD%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://freemind-lj.github.io/2015/11/20/关于GCD开发的一些事儿/</id>
    <published>2015-11-20T09:58:10.000Z</published>
    <updated>2016-02-15T03:03:58.000Z</updated>
    
    <content type="html">&lt;p&gt;在之前我们介绍过NSOperation的一些东西，这次我们来聊一聊另一个iOS开发最经常使用的技术之一 — GCD，GCD将线程的管理移到系统级别，你只需要定义好要执行的任务，然后丢到合适的Dispatch queue，GCD会负责创建线程来执行你的代码，由于这部分是处于系统级别，所以执行的性能通常非常高。GCD这部分代码苹果已开源，有兴趣的可以去下载了解一下:&lt;a href=&quot;http://libdispatch.macosforge.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;地址&lt;/a&gt;&lt;br&gt;在介绍GCD之前我们先了解一下Quality of Service：&lt;/p&gt;
&lt;h3 id=&quot;Quality-of-Service-QoS&quot;&gt;&lt;a href=&quot;#Quality-of-Service-QoS&quot; class=&quot;headerlink&quot; title=&quot;Quality of Service(QoS)&quot;&gt;&lt;/a&gt;Quality of Service(QoS)&lt;/h3&gt;&lt;p&gt;这是在iOS8之后提供的新功能，苹果提供了几个Quality of Service枚举来使用:user interactive, user initiated, utility 和 background，通过这告诉系统我们在进行什么样的工作，然后系统会通过合理的资源控制来最高效的执行任务代码，其中主要涉及到CPU调度的优先级、IO优先级、任务运行在哪个线程以及运行的顺序等等，我们通过一个抽象的Quality of Service参数来表明任务的意图以及类别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSQualityOfServiceUserInteractive&lt;br&gt;与用户交互的任务，这些任务通常跟UI级别的刷新相关，比如动画，这些任务需要在一瞬间完成&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceUserInitiated&lt;br&gt;由用户发起的并且需要立即得到结果的任务，比如滑动scroll view时去加载数据用于后续cell的显示，这些任务通常跟后续的用户交互相关，在几秒或者更短的时间内完成&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceUtility&lt;br&gt;一些可能需要花点时间的任务，这些任务不需要马上返回结果，比如下载的任务，这些任务可能花费几秒或者几分钟的时间&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceBackground&lt;br&gt;这些任务对用户不可见，比如后台进行备份的操作，这些任务可能需要较长的时间，几分钟甚至几个小时&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceDefault&lt;br&gt;优先级介于user-initiated 和 utility，当没有 QoS信息时默认使用，开发者不应该使用这个值来设置自己的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Qos可以跟GCD queue做个对照：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E5%AF%B9%E7%85%A7%E8%A1%A8.png&quot; alt=&quot;对照表&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;下面我们了解一下GCD的一些用法：&lt;/p&gt;
&lt;h3 id=&quot;Dispatch-Queue&quot;&gt;&lt;a href=&quot;#Dispatch-Queue&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Queue&quot;&gt;&lt;/a&gt;Dispatch Queue&lt;/h3&gt;&lt;p&gt;开发者将需要执行的任务添加到合适的Dispatch Queue中即可，Dispatch Queue会根据任务添加的顺序先到先执行，其中有以下几种队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;main dispatch queue&lt;br&gt;功能跟主线程一样，通过dispatch_get_main_queue()来获取，提交到main queue的任务实际上都是在主线程执行的，所以这是一个串行队列&lt;/li&gt;
&lt;li&gt;&lt;p&gt;global dispatch queues&lt;br&gt;系统给每个应用提供四个全局的并发队列，这四个队列分别有不同的优先级：高、默认、低以及后台，用户不能去创建全局队列，只能根据优先级去获取: &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue ; &amp;#10;queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;user create queue&lt;br&gt;用户可以通过dispatch_queue_create自己创建队列，该函数有两个参数，第一个是队列的名称，在debug的时候方便区分；第二个是队列的一些属性，NULL或者DISPATCH_QUEUE_SERIAL创建出来的队列是串行队列，如果传递DISPATCH_QUEUE_CONCURRENT则为并行队列。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#21019;&amp;#24314;&amp;#24182;&amp;#34892;&amp;#38431;&amp;#21015;&amp;#10;dispatch_queue_t queue;&amp;#10;queue = dispatch_queue_create(&amp;#34;com.example.MyQueue&amp;#34;, DISPATCH_QUEUE_CONCURRENT);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;队列优先级&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;dispatch_queue_create创建队列的优先级跟global dispatch queue的默认优先级一样，假如我们需要设置队列的优先级，可以通过dispatch_queue_attr_make_with_qos_class或者dispatch_set_target_queue方法；&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#25351;&amp;#23450;&amp;#38431;&amp;#21015;&amp;#30340;QoS&amp;#31867;&amp;#21035;&amp;#20026;QOS_CLASS_UTILITY&amp;#10;dispatch_queue_attr_t queue_attr = dispatch_queue_attr_make_with_qos_class (DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY,-1);&amp;#10;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, queue_attr);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;dispatch_set_target_queue的第一个参数为要设置优先级的queue,第二个参数是对应的优先级参照物&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t&amp;#160;serialQueue&amp;#160;=&amp;#160;dispatch_queue_create(&amp;#34;com.example.MyQueue&amp;#34;,NULL);&amp;#160;&amp;#160;&amp;#10;dispatch_queue_t&amp;#160;globalQueue&amp;#160;=&amp;#160;dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);&amp;#160;&amp;#160;&amp;#10;&amp;#160;&amp;#10;//serialQueue&amp;#29616;&amp;#22312;&amp;#30340;&amp;#20248;&amp;#20808;&amp;#32423;&amp;#36319;globalQueue&amp;#30340;&amp;#20248;&amp;#20808;&amp;#32423;&amp;#19968;&amp;#26679;&amp;#10;dispatch_set_target_queue(serialQueue,&amp;#160;globalQueue);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_set_target_queue&lt;br&gt;dispatch_set_target_queue除了能用来设置队列的优先级之外，还能够创建队列的层次体系，当我们想让不同队列中的任务同步的执行时，我们可以创建一个串行队列，然后将这些队列的target指向新创建的队列即可，比如&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%97%E4%BD%93%E7%B3%BB.p.png&quot; alt=&quot;队列体系.png&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/center&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t targetQueue = dispatch_queue_create(&amp;#34;target_queue&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;dispatch_queue_t queue1 = dispatch_queue_create(&amp;#34;queue1&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;dispatch_queue_t queue2 = dispatch_queue_create(&amp;#34;queue2&amp;#34;, DISPATCH_QUEUE_CONCURRENT);&amp;#10;dispatch_set_target_queue(queue1, targetQueue);&amp;#10;dispatch_set_target_queue(queue2, targetQueue);&amp;#10;&amp;#160; dispatch_async(queue1, ^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; NSLog(@&amp;#34;do job1&amp;#34;);&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [NSThread sleepForTimeInterval:3.f];&amp;#10;&amp;#160; &amp;#160; &amp;#125;);&amp;#10;&amp;#160; dispatch_async(queue2, ^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; NSLog(@&amp;#34;do job2&amp;#34;);&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [NSThread sleepForTimeInterval:2.f];&amp;#10;&amp;#160; &amp;#160; &amp;#125;);&amp;#10;&amp;#160; dispatch_async(queue2, ^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; NSLog(@&amp;#34;do job3&amp;#34;);&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [NSThread sleepForTimeInterval:1.f];&amp;#10;&amp;#160; &amp;#160; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到执行的结果如下，这些队列会同步的执行任务。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[13323:569147] do job1&amp;#10;GCDTests[13323:569147] do job2&amp;#10;GCDTests[13323:569147] do job3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_barrier_async&lt;br&gt;dispatch_barrier_async用于等待前面的任务执行完毕后自己才执行，而它后面的任务需等待它完成之后才执行。一个典型的例子就是数据的读写，通常为了防止文件读写导致冲突，我们会创建一个串行的队列，所有的文件操作都是通过这个队列来执行，比如FMDB，这样就可以避免读写冲突。不过其实这样效率是有提升的空间的，当没有更新数据时，读操作其实是可以并行进行的，而写操作需要串行的执行，如何实现呢：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;Database_Queue&amp;#34;, DISPATCH_QUEUE_CONCURRENT);&amp;#10;    &amp;#10;    dispatch_async(queue, ^&amp;#123;&amp;#10;        NSLog(@&amp;#34;reading data1&amp;#34;);&amp;#10;    &amp;#125;);&amp;#10;    dispatch_async(queue, ^&amp;#123;&amp;#10;        NSLog(@&amp;#34;reading data2&amp;#34;);&amp;#10;    &amp;#125;);&amp;#10;    dispatch_barrier_async(queue, ^&amp;#123;&amp;#10;        NSLog(@&amp;#34;writing data1&amp;#34;);&amp;#10;        [NSThread sleepForTimeInterval:1];&amp;#10;        &amp;#10;    &amp;#125;);&amp;#10;    dispatch_async(queue, ^&amp;#123;&amp;#10;        [NSThread sleepForTimeInterval:1];&amp;#10;        NSLog(@&amp;#34;reading data3&amp;#34;);&amp;#10;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行结果如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[13360:584316] reading data2&amp;#10;GCDTests[13360:584317] reading data1&amp;#10;GCDTests[13360:584317] writing data1&amp;#10;GCDTests[13360:584317] reading data3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们将写数据的操作放在dispatch_barrier_async中，这样能确保在写数据的时候会等待前面的读操作完成，而后续的读操作也会等到写操作完成后才能继续执行，提高文件读写的执行效率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_queue_set_specific 、dispatch_get_specific&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个API类似于objc_setAssociatedObject跟objc_getAssociatedObject，FMDB里就用到这个来防止死锁，来看看FMDB的部分源码&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static const void * const kDispatchQueueSpecificKey = &amp;#38;kDispatchQueueSpecificKey;&amp;#10;//&amp;#21019;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#20018;&amp;#34892;&amp;#38431;&amp;#21015;&amp;#26469;&amp;#25191;&amp;#34892;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#30340;&amp;#25152;&amp;#26377;&amp;#25805;&amp;#20316;&amp;#10; _queue = dispatch_queue_create([[NSString stringWithFormat:@&amp;#34;fmdb.%@&amp;#34;, self] UTF8String], NULL);&amp;#10;&amp;#10; //&amp;#36890;&amp;#36807;key&amp;#26631;&amp;#31034;&amp;#38431;&amp;#21015;&amp;#65292;&amp;#35774;&amp;#32622;context&amp;#20026;self&amp;#10; dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当要执行数据库操作时，如果在queue里面的block执行过程中，又调用了 indatabase方法，需要检查是不是同一个queue，因为同一个queue的话会产生死锁情况&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)inDatabase:(void (^)(FMDatabase *db))block &amp;#123;&amp;#10;    FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);&amp;#10;    assert(currentSyncQueue != self &amp;#38;&amp;#38; &amp;#34;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&amp;#34;);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_apply&lt;br&gt;dispatch_apply类似一个for循环，会在指定的dispatch queue中运行block任务n次，如果队列是并发队列，则会并发执行block任务，dispatch_apply是一个同步调用，block任务执行n次后才返回。&lt;br&gt;简单的使用方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;myqueue&amp;#34;, DISPATCH_QUEUE_CONCURRENT);&amp;#10;//&amp;#24182;&amp;#21457;&amp;#30340;&amp;#36816;&amp;#34892;&amp;#19968;&amp;#20010;block&amp;#20219;&amp;#21153;5&amp;#27425;&amp;#10;dispatch_apply(5, queue, ^(size_t i) &amp;#123;&amp;#10;    NSLog(@&amp;#34;do a job %zu times&amp;#34;,i+1);&amp;#10;&amp;#125;);&amp;#10;NSLog(@&amp;#34;go on&amp;#34;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[10029:760640] do a job 2 times&amp;#10;GCDTests[10029:760640] do a job 1 times&amp;#10;GCDTests[10029:760640] do a job 3 times&amp;#10;GCDTests[10029:760640] do a job 5 times&amp;#10;GCDTests[10029:760640] do a job 4 times&amp;#10;GCDTests[10029:760640] go on&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在某些场景下使用dispatch_apply会对性能有很大的提升，比如你的代码需要以每个像素为基准来处理计算image图片。同时dispatch apply能够避免一些线程爆炸的情况发生（创建很多线程）&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#21361;&amp;#38505;&amp;#65292;&amp;#21487;&amp;#33021;&amp;#23548;&amp;#33268;&amp;#32447;&amp;#31243;&amp;#29190;&amp;#28856;&amp;#20197;&amp;#21450;&amp;#27515;&amp;#38145;&amp;#10;for (int i = 0; i &amp;#60; 999; i++)&amp;#123;&amp;#10;   dispatch_async(q, ^&amp;#123;...&amp;#125;);&amp;#10;&amp;#125;&amp;#10;dispatch_barrier_sync(q, ^&amp;#123;&amp;#125;);&amp;#10;&amp;#10;// &amp;#36739;&amp;#20248;&amp;#36873;&amp;#25321;&amp;#65292; GCD &amp;#20250;&amp;#31649;&amp;#29702;&amp;#24182;&amp;#21457;&amp;#10;dispatch_apply(999, q, ^(size_t i)&amp;#123;...&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Dispatch-Block&quot;&gt;&lt;a href=&quot;#Dispatch-Block&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Block&quot;&gt;&lt;/a&gt;Dispatch Block&lt;/h4&gt;&lt;p&gt;添加到gcd队列中执行的任务是以block的形式添加的，block封装了需要执行功能，block带来的开发效率提升就不说了，gcd跟block可以说是一对好基友，能够很好的配合使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建block&lt;br&gt;我们可以自己创建block并添加到queue中去执行&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;//&amp;#21019;&amp;#24314;block&amp;#10;dispatch_block_t block = dispatch_block_create(0, ^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; NSLog(@&amp;#34;do something&amp;#34;);&amp;#10;&amp;#160; &amp;#160; &amp;#125;);&amp;#10;dispatch_async(queue, block);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在创建block的时候我们也可以通过设置QoS，指定block对应的优先级，在dispatch_block_create_with_qos_class中指定QoS类别即可：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;dispatch_block_t block = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INITIATED, -1, ^&amp;#123;&amp;#10;        NSLog(@&amp;#34;do something with QoS&amp;#34;);&amp;#10;    &amp;#125;);&amp;#10;dispatch_async(queue, block);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_block_wait&lt;br&gt;当需要等待前面的任务执行完毕时，我们可以使用dispatch_block_wait这个接口，设置等待时间DISPATCH_TIME_FOREVER会一直等待直到前面的任务完成：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;dispatch_block_t block = dispatch_block_create(0, ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;before sleep&amp;#34;);&amp;#10;    [NSThread sleepForTimeInterval:1];&amp;#10;    NSLog(@&amp;#34;after sleep&amp;#34;);&amp;#10;&amp;#125;);&amp;#10;dispatch_async(queue, block);&amp;#10;//&amp;#31561;&amp;#24453;&amp;#21069;&amp;#38754;&amp;#30340;&amp;#20219;&amp;#21153;&amp;#25191;&amp;#34892;&amp;#23436;&amp;#27605;&amp;#10;dispatch_block_wait(block, DISPATCH_TIME_FOREVER);&amp;#10;NSLog(@&amp;#34;coutinue&amp;#34;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;程序运行结果:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[16679:863641] before sleep&amp;#10;GCDTests[16679:863641] after sleep&amp;#10;GCDTests[16679:863529] coutinue&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_block_notify&lt;br&gt;dispatch_block_notify当观察的某个block执行结束之后立刻通知提交另一特定的block到指定的queue中执行，该函数有三个参数，第一参数是需要观察的block，第二个参数是被通知block提交执行的queue，第三参数是当需要被通知执行的block，函数的原型:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void dispatch_block_notify(dispatch_block_t block, dispatch_queue_t queue,&amp;#10;&amp;#9;&amp;#9;dispatch_block_t notification_block);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体使用的方法:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;dispatch_block_t previousBlock = dispatch_block_create(0, ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;previousBlock begin&amp;#34;);&amp;#10;    [NSThread sleepForTimeInterval:1];&amp;#10;    NSLog(@&amp;#34;previousBlock done&amp;#34;);&amp;#10;&amp;#125;);&amp;#10;dispatch_async(queue, previousBlock);&amp;#10;dispatch_block_t notifyBlock = dispatch_block_create(0, ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;notifyBlock&amp;#34;);&amp;#10;&amp;#125;);&amp;#10;//&amp;#24403;previousBlock&amp;#25191;&amp;#34892;&amp;#23436;&amp;#27605;&amp;#21518;&amp;#65292;&amp;#25552;&amp;#20132;notifyBlock&amp;#21040;global queue&amp;#20013;&amp;#25191;&amp;#34892;&amp;#10;dispatch_block_notify(previousBlock, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), notifyBlock);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行结果：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[17129:895673] previousBlock begin&amp;#10;GCDTests[17129:895673] previousBlock done&amp;#10;GCDTests[17129:895673] notifyBlock&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_block_cancel&lt;br&gt;之前在介绍nsopreration的时候提到它的一个优点是可以取消某个operation，现在在iOS8之后，提交到gcd队列中的dispatch block也可取消了，只需要简单的调用dispatch_block_cancel传入想要取消的block即可:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;dispatch_block_t block1 = dispatch_block_create(0, ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;block1 begin&amp;#34;);&amp;#10;    [NSThread sleepForTimeInterval:1];&amp;#10;    NSLog(@&amp;#34;block1 done&amp;#34;);&amp;#10;&amp;#125;);&amp;#10;dispatch_block_t block2 = dispatch_block_create(0, ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;block2 &amp;#34;);&amp;#10;&amp;#125;);&amp;#10;dispatch_async(queue, block1);&amp;#10;dispatch_async(queue, block2);&amp;#10;dispatch_block_cancel(block2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到如下的执行结果，block2不再执行了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[17271:902981] block1 begin&amp;#10;GCDTests[17271:902981] block1 done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;Dispatch-Group&quot;&gt;&lt;a href=&quot;#Dispatch-Group&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Group&quot;&gt;&lt;/a&gt;Dispatch Group&lt;/h4&gt;&lt;p&gt;当我们想在gcd queue中所有的任务执行完毕之后做些特定事情的时候，也就是队列的同步问题，如果队列是串行的话，那将该操作最后添加到队列中即可，但如果队列是并行队列的话，这时候就可以利用dispatch_group来实现了，dispatch_group能很方便的解决同步的问题。dispatch_group_create可以创建一个group对象，然后可以添加block到该组里面，下面看下它的一些用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_group_wait&lt;br&gt;dispatch_group_wait会同步地等待group中所有的block执行完毕后才继续执行,类似于dispatch barrier&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, DISPATCH_QUEUE_CONCURRENT);&amp;#10;dispatch_group_t group = dispatch_group_create();&amp;#10;//&amp;#23558;&amp;#20219;&amp;#21153;&amp;#24322;&amp;#27493;&amp;#22320;&amp;#28155;&amp;#21152;&amp;#21040;group&amp;#20013;&amp;#21435;&amp;#25191;&amp;#34892;&amp;#10;dispatch_group_async(group,queue,^&amp;#123; NSLog(@&amp;#34;block1&amp;#34;); &amp;#125;);&amp;#10;dispatch_group_async(group,queue,^&amp;#123; NSLog(@&amp;#34;block2&amp;#34;); &amp;#125;);&amp;#10;dispatch_group_wait(group,DISPATCH_TIME_FOREVER);&amp;#10;NSLog(@&amp;#34;go on&amp;#34;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行结果如下，只有block1跟block2执行完毕后才会执行dispatch_group_wait后面的内容。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[954:41031] block2&amp;#10;GCDTests[954:41032] block1&amp;#10;GCDTests[954:40847] go on&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_group_notify&lt;br&gt;功能与dispatch_group_wait类似，不过该过程是异步的，不会阻塞该线程，dispatch_group_notify有三个参数&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void dispatch_group_notify(dispatch_group_t group, //&amp;#35201;&amp;#35266;&amp;#23519;&amp;#30340;group&amp;#10;                           dispatch_queue_t queue,   //block&amp;#25191;&amp;#34892;&amp;#30340;&amp;#38431;&amp;#21015;&amp;#10;                           dispatch_block_t block);   //&amp;#24403;group&amp;#20013;&amp;#25152;&amp;#26377;&amp;#20219;&amp;#21153;&amp;#25191;&amp;#34892;&amp;#23436;&amp;#27605;&amp;#20043;&amp;#21518;&amp;#35201;&amp;#25191;&amp;#34892;&amp;#30340;block&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单的示意用法:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;queue&amp;#34;, DISPATCH_QUEUE_CONCURRENT);&amp;#10;dispatch_group_t group = dispatch_group_create();&amp;#10;dispatch_group_async(group,queue,^&amp;#123; NSLog(@&amp;#34;block1&amp;#34;); &amp;#125;);&amp;#10;dispatch_group_async(group,queue,^&amp;#123; NSLog(@&amp;#34;block2&amp;#34;); &amp;#125;);&amp;#10;dispatch_group_notify(group, dispatch_get_main_queue(), ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;done&amp;#34;);&amp;#10;&amp;#125;);&amp;#10;NSLog(@&amp;#34;go on&amp;#34;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到如下的执行结果&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[1046:45104] go on&amp;#10;GCDTests[1046:45153] block1&amp;#10;GCDTests[1046:45152] block2&amp;#10;GCDTests[1046:45104] done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_group_enter dispatch_group_leave&lt;br&gt;假如我们不想使用dispatch_group_async异步的将任务丢到group中去执行，这时候就需要用到dispatch_group_enter跟dispatch_group_leave方法，这两个方法要配对出现，以下这两种方法是等价的：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(group, queue, ^&amp;#123; &amp;#10;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等价于&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_enter(group);&amp;#10;dispatch_async(queue, ^&amp;#123;&amp;#10;&amp;#12288;&amp;#12288;dispatch_group_leave(group);&amp;#10;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;简单的使用方法，可以自己试试没有写dispatch_group_leave会发生什么。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_t group = dispatch_group_create();&amp;#10;for (int i =0 ; i&amp;#60;3; i++) &amp;#123;&amp;#10;    dispatch_group_enter(group);&amp;#10;    NSLog(@&amp;#34;do block:%d&amp;#34;,i);&amp;#10;    dispatch_group_leave(group);&amp;#10;&amp;#125;&amp;#10;//&amp;#31561;&amp;#24453;&amp;#19978;&amp;#38754;&amp;#30340;&amp;#20219;&amp;#21153;&amp;#23436;&amp;#25104;&amp;#10;dispatch_group_wait(group, DISPATCH_TIME_FOREVER);&amp;#10;NSLog(@&amp;#34;go on&amp;#34;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Dispatch-Semaphore&quot;&gt;&lt;a href=&quot;#Dispatch-Semaphore&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Semaphore&quot;&gt;&lt;/a&gt;Dispatch Semaphore&lt;/h4&gt;&lt;p&gt;dispatch semaphore也是用来做解决一些同步的问题，dispatch_semaphore_create会创建一个信号量，该函数需要传递一个信号值，dispatch_semaphore_signal会使信号值加1，如果信号值的大小等于1，dispatch_semaphore_wait会使信号值减1，并继续往下走，如果信号值为0，则等待。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#21019;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#20449;&amp;#21495;&amp;#37327;&amp;#65292;&amp;#21021;&amp;#22987;&amp;#20540;&amp;#20026;0&amp;#10;dispatch_semaphore_t sema = dispatch_semaphore_create(0);&amp;#10;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;do some job&amp;#34;);&amp;#10;    sleep(1);&amp;#10;    NSLog(@&amp;#34;increase the semaphore&amp;#34;);&amp;#10;    dispatch_semaphore_signal(sema); //&amp;#20449;&amp;#21495;&amp;#20540;&amp;#21152;1&amp;#10;&amp;#125;);&amp;#10;dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);//&amp;#31561;&amp;#24453;&amp;#30452;&amp;#21040;&amp;#20449;&amp;#21495;&amp;#20540;&amp;#22823;&amp;#20110;&amp;#31561;1&amp;#10;NSLog(@&amp;#34;go on&amp;#34;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;执行结果如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCDTests[1394:92383] do some job&amp;#10;GCDTests[1394:92383] increase the semaphore&amp;#10;GCDTests[1394:92326] go on&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Dispatch-Timer&quot;&gt;&lt;a href=&quot;#Dispatch-Timer&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Timer&quot;&gt;&lt;/a&gt;Dispatch Timer&lt;/h4&gt;&lt;p&gt;dispatch timer通常配合dispatch_after使用，完成一些延时的任务：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#24310;&amp;#36831;5&amp;#31186;&amp;#21518;&amp;#25191;&amp;#34892;&amp;#20219;&amp;#21153;&amp;#10;dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC));&amp;#10;dispatch_after(time, dispatch_get_main_queue(), ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;do job afer 5 seconds&amp;#34;);&amp;#10;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Dispatch-IO&quot;&gt;&lt;a href=&quot;#Dispatch-IO&quot; class=&quot;headerlink&quot; title=&quot;Dispatch IO&quot;&gt;&lt;/a&gt;Dispatch IO&lt;/h4&gt;&lt;p&gt;当我们要读取一份较大文件的时候，多个线程同时去读肯定比一个线程去读的速度要快，要实现这样的功能可以通过dispatch io跟dispatch data来实现，通过dispatch io去读文件时，会使用global dispatch queue将一个文件按照一个指定的分块大小同时去读取数据，类似于：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(queue, ^&amp;#123;/* &amp;#35835;&amp;#21462;0-99&amp;#23383;&amp;#33410; */&amp;#125;);&amp;#10;dispatch_async(queue, ^&amp;#123;/* &amp;#35835;&amp;#21462;100-199&amp;#23383;&amp;#33410; */&amp;#125;);&amp;#10;dispatch_async(queue, ^&amp;#123;/* &amp;#35835;&amp;#21462;200-299&amp;#23383;&amp;#33410; */&amp;#125;);&amp;#10;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将文件分成一块一块并行的去读取，读取的数据通过Dispatch Data可以更为简单地进行结合和分割 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_io_create&lt;br&gt;生成Dispatch IO,指定发生错误时用来执行处理的Block,以及执行该Block的Dispatch Queue&lt;/li&gt;
&lt;li&gt;dispatch_io_set_low_water&lt;br&gt;设定一次读取的大小（分割的大小）&lt;/li&gt;
&lt;li&gt;dispatch_io_read&lt;br&gt;使用Global Dispatch Queue开始并列读取，当每个分割的文件块读取完毕时，会将含有文件数据的dispatch data返回到dispatch_io_read设定的block，在block中需要分析传递过来的dispatch data进行合并处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看下苹果的系统日志API(Libc-763.11 gen/asl.c)的源代码使用到了dispatch IO：&lt;a href=&quot;https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码地址&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#10;//dispatch_io_create&amp;#20986;&amp;#38169;&amp;#26102;handler&amp;#25191;&amp;#34892;&amp;#30340;&amp;#38431;&amp;#21015;&amp;#10;pipe_q = dispatch_queue_create(&amp;#34;PipeQ&amp;#34;, NULL);&amp;#10;pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM, fd, pipe_q, ^(int err)&amp;#123;&amp;#10;&amp;#9;//&amp;#20986;&amp;#38169;&amp;#26102;&amp;#25191;&amp;#34892;&amp;#30340;handler&amp;#10;&amp;#9;close(fd);&amp;#10;&amp;#125;);&amp;#10;*out_fd = fdpair[1];&amp;#10;&amp;#10;//&amp;#35774;&amp;#23450;&amp;#19968;&amp;#27425;&amp;#35835;&amp;#21462;&amp;#30340;&amp;#22823;&amp;#23567;(&amp;#20998;&amp;#21106;&amp;#22823;&amp;#23567;)&amp;#10;dispatch_io_set_low_water(pipe_channel, SIZE_MAX);&amp;#10;dispatch_io_read(pipe_channel, 0, SIZE_MAX, pipe_q, ^(bool done, dispatch_data_t pipedata, int err)&amp;#123;&amp;#10;&amp;#9;if (error)&amp;#10;&amp;#9;&amp;#9;return;&amp;#10;&amp;#9;if (err == 0)&amp;#10;&amp;#9;&amp;#123;&amp;#10;&amp;#9;&amp;#9;//&amp;#27599;&amp;#27425;&amp;#35835;&amp;#21462;&amp;#21040;&amp;#25968;&amp;#25454;&amp;#36827;&amp;#34892;&amp;#25968;&amp;#25454;&amp;#30340;&amp;#22788;&amp;#29702;&amp;#10;&amp;#9;&amp;#9;size_t len = dispatch_data_get_size(pipedata);&amp;#10;&amp;#9;&amp;#9;if (len &amp;#62; 0)&amp;#10;&amp;#9;&amp;#9;&amp;#123;&amp;#10;&amp;#9;&amp;#9;&amp;#9;const char *bytes = NULL;&amp;#10;&amp;#9;&amp;#9;&amp;#9;char *encoded;&amp;#10;&amp;#9;&amp;#9;&amp;#9;uint32_t eval;&amp;#10;&amp;#9;&amp;#9;&amp;#9;dispatch_data_t md = dispatch_data_create_map(pipedata, (const void **)&amp;#38;bytes, &amp;#38;len);&amp;#10;&amp;#9;&amp;#9;&amp;#9;encoded = asl_core_encode_buffer(bytes, len);&amp;#10;&amp;#9;&amp;#9;&amp;#9;asl_msg_set_key_val(aux, ASL_KEY_AUX_DATA, encoded);&amp;#10;&amp;#9;&amp;#9;&amp;#9;free(encoded);&amp;#10;&amp;#9;&amp;#9;&amp;#9;eval = _asl_evaluate_send(NULL, (aslmsg)aux, -1);&amp;#10;&amp;#9;&amp;#9;&amp;#9;_asl_send_message(NULL, eval, aux, NULL);&amp;#10;&amp;#9;&amp;#9;&amp;#9;asl_msg_release(aux);&amp;#10;&amp;#9;&amp;#9;&amp;#9;dispatch_release(md);&amp;#10;&amp;#9;&amp;#9;&amp;#125;&amp;#10;&amp;#9;&amp;#125;&amp;#10;&amp;#9;if (done)&amp;#10;&amp;#9;&amp;#123;&amp;#10;&amp;#9;&amp;#9;//&amp;#24182;&amp;#21457;&amp;#35835;&amp;#21462;&amp;#23436;&amp;#27605;&amp;#10;&amp;#9;&amp;#9;dispatch_semaphore_signal(sem);&amp;#10;&amp;#9;&amp;#9;dispatch_release(pipe_channel);&amp;#10;&amp;#9;&amp;#9;dispatch_release(pipe_q);&amp;#10;&amp;#9;&amp;#125;&amp;#10;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假如你的数据文件比较大，可以考虑采用dispatch IO的方式来提高读取的速率。&lt;/p&gt;
&lt;h4 id=&quot;Dispatch-Source&quot;&gt;&lt;a href=&quot;#Dispatch-Source&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Source&quot;&gt;&lt;/a&gt;Dispatch Source&lt;/h4&gt;&lt;p&gt;dispatch框架提供一套接口用于监听系统底层对象(如文件描述符、Mach端口、信号量等)，当这些对象有事件产生时会自动把事件的处理block函数提交到dispatch队列中执行，这套接口就是Dispatch Source API，Dispatch Source其实就是对kqueue功能的封装，可以去查看dispatch_source的c源码实现(什么是kqueue？Google，什么是Mach端口? Google Again)，Dispatch Source主要处理以下几种事件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_SOURCE_TYPE_DATA_ADD   &amp;#21464;&amp;#37327;&amp;#22686;&amp;#21152;&amp;#10;DISPATCH_SOURCE_TYPE_DATA_OR    &amp;#21464;&amp;#37327;OR&amp;#10;DISPATCH_SOURCE_TYPE_MACH_SEND  Mach&amp;#31471;&amp;#21475;&amp;#21457;&amp;#36865;&amp;#10;DISPATCH_SOURCE_TYPE_MACH_RECV  Mach&amp;#31471;&amp;#21475;&amp;#25509;&amp;#25910;&amp;#10;DISPATCH_SOURCE_TYPE_MEMORYPRESSURE &amp;#20869;&amp;#23384;&amp;#21387;&amp;#21147;&amp;#24773;&amp;#20917;&amp;#21464;&amp;#21270;&amp;#10;DISPATCH_SOURCE_TYPE_PROC       &amp;#19982;&amp;#36827;&amp;#31243;&amp;#30456;&amp;#20851;&amp;#30340;&amp;#20107;&amp;#20214;&amp;#10;DISPATCH_SOURCE_TYPE_READ       &amp;#21487;&amp;#35835;&amp;#21462;&amp;#25991;&amp;#20214;&amp;#26144;&amp;#20687;&amp;#10;DISPATCH_SOURCE_TYPE_SIGNAL     &amp;#25509;&amp;#25910;&amp;#20449;&amp;#21495;&amp;#10;DISPATCH_SOURCE_TYPE_TIMER      &amp;#23450;&amp;#26102;&amp;#22120;&amp;#20107;&amp;#20214;&amp;#10;DISPATCH_SOURCE_TYPE_VNODE      &amp;#25991;&amp;#20214;&amp;#31995;&amp;#32479;&amp;#21464;&amp;#26356;&amp;#10;DISPATCH_SOURCE_TYPE_WRITE      &amp;#21487;&amp;#20889;&amp;#20837;&amp;#25991;&amp;#20214;&amp;#26144;&amp;#20687;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当有事件发生时，dispatch source自动将一个block放入一个dispatch queue执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;dispatch_source_create&lt;br&gt;创建一个dispatch source，需要指定事件源的类型,handler的执行队列，dispatch source创建完之后将处于挂起状态。此时dispatch source会接收事件，但是不会进行处理，你需要设置事件处理的handler，并执行额外的配置；同时为了防止事件堆积到dispatch queue中，dispatch source还会对事件进行合并，如果新事件在上一个事件处理handler执行之前到达，dispatch source会根据事件的类型替换或者合并新旧事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dispatch_source_set_event_handler&lt;br&gt;给指定的dispatch source设置事件发生的处理handler&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;dispatch_source_set_cancel_handler&lt;br&gt;给指定的dispatch source设置一个取消处理handler，取消处理handler会在dispatch soruce释放之前做些清理工作，比如关闭文件描述符:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_source_set_cancel_handler(mySource, ^&amp;#123; &amp;#10;   close(fd); //&amp;#20851;&amp;#38381;&amp;#25991;&amp;#20214;&amp;#31186;&amp;#36895;&amp;#31526; &amp;#10;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;dispatch_source_cancel&lt;br&gt;异步地关闭dispatch source，这样后续的事件发生时不去调用对应的事件处理handler，但已经在执行的handler不会被取消。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多第三方库会用到dispatch source的功能，比如著名的IM框架XMPPFramework在涉及到定时器的时候都采用这种方法，比如发送心跳包的时候(&lt;a href=&quot;https://github.com/robbiehanson/XMPPFramework/blob/master/Core/XMPPStream.m&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;setupKeepAliveTimer&lt;/a&gt;)。&lt;br&gt;一个简单的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#22914;&amp;#26524;dispatch source&amp;#26159;&amp;#26412;&amp;#22320;&amp;#21464;&amp;#37327;&amp;#65292;&amp;#20250;&amp;#34987;&amp;#37322;&amp;#25918;&amp;#25481;&amp;#65292;&amp;#38656;&amp;#35201;&amp;#36825;&amp;#20040;&amp;#22768;&amp;#26126;&amp;#10;@property (nonatomic)dispatch_source_t timerSource;&amp;#10;&amp;#10;//&amp;#20107;&amp;#20214;handler&amp;#30340;&amp;#22788;&amp;#29702;&amp;#38431;&amp;#21015;&amp;#10;dispatch_queue_t queue = dispatch_queue_create(&amp;#34;myqueue&amp;#34;, NULL);&amp;#10;&amp;#10;//&amp;#10;_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);&amp;#10;&amp;#10;//&amp;#23450;&amp;#26102;&amp;#22120;&amp;#38388;&amp;#38548;&amp;#26102;&amp;#38388;&amp;#10;uint64_t interval = 2 * NSEC_PER_SEC;&amp;#10;//&amp;#35774;&amp;#32622;&amp;#23450;&amp;#26102;&amp;#22120;&amp;#20449;&amp;#24687;&amp;#10;dispatch_source_set_timer(_timerSource,DISPATCH_TIME_NOW, interval , 0);&amp;#10;&amp;#10;//&amp;#35774;&amp;#32622;&amp;#20107;&amp;#20214;&amp;#30340;&amp;#22788;&amp;#29702;handler&amp;#10;dispatch_source_set_event_handler(_timerSource, ^&amp;#123;&amp;#10;    NSLog(@&amp;#34;receive time event&amp;#34;);&amp;#10;    //if (done) &amp;#10;    //   dispatch_source_cancel(_timerSource); &amp;#10;&amp;#125;);&amp;#10;//&amp;#24320;&amp;#22987;&amp;#22788;&amp;#29702;&amp;#23450;&amp;#26102;&amp;#22120;&amp;#20107;&amp;#20214;&amp;#65292;dispatch_suspend&amp;#26242;&amp;#20572;&amp;#22788;&amp;#29702;&amp;#20107;&amp;#20214;&amp;#10;dispatch_resume(_timerSource);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;定时器还可以通过NSTimer实现，不过NSTimer会跟runloop关联在一起，主线层默认有一个runloop，假如你nstimer是运行在子线程，就需要自己手动开启一个runloop，而且nstimer默认是在NSDefaultRunLoopMode模式下的，所以当runloop切换到其它模式nstimer就不会运行，需要手动将nstimer添加到NSRunLoopCommonModes模式下；而dispatch source timer不跟runloop关联，所以有些场景可以使用这种方法。&lt;/p&gt;
&lt;p&gt;本文总结了GCD的一些用法，不过有些API可能iOS8之后才可以用，如有还有什么可以补充的，欢迎提出～&lt;/p&gt;
&lt;h4 id=&quot;部分参考&quot;&gt;&lt;a href=&quot;#部分参考&quot; class=&quot;headerlink&quot; title=&quot;部分参考&quot;&gt;&lt;/a&gt;部分参考&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;dispatch源码地址：&lt;a href=&quot;http://libdispatch.macosforge.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://libdispatch.macosforge.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015-718/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Building Responsive and Efficient Apps with GCD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Grand Central Dispatch (GCD) Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.amazon.cn/Objective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-iOS%E4%B8%8EOS-X%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%9D%82%E6%9C%AC%E4%B8%80%E6%A0%91/dp/B00DE60G3S/ref=sr_1_8?ie=UTF8&amp;amp;qid=1447952737&amp;amp;sr=8-8&amp;amp;keywords=iOS&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Objective-C高级编程:iOS与OS X多线程和内存管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在之前我们介绍过NSOperation的一些东西，这次我们来聊一聊另一个iOS开发最经常使用的技术之一 — GCD，GCD将线程的管理移到系统级别，你只需要定义好要执行的任务，然后丢到合适的Dispatch queue，GCD会负责创建线程来执行你的代码，由于这部分是处于系统级别，所以执行的性能通常非常高。GCD这部分代码苹果已开源，有兴趣的可以去下载了解一下:&lt;a href=&quot;http://libdispatch.macosforge.org/&quot;&gt;地址&lt;/a&gt;&lt;br&gt;在介绍GCD之前我们先了解一下Quality of Service：&lt;/p&gt;
&lt;h3 id=&quot;Quality-of-Service-QoS&quot;&gt;&lt;a href=&quot;#Quality-of-Service-QoS&quot; class=&quot;headerlink&quot; title=&quot;Quality of Service(QoS)&quot;&gt;&lt;/a&gt;Quality of Service(QoS)&lt;/h3&gt;&lt;p&gt;这是在iOS8之后提供的新功能，苹果提供了几个Quality of Service枚举来使用:user interactive, user initiated, utility 和 background，通过这告诉系统我们在进行什么样的工作，然后系统会通过合理的资源控制来最高效的执行任务代码，其中主要涉及到CPU调度的优先级、IO优先级、任务运行在哪个线程以及运行的顺序等等，我们通过一个抽象的Quality of Service参数来表明任务的意图以及类别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSQualityOfServiceUserInteractive&lt;br&gt;与用户交互的任务，这些任务通常跟UI级别的刷新相关，比如动画，这些任务需要在一瞬间完成&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceUserInitiated&lt;br&gt;由用户发起的并且需要立即得到结果的任务，比如滑动scroll view时去加载数据用于后续cell的显示，这些任务通常跟后续的用户交互相关，在几秒或者更短的时间内完成&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceUtility&lt;br&gt;一些可能需要花点时间的任务，这些任务不需要马上返回结果，比如下载的任务，这些任务可能花费几秒或者几分钟的时间&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceBackground&lt;br&gt;这些任务对用户不可见，比如后台进行备份的操作，这些任务可能需要较长的时间，几分钟甚至几个小时&lt;/li&gt;
&lt;li&gt;NSQualityOfServiceDefault&lt;br&gt;优先级介于user-initiated 和 utility，当没有 QoS信息时默认使用，开发者不应该使用这个值来设置自己的任务&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="GCD" scheme="http://freemind-lj.github.io/tags/GCD/"/>
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>NSOperation和NSOperationQueue的一些事儿</title>
    <link href="http://freemind-lj.github.io/2015/11/02/NSOperation%E5%92%8CNSOperationQueue%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://freemind-lj.github.io/2015/11/02/NSOperation和NSOperationQueue的一些事儿/</id>
    <published>2015-11-02T08:06:56.000Z</published>
    <updated>2016-02-15T03:06:08.000Z</updated>
    
    <content type="html">&lt;p&gt;在面对多线程的时候，大多数会选择NSOperation或者GCD来实现，GCD由于使用起来非常方便，应该是很多开发者的首选，不过你会发现其实很多开源代码都是使用NSOpertaion来执行异步任务,所以这次我们来说说NSOperation跟NSOperationQueue，以及它的强大之处。&lt;/p&gt;
&lt;h3 id=&quot;NSOPerationQueue&quot;&gt;&lt;a href=&quot;#NSOPerationQueue&quot; class=&quot;headerlink&quot; title=&quot;NSOPerationQueue&quot;&gt;&lt;/a&gt;NSOPerationQueue&lt;/h3&gt;&lt;p&gt;NSOperation可以通过调用start方法同步地执行相应的任务，不过通常NSOprtaion都是配合NSOPerationQueue来使用的，NSOperationQueue可以看作是一种高级的dispatch queue，将NSOperation加入到queue中，queue会自动异步的执行该NSOperation&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#21019;&amp;#24314;&amp;#38431;&amp;#21015;&amp;#10;NSOperationQueue *queue = [[NSOperationQueue alloc] init];  &amp;#10;&amp;#10;//&amp;#23558;NSOperation&amp;#21152;&amp;#20837;&amp;#38431;&amp;#21015;&amp;#20043;&amp;#21518;&amp;#65292;queue&amp;#20250;&amp;#33258;&amp;#21160;&amp;#25191;&amp;#34892;&amp;#35813;operation&amp;#10;[queue addOperation:operation];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在gcd编程的时候，我们无法取消block对应的任务，不过NSOPerationQueue之所以称为高级的dispatch queue除了能异步的执行任务之外，还能够:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取消操作&lt;br&gt;当NSOperation加入到NSOperationQueue之后，可以通过调用cancel方法取消单个任务，如果想取消所有的任务可以调用cancelAllOperations方法;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#21462;&amp;#28040;&amp;#19968;&amp;#20010;&amp;#20219;&amp;#21153; &amp;#10;[operation cancel];  &amp;#10;  &amp;#10;// &amp;#21462;&amp;#28040;queue&amp;#20013;&amp;#25152;&amp;#26377;&amp;#30340;&amp;#20219;&amp;#21153;  &amp;#10;[queue cancelAllOperations];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;设置最大并发数&lt;br&gt;我们可以通过设置maxConcurrentOperationCount来设置队列的最大并发数，比如当网络为Wi-Fi时设置为6，3G时设置为2：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#35774;&amp;#32622;&amp;#24182;&amp;#21457;&amp;#25968;&amp;#30446;&amp;#20026;2&amp;#10;queue.maxConcurrentOperationCount = 2;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假如maxConcurrentOperationCount的值设为1，可以看作该队列为串行队列，每次只能执行一个任务。不过NSOPerationQueue不是先进先出（FIFO）队列，这点跟dispatch queue有点区别，dispatch queue中的block会按照FIFO的顺序去执行，NSOPerationQueue会根据Operation的状态(是否Ready)以及优先级来确定执行的NSOperation的顺序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;暂停跟继续&lt;br&gt;假如想要暂停NSOperation的执行，可以调用queue的setSuspended:方法暂停queue继续调度运行新的任务，不过正在执行的任务无法暂停&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#26242;&amp;#20572;&amp;#38431;&amp;#21015;&amp;#36816;&amp;#34892;&amp;#20219;&amp;#21153;&amp;#10;[queue setSuspended:YES];&amp;#10;&amp;#10;// &amp;#32487;&amp;#32493;&amp;#10;[queue setSuspended:NO];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;队列优先级&lt;br&gt;iOS8之后引入了QualityOfService的概念，类似于线程的优先级，设置不同的QualityOfService值后系统会分配不同的CPU时间、网络资源和硬盘资源等，因此我们可以通过这个设置队列的优先级，NSQualityOfService定义了几个枚举值：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;UserInteractive&lt;/strong&gt;: 任务跟界面的一些UI相关，比如绘制屏幕内容跟处理点击事件等，处于最高优先级的任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UserInitiated&lt;/strong&gt; : 用户一些请求的任务，关系到后面的交互，比如用户点击消息按钮后获取邮件列表的任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Utility:&lt;/strong&gt; 处理一些用户并不立即需要结果的任务，比如定期的内容更新之类的任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Background&lt;/strong&gt;:后台任务，用户不会察觉到这些任务，比如后台对文件进行索引方便后续搜索，优先级最低；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Default:&lt;/strong&gt; 默认值，介于UserInitiated跟Utility之间&lt;/p&gt;
&lt;h3 id=&quot;NSOperaion&quot;&gt;&lt;a href=&quot;#NSOperaion&quot; class=&quot;headerlink&quot; title=&quot;NSOperaion&quot;&gt;&lt;/a&gt;NSOperaion&lt;/h3&gt;&lt;p&gt;NSOperation可以看作是高级的dispatch block(dispatch_block_t),我们可以将一个任务封装成一个NSOperation对象，然后放到NSOperationQueue中去异步执行。NSOperation分为concurrent(并发任务)跟non-concurrent(非并发任务)两种，两者主要是生命周期的管理有些区别，NSOperation是一个抽象类，我们需要继承于它并实现一些方法。(当任务相对简单的时候，可以直接使用NSInvocationOperation或是NSBlockOperation，这两者也都继承自NSOperation)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;non-concurrent operation&lt;br&gt;实现一个non-concurrent operation只需要简单的继承NSOperation并实现main方法即可,NSOperationQueue会调用NSOperation的start方法，然后在start方法中调用main方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface NonConcurrentOperation : NSOperation&amp;#10;@end&amp;#10;@implementation NonConcurrentOperation&amp;#10;&amp;#10;-(void)main&amp;#10;&amp;#123;&amp;#10;    NSLog(@&amp;#34;main called&amp;#34;);&amp;#10;    &amp;#10;    dispatch_time_t time=dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);&amp;#10;    __weak typeof(self) weakSelf = self;&amp;#10;    dispatch_after(time, dispatch_get_main_queue(), ^&amp;#123;&amp;#10;        &amp;#10;        NSLog(@&amp;#34;weakSelf:%@&amp;#34;,weakSelf);&amp;#10;    &amp;#125;);&amp;#10;&amp;#125;&amp;#10;-(void)dealloc&amp;#10;&amp;#123;&amp;#10;    NSLog(@&amp;#34;dealloc called&amp;#34;);&amp;#10;&amp;#125;&amp;#10;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;non-concurrent operation会同步的运行main方法，不管期间的任务需要运行多长时间，当在执行完main方法后该operation对象会被释放。假如你在main方法中执行了异步的操作时会出现错误，比如上述的代码可以发现main方法运行完后就调用dealloc方法释放了，导致weakSelf的值为空。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSOperations[1467:91483] main called&amp;#10;NSOperations[1467:91483] dealloc called&amp;#10;NSOperations[1467:91218] weakSelf:(null)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;concurrent operation&lt;br&gt;当你的任务是并发的任务是异步任务时，你需要的是继承NSOperation并至少实现start、isExecuting和isFinished方法，其中isExecuting跟isFinished两个属性值的改变需要做KVO通知。&lt;br&gt;concurrent operation的生命周期跟non-concurrent operation不一样，可以在start方法中执行异步的方法，当start方法执行完之后该operation对象不会被释放，直到该operation执行结束，收到isFinished的kvo通知。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#29366;&amp;#24577;&amp;#26522;&amp;#20030;&amp;#10;typedef NS_ENUM(NSInteger, ConcurrentOperationState) &amp;#123;&amp;#10;    ConcurrentOperationReadyState = 1,&amp;#10;    ConcurrentOperationExecutingState,&amp;#10;    ConcurrentOperationFinishedState&amp;#10;&amp;#125;;&amp;#10;&amp;#10;@interface ConcurrentOperation ()&amp;#10;@property (nonatomic, assign) ConcurrentOperationState state;&amp;#10;@end&amp;#10;&amp;#10;@implementation ConcurrentOperation&amp;#10;&amp;#10;- (BOOL)isReady &amp;#123;&amp;#10;    self.state = ConcurrentOperationReadyState;&amp;#10;    return self.state == ConcurrentOperationReadyState;&amp;#10;&amp;#125;&amp;#10;- (BOOL)isExecuting&amp;#123;&amp;#10;    return self.state == ConcurrentOperationExecutingState;&amp;#10;&amp;#125;&amp;#10;- (BOOL)isFinished&amp;#123;&amp;#10;    return self.state == ConcurrentOperationFinishedState;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)start &amp;#123;&amp;#10;    __weak typeof(self) weakSelf = self;&amp;#10;    dispatch_time_t time=dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);&amp;#10;    dispatch_after(time, dispatch_get_main_queue(), ^&amp;#123;&amp;#10;&amp;#10;        //kvo&amp;#65306;&amp;#32467;&amp;#26463;&amp;#10;        [weakSelf willChangeValueForKey:@&amp;#34;isFinished&amp;#34;];&amp;#10;        weakSelf.state = ConcurrentOperationFinishedState;&amp;#10;        [weakSelf didChangeValueForKey:@&amp;#34;isFinished&amp;#34;];&amp;#10;        &amp;#10;        NSLog(@&amp;#34;finished :%@&amp;#34;,weakSelf);&amp;#10;    &amp;#125;);&amp;#10;    NSLog(@&amp;#34;start called&amp;#34;);&amp;#10;&amp;#10;    //kvo&amp;#65306;&amp;#27491;&amp;#22312;&amp;#25191;&amp;#34892;&amp;#10;    [weakSelf willChangeValueForKey:@&amp;#34;isExecuting&amp;#34;];&amp;#10;    weakSelf.state = ConcurrentOperationExecutingState;&amp;#10;    [weakSelf didChangeValueForKey:@&amp;#34;isExecuting&amp;#34;];&amp;#10;&amp;#125;&amp;#10;&amp;#10;-(void)dealloc&amp;#123;&amp;#10;    NSLog(@&amp;#34;dealloc called&amp;#34;);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以从打印的日志看到，当start方法结束后对象并没有立即被释放，只有发出isFinished的kvo通知后，该operation对象才会被释放&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSOperations[1556:103301] start called&amp;#10;NSOperations[1556:103242] finished :&amp;#60;ConcurrentOperation: 0x79a47bf0&amp;#62;&amp;#10;NSOperations[1556:103242] dealloc called&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSOperation状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/NSOperation%E7%8A%B6%E6%80%81.png&quot; alt=&quot;NSOperation状态&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上面的图可以看到nsoperation的几种状态，当这几个状态值改变时需要使用KVO通知，其中处于Pending、Ready跟Executing状态的operation是可以被cancel的，而当operation处于finished状态是无法被取消的。当operation成功结束、失败或者被取消了，isFinished的值都会被设置为yes,所以不能仅仅靠isFinished==YES认为operation成功执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置优先级&lt;br&gt;我们可以设置operation运行的优先级，优先级的选择主要有:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &amp;#123;&amp;#10;&amp;#9;NSOperationQueuePriorityVeryLow = -8L,&amp;#10;&amp;#9;NSOperationQueuePriorityLow = -4L,&amp;#10;&amp;#9;NSOperationQueuePriorityNormal = 0,&amp;#10;&amp;#9;NSOperationQueuePriorityHigh = 4,&amp;#10;&amp;#9;NSOperationQueuePriorityVeryHigh = 8&amp;#10;&amp;#125;;&amp;#10;&amp;#10;//&amp;#35774;&amp;#32622;&amp;#20248;&amp;#20808;&amp;#32423;&amp;#10;[operation1 setQueuePriority:NSOperationQueuePriorityVeryLow];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当operation被添加到队列之后，NSOperationQueue会浏览所有的operation，优先运行那些处于ready状态且优先级较高的操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dependencies&lt;br&gt;NSOperation的另一个强大之处就是可以添加依赖，当operation1依赖于operation2的时候，系统可以保证只有当operation2结束的时候，operation1才会运行，而且依赖不局限于一个队列，你可以依赖一个不同队列的NSOperation。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#9;&amp;#10;@interface NonConcurrentOperation ()&amp;#10;@property(nonatomic,strong)NSNumber *number;&amp;#10;@end&amp;#10;&amp;#10;@implementation NonConcurrentOperation&amp;#10;&amp;#10;-(id)initWithNumber:(NSNumber *)number&amp;#123;&amp;#10;    self = [super init];&amp;#10;    if (self) &amp;#123;&amp;#10;        self.number = number;&amp;#10;    &amp;#125;&amp;#10;    return self;&amp;#10;&amp;#125;&amp;#10;&amp;#10;-(void)main&amp;#10;&amp;#123;&amp;#10;    NSLog(@&amp;#34;main called, %@&amp;#34;,self.number);&amp;#10;&amp;#125;&amp;#10;@end&amp;#10;&amp;#10;//&amp;#27979;&amp;#35797;&amp;#20195;&amp;#30721;&amp;#10;NSOperationQueue  *queue1 = [NSOperationQueue new];&amp;#10;NSOperationQueue  *queue2 = [NSOperationQueue new];&amp;#10;    &amp;#10;NonConcurrentOperation *op1 = [[NonConcurrentOperation alloc] initWithNumber:@(1)];&amp;#10;NonConcurrentOperation *op2 = [[NonConcurrentOperation alloc] initWithNumber:@(2)];&amp;#10;NonConcurrentOperation *op3 = [[NonConcurrentOperation alloc] initWithNumber:@(3)];&amp;#10;NonConcurrentOperation *op4 = [[NonConcurrentOperation alloc] initWithNumber:@(4)];&amp;#10;&amp;#10;//&amp;#28155;&amp;#21152;&amp;#20381;&amp;#36182;&amp;#10;[op1 addDependency:op2];&amp;#10;[op2 addDependency:op3];&amp;#10;&amp;#10;//&amp;#21487;&amp;#20197;&amp;#20381;&amp;#36182;&amp;#19981;&amp;#21516;&amp;#38431;&amp;#21015;&amp;#30340;operation&amp;#10;[op3 addDependency:op4];&amp;#10;    &amp;#10;[queue1 addOperation:op1];&amp;#10;[queue1 addOperation:op2];&amp;#10;[queue1 addOperation:op3];&amp;#10;[queue2 addOperation:op4]; //&amp;#28155;&amp;#21152;&amp;#21040;&amp;#19981;&amp;#21516;&amp;#38431;&amp;#21015;&amp;#20013;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出结果:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSOperations[2105:179596] main called, 4&amp;#10;NSOperations[2105:179596] main called, 3&amp;#10;NSOperations[2105:179596] main called, 2&amp;#10;NSOperations[2105:179596] main called, 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;添加依赖的时候需要注意不要相互依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[op1 addDependency:op2];&amp;#10;[op2 addDependency:op1];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果相互依赖，双方都会等待对方结束导致相互之间都无法执行。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E4%BA%92%E7%9B%B8%E4%BE%9D%E8%B5%96.png&quot; alt=&quot;互相依赖.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;抽象化逻辑&lt;br&gt;NSOperation可以用来抽象化一些业务逻辑，业务之间有依赖的情况可以通过dependency来简化。比如有的业务场景需要收藏一篇文章，由于收藏文章需要用户的信息，而获取用户的信息又需要去登陆获取，所以我们可以将登陆、获取用户信息以及收藏文章抽象封装封装成3个operation，而其中的逻辑关系通过dependency来实现，降低逻辑复杂度，而且业务之间的关系变得可组装：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#33719;&amp;#21462;&amp;#29992;&amp;#25143;&amp;#20449;&amp;#24687;&amp;#38656;&amp;#35201;&amp;#30331;&amp;#38470;&amp;#23436;&amp;#25165;&amp;#33021;&amp;#25191;&amp;#34892;&amp;#10;[userInfoOperation addDependency:loginOperation];&amp;#10;&amp;#10;//&amp;#25910;&amp;#34255;&amp;#38656;&amp;#35201;&amp;#33719;&amp;#21462;&amp;#21040;&amp;#29992;&amp;#25143;&amp;#20449;&amp;#24687;&amp;#21518;&amp;#25165;&amp;#33021;&amp;#25191;&amp;#34892;&amp;#10;[favorOperation addDependency:userInfoOperation];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E4%B8%9A%E5%8A%A1%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB.png&quot; alt=&quot;业务间的联系.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;不过NSOperation跟NSOperation底层也是基于GCD实现的，它是更高层次的抽象，当你框架设计涉及到这块内容的时候应该优先考虑使用NSOperations，这样框架的结构相对会好些，类似SDwebimgag跟AFNetworking等很多开源框架都在使用NSOperations。不过不可否认gcd代码编写更简便，这边就当抛砖引玉吧～&lt;/p&gt;
&lt;h5 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h5&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/index.html#//apple_ref/doc/uid/TP40004591&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSOperation&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://greenchiu.github.io/blog/2013/08/06/ren-shi-nsoperation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;認識NSOperation&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015-226/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Advanced NSOperations&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在面对多线程的时候，大多数会选择NSOperation或者GCD来实现，GCD由于使用起来非常方便，应该是很多开发者的首选，不过你会发现其实很多开源代码都是使用NSOpertaion来执行异步任务,所以这次我们来说说NSOperation跟NSOperationQueue，以及它的强大之处。&lt;/p&gt;
&lt;h3 id=&quot;NSOPerationQueue&quot;&gt;&lt;a href=&quot;#NSOPerationQueue&quot; class=&quot;headerlink&quot; title=&quot;NSOPerationQueue&quot;&gt;&lt;/a&gt;NSOPerationQueue&lt;/h3&gt;&lt;p&gt;NSOperation可以通过调用start方法同步地执行相应的任务，不过通常NSOprtaion都是配合NSOPerationQueue来使用的，NSOperationQueue可以看作是一种高级的dispatch queue，将NSOperation加入到queue中，queue会自动异步的执行该NSOperation&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#21019;&amp;#24314;&amp;#38431;&amp;#21015;&amp;#10;NSOperationQueue *queue = [[NSOperationQueue alloc] init];  &amp;#10;&amp;#10;//&amp;#23558;NSOperation&amp;#21152;&amp;#20837;&amp;#38431;&amp;#21015;&amp;#20043;&amp;#21518;&amp;#65292;queue&amp;#20250;&amp;#33258;&amp;#21160;&amp;#25191;&amp;#34892;&amp;#35813;operation&amp;#10;[queue addOperation:operation];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在gcd编程的时候，我们无法取消block对应的任务，不过NSOPerationQueue之所以称为高级的dispatch queue除了能异步的执行任务之外，还能够:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取消操作&lt;br&gt;当NSOperation加入到NSOperationQueue之后，可以通过调用cancel方法取消单个任务，如果想取消所有的任务可以调用cancelAllOperations方法;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#21462;&amp;#28040;&amp;#19968;&amp;#20010;&amp;#20219;&amp;#21153; &amp;#10;[operation cancel];  &amp;#10;  &amp;#10;// &amp;#21462;&amp;#28040;queue&amp;#20013;&amp;#25152;&amp;#26377;&amp;#30340;&amp;#20219;&amp;#21153;  &amp;#10;[queue cancelAllOperations];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="GCD" scheme="http://freemind-lj.github.io/tags/GCD/"/>
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>IM开发(2)-XMPP iOS开发</title>
    <link href="http://freemind-lj.github.io/2015/10/20/IM%E5%BC%80%E5%8F%91-2-XMPP-iOS%E5%BC%80%E5%8F%91/"/>
    <id>http://freemind-lj.github.io/2015/10/20/IM开发-2-XMPP-iOS开发/</id>
    <published>2015-10-20T04:30:46.000Z</published>
    <updated>2016-02-15T03:54:34.000Z</updated>
    
    <content type="html">&lt;p&gt;搭建完&lt;a href=&quot;http://www.jianshu.com/p/f801229de016&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;本地服务器&lt;/a&gt;之后，我们便可以着手客户端的工作，这里我们使用&lt;a href=&quot;https://github.com/robbiehanson/XMPPFramework&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XMPPFramework&lt;/a&gt;这个开源库，安卓平台可以使用&lt;a href=&quot;https://github.com/igniterealtime/Smack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Smack&lt;/a&gt;(最好使用4.1以及之后的版本，支持流管理)，为了简单起见这里只实现登陆、获取好友列表以及聊天等功能，页面如下所示：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/user2%E7%9A%84%E5%A5%BD%E5%8F%8B%E5%88%97%E8%A1%A8.png&quot; alt=&quot;user2的好友列表.png&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E8%81%8A%E5%A4%A9.png&quot; alt=&quot;聊天.png&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/center&gt;

&lt;h4 id=&quot;xmpp初始化&quot;&gt;&lt;a href=&quot;#xmpp初始化&quot; class=&quot;headerlink&quot; title=&quot;xmpp初始化&quot;&gt;&lt;/a&gt;xmpp初始化&lt;/h4&gt;&lt;p&gt;  在开始使用xmpp进行IM聊天之前，我们需要初始化xmpp流，接入我们需要的模块：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define JBXMPP_HOST @&amp;#34;lujiangbin.local&amp;#34;&amp;#10;#define JBXMPP_PORT 5222&amp;#10;- (void)setupStream&amp;#10;&amp;#123;&amp;#10;&amp;#160; &amp;#160; if (!_xmppStream) &amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; _xmppStream = [[XMPPStream alloc] init];&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [self.xmppStream setHostName:JBXMPP_HOST]; //&amp;#35774;&amp;#32622;xmpp&amp;#26381;&amp;#21153;&amp;#22120;&amp;#22320;&amp;#22336;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [self.xmppStream setHostPort:JBXMPP_PORT]; //&amp;#35774;&amp;#32622;xmpp&amp;#31471;&amp;#21475;&amp;#65292;&amp;#40664;&amp;#35748;5222&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [self.xmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [self.xmppStream setKeepAliveInterval:30]; //&amp;#24515;&amp;#36339;&amp;#21253;&amp;#26102;&amp;#38388;&amp;#10;&amp;#10;        //&amp;#20801;&amp;#35768;xmpp&amp;#22312;&amp;#21518;&amp;#21488;&amp;#36816;&amp;#34892;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; self.xmppStream.enableBackgroundingOnSocket=YES;&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; //&amp;#25509;&amp;#20837;&amp;#26029;&amp;#32447;&amp;#37325;&amp;#36830;&amp;#27169;&amp;#22359;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; _xmppReconnect = [[XMPPReconnect alloc] init];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [_xmppReconnect setAutoReconnect:YES];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [_xmppReconnect activate:self.xmppStream];&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; //&amp;#25509;&amp;#20837;&amp;#27969;&amp;#31649;&amp;#29702;&amp;#27169;&amp;#22359;&amp;#65292;&amp;#29992;&amp;#20110;&amp;#27969;&amp;#24674;&amp;#22797;&amp;#36319;&amp;#28040;&amp;#24687;&amp;#30830;&amp;#35748;&amp;#65292;&amp;#22312;&amp;#31227;&amp;#21160;&amp;#31471;&amp;#24456;&amp;#37325;&amp;#35201;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; _storage = [XMPPStreamManagementMemoryStorage new];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; _xmppStreamManagement = [[XMPPStreamManagement alloc] initWithStorage:_storage];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; _xmppStreamManagement.autoResume = YES;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [_xmppStreamManagement addDelegate:self delegateQueue:dispatch_get_main_queue()];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [_xmppStreamManagement activate:self.xmppStream];&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; //&amp;#25509;&amp;#20837;&amp;#22909;&amp;#21451;&amp;#27169;&amp;#22359;&amp;#65292;&amp;#21487;&amp;#20197;&amp;#33719;&amp;#21462;&amp;#22909;&amp;#21451;&amp;#21015;&amp;#34920;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; _xmppRosterMemoryStorage = [[XMPPRosterMemoryStorage alloc] init];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; _xmppRoster = [[XMPPRoster alloc] initWithRosterStorage:_xmppRosterMemoryStorage];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [_xmppRoster activate:self.xmppStream];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [_xmppRoster addDelegate:self delegateQueue:dispatch_get_main_queue()];&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; //&amp;#25509;&amp;#20837;&amp;#28040;&amp;#24687;&amp;#27169;&amp;#22359;&amp;#65292;&amp;#23558;&amp;#28040;&amp;#24687;&amp;#23384;&amp;#20648;&amp;#21040;&amp;#26412;&amp;#22320;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; _xmppMessageArchivingCoreDataStorage = [XMPPMessageArchivingCoreDataStorage sharedInstance];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; _xmppMessageArchiving = [[XMPPMessageArchiving alloc] initWithMessageArchivingStorage:_xmppMessageArchivingCoreDataStorage dispatchQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 9)];&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [_xmppMessageArchiving activate:self.xmppStream];&amp;#10;&amp;#160; &amp;#160; &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;登陆&quot;&gt;&lt;a href=&quot;#登陆&quot; class=&quot;headerlink&quot; title=&quot;登陆&quot;&gt;&lt;/a&gt;登陆&lt;/h4&gt;&lt;p&gt;xmpp的登陆过程比较繁琐，登陆过程包括初始化流、TLS握手和SASL验证等，想要了解各个阶段服务端跟客户端之间交互的内容可以查看&lt;a href=&quot;https://github.com/winterSleep/XMPPBlog/blob/master/1-%E5%BB%BA%E7%AB%8Bsocket%E5%88%B0%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;，就不在详细介绍。XMPPFramework将整个复杂的登陆过程都封装起来了，客户端调用connectWithTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr连接服务器，然后在xmppStreamDidConnect代理方法输入密码验证登陆，这里我们使用在搭建服务器时创建的两个用户，user1和user2。&lt;br&gt; &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define JBXMPP_DOMAIN @&amp;#34;lujiangbin.local&amp;#34;&amp;#10;-(void)loginWithName:(NSString *)userName andPassword:(NSString *)password&amp;#10;&amp;#123;&amp;#10;&amp;#160; &amp;#160; _myJID = [XMPPJID jidWithUser:userName domain:JBXMPP_DOMAIN resource:@&amp;#34;iOS&amp;#34;];&amp;#10;&amp;#160; &amp;#160; self.myPassword = password;&amp;#10;&amp;#160; &amp;#160; [self.xmppStream setMyJID:_myJID];&amp;#10;&amp;#160; &amp;#160; NSError *error = nil;&amp;#10;&amp;#160; &amp;#160; [_xmppStream connectWithTimeout:XMPPStreamTimeoutNone error:&amp;#38;error]&amp;#65307;&amp;#10;&amp;#125;&amp;#10;&amp;#10;#pragma mark -- connect delegate&amp;#10;//&amp;#36755;&amp;#20837;&amp;#23494;&amp;#30721;&amp;#39564;&amp;#35777;&amp;#30331;&amp;#38470;&amp;#10;- (void)xmppStreamDidConnect:(XMPPStream *)sender&amp;#10;&amp;#123;&amp;#10;&amp;#160; &amp;#160; NSError *error = nil;&amp;#10;&amp;#160; &amp;#160;[[self xmppStream] authenticateWithPassword:_myPassword error:&amp;#38;error]&amp;#65307;&amp;#10;&amp;#125;&amp;#10;&amp;#10;//&amp;#30331;&amp;#38470;&amp;#25104;&amp;#21151;&amp;#10;- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender&amp;#10;&amp;#123;&amp;#10;&amp;#160; &amp;#160; NSLog(@&amp;#34;%s&amp;#34;,__func__);&amp;#10;    //&amp;#21457;&amp;#36865;&amp;#22312;&amp;#32447;&amp;#36890;&amp;#30693;&amp;#32473;&amp;#26381;&amp;#21153;&amp;#22120;&amp;#65292;&amp;#26381;&amp;#21153;&amp;#22120;&amp;#25165;&amp;#20250;&amp;#23558;&amp;#31163;&amp;#32447;&amp;#28040;&amp;#24687;&amp;#25512;&amp;#36865;&amp;#36807;&amp;#26469;&amp;#10;    XMPPPresence *presence = [XMPPPresence presence]; // &amp;#40664;&amp;#35748;&amp;#34;available&amp;#34; &amp;#10;&amp;#160; &amp;#160; [[self xmppStream] sendElement:presence];&amp;#10;&amp;#160; &amp;#160; //&amp;#21551;&amp;#29992;&amp;#27969;&amp;#31649;&amp;#29702;&amp;#10;&amp;#160; &amp;#160; [_xmppStreamManagement enableStreamManagementWithResumption:YES maxTimeout:0];&amp;#10;&amp;#125;&amp;#10;//&amp;#30331;&amp;#38470;&amp;#22833;&amp;#36133;&amp;#10;- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error&amp;#10;&amp;#123;&amp;#10;&amp;#160; &amp;#160; NSLog(@&amp;#34;%s&amp;#34;,__func__);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;获取好友列表&quot;&gt;&lt;a href=&quot;#获取好友列表&quot; class=&quot;headerlink&quot; title=&quot;获取好友列表&quot;&gt;&lt;/a&gt;获取好友列表&lt;/h4&gt;&lt;p&gt;登陆成功之后，我们可以通过XMPPRoster去获取好友列表，在示例中我们为了简单起见使用&lt;br&gt;XMPPRosterMemoryStorage将好友存储在内存中，在实际场景你可以将好友存储在&lt;br&gt;XMPPRosterCoreDataStorage，xmppframework使用coredata将好友保存到本地，可以在初始化xmpp流的时候设置。为了获取好友列表，只需调用fetchRoster方法:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#33719;&amp;#21462;&amp;#26381;&amp;#21153;&amp;#22120;&amp;#22909;&amp;#21451;&amp;#21015;&amp;#34920;&amp;#10;&amp;#160; &amp;#160; [[[JBXMPPManager sharedInstance] xmppRoster] fetchRoster];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;消息&quot;&gt;&lt;a href=&quot;#消息&quot; class=&quot;headerlink&quot; title=&quot;消息&quot;&gt;&lt;/a&gt;消息&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;消息发送&lt;br&gt;只需要调用xmpp的sendElement:方法，由于xmpp只支持文本，所以假如你想发送二进制的文件，比如语音图片等，可以先压缩然后用base64编码，接收方收到再做解码工作，比如语音可以压缩成amr格式，amr格式安卓可以直接播放，iOS需要在解压成wav格式，可以参考&lt;a href=&quot;https://github.com/FreeMind-LJ/IMChatDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)sendMessage:(NSString *)message to:(XMPPJID *)jid&amp;#10;&amp;#123;&amp;#10;&amp;#160; &amp;#160; XMPPMessage* newMessage = [[XMPPMessage alloc] initWithType:@&amp;#34;chat&amp;#34; to:jid];&amp;#10;&amp;#160; &amp;#160; [newMessage addBody:message]; //&amp;#28040;&amp;#24687;&amp;#20869;&amp;#23481;&amp;#10;&amp;#160; &amp;#160; [_xmppStream sendElement:newMessage];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;消息接收&lt;br&gt;当收到消息的时候，xmppframework会调用didReceiveMessage：代理方法，由于我们在初始化流的时候将消息设置存储到本地，可以看到XMPPMessageArchiving在didReceiveMessage收到消息的时候将消息存储起来。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// XMPPMessageArchiving.m&amp;#10;- (void)xmppStream:(XMPPStream *)sender didSendMessage:(XMPPMessage *)message&amp;#10;&amp;#123;&amp;#10;     if ([self shouldArchiveMessage:message outgoing:YES xmppStream:sender])&amp;#10;     &amp;#123;&amp;#10;         [xmppMessageArchivingStorage archiveMessage:message outgoing:YES     xmppStream:sender];&amp;#10;     &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;消息确认&lt;br&gt;为了防止发出去的消息丢失了，可以接入消息回执模块(XEP-184)，这样对方每收到一条消息的时候都会返回一条确认的消息，如果没收到该条确认消息可以认为发送失败，确认消息的格式如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &amp;#160;&amp;#10;&amp;#60;message to=&amp;#34;user2@lujiangbin.local&amp;#34;&amp;#62;&amp;#10;&amp;#160; &amp;#60;received xmlns=&amp;#34;urn:xmpp:receipts&amp;#34; id=&amp;#34;&amp;#28040;&amp;#24687;ID&amp;#34;/&amp;#62;&amp;#10;&amp;#60;/message&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过这种方法也有些弊端，比如每次收到一条消息都必须回复，一定程度上会浪费流量以及影响服务器的性能，所以一般采用流管理来实现消息确认。&lt;/p&gt;
&lt;h4 id=&quot;流关闭&quot;&gt;&lt;a href=&quot;#流关闭&quot; class=&quot;headerlink&quot; title=&quot;流关闭&quot;&gt;&lt;/a&gt;流关闭&lt;/h4&gt;&lt;p&gt;当退出程序的时候，最好能给服务器发送关闭流的通知，也就是发送结束流，服务器收到之后开始将后续发给该对象的消息收集到离线仓库中，当客户端重新上线的时候，服务端会主动将离线消息推送过来，这样不会丢失消息。由于客户端的操作经常是切到后台然后直接关掉程序，因此可以监听UIApplicationWillTerminateNotification消息，然后手动关闭流。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillTerminate) name:UIApplicationWillTerminateNotification object:nil];&amp;#10;&amp;#10;#pragma mark -- terminate&amp;#10;/**&amp;#10;&amp;#160;*&amp;#160; &amp;#30003;&amp;#35831;&amp;#21518;&amp;#21488;&amp;#26356;&amp;#22810;&amp;#30340;&amp;#26102;&amp;#38388;&amp;#26469;&amp;#23436;&amp;#25104;&amp;#20851;&amp;#38381;&amp;#27969;&amp;#30340;&amp;#20219;&amp;#21153;&amp;#10;&amp;#160;*/&amp;#10;-(void)applicationWillTerminate&amp;#10;&amp;#123;&amp;#10;&amp;#160; &amp;#160; UIApplication *app=[UIApplication sharedApplication];&amp;#10;&amp;#160; &amp;#160; UIBackgroundTaskIdentifier taskId;&amp;#10;&amp;#160; &amp;#160; taskId=[app beginBackgroundTaskWithExpirationHandler:^(void)&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [app endBackgroundTask:taskId];&amp;#10;&amp;#160; &amp;#160; &amp;#125;];&amp;#10;&amp;#160; &amp;#160; if(taskId==UIBackgroundTaskInvalid)&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; return;&amp;#10;&amp;#160; &amp;#160; &amp;#125;&amp;#10;&amp;#160; &amp;#160; [_xmppStream disconnectAfterSendingEndStream];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;流管理&quot;&gt;&lt;a href=&quot;#流管理&quot; class=&quot;headerlink&quot; title=&quot;流管理&quot;&gt;&lt;/a&gt;流管理&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://xmpp.org/extensions/xep-0198.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stream Management&lt;/a&gt;是为了流恢复跟节确认而增加的。理想情况下，客户端发送关闭流的通知给服务器，服务器将后续的消息存储到离线仓库，等客户端再登陆上线的时候推送过来，但是在移动端网络可能随时断掉，这时候服务器并不会马上察觉(只能依靠TCP超时或者服务器自己的心跳包)，它会认为对方还在线，将后续的消息发送过去，这样到服务器知道对方掉线的这段时间，期间的消息就丢失了，所以需要流管理来处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节确认(stanza acknowledgement)&lt;br&gt;用来确认一段时间内节(包括&amp;amp;ltiq/&amp;amp;lt,&amp;amp;ltmessage/&amp;amp;lt,&lt;presence&gt;,不是&lt;iq&gt;&lt;br&gt;,&lt;message&gt;,或&lt;presence&gt;这样的stanzas不会在流管理中被确认跟计数的)是否被对方接收，客户端跟服务端都各自有有两个h值用来维护这些信息。从客户端来看，其中一个h值用于记录收到的节，比如当收到服务推送的消息时，会将该h值加1；另一个h值用于记录发出去的节，当发出一条消息时该h值也加1，所以为了确认消息是否被收到其实都是在比较双方的两个h值。&lt;br&gt;为了查询这些h值，xmpp定义了 &lt;a&gt; 和 &lt;r&gt; 两个元素，&lt;r&gt;用户请求节的确认消息，&lt;a&gt;用于回答节的确认消息，必须携带自己已处理的h值。&lt;/a&gt;&lt;/r&gt;&lt;/r&gt;&lt;/a&gt;&lt;/presence&gt;&lt;/message&gt;&lt;/iq&gt;&lt;/presence&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#26381;&amp;#21153;&amp;#31471;: &amp;#60;r xmlns=&amp;#39;urn:xmpp:sm:3&amp;#39;/&amp;#62;&amp;#10;&amp;#23458;&amp;#25143;&amp;#31471;: &amp;#60;a xmlns=&amp;#39;urn:xmpp:sm:3&amp;#39; h=&amp;#39;3&amp;#39;/&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如服务端发送&lt;r&gt;请求，客户端返回自己接受收到的h值（3），然后服务端会根据这个h值跟它自己记录发出去的节的h值做比较，假如小的话会重新发送剩下的节，来防止节丢失。&lt;/r&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;流恢复&lt;br&gt;由于移动网络可能随时down掉，所以在我们重连上来的时候需要的是快速恢复上一次的流，而不是重新新建一个流，roster的检索以及状态的广播，流管理可以通过上一次的流id（当启用流管理的时候，服务端会生成一个id来表示一个流）以及双方的h值来完成流的快速恢复以及这期间的节确认，发送未被确认的节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开启流管理&lt;br&gt;要想启用流管理，客户端发送&lt;enable&gt;元素给服务端，服务端返回&lt;enabled&gt;元素表示该流已经被管理了，同时有一个id值来标示这个流，xmppframework开启流管理只需要调用&lt;br&gt;enableStreamManagementWithResumption: maxTimeout:接口：&lt;/enabled&gt;&lt;/enable&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#23458;&amp;#25143;&amp;#31471;: &amp;#60;enable xmlns=&amp;#39;urn:xmpp:sm:3&amp;#39; resume=&amp;#39;true&amp;#39;/&amp;#62;&amp;#10;&amp;#26381;&amp;#21153;&amp;#31471;: &amp;#60;enabled xmlns=&amp;#39;urn:xmpp:sm:3&amp;#39; id=&amp;#39;&amp;#27969;id&amp;#39; resume=&amp;#39;true&amp;#39;/&amp;#62;&amp;#10;&amp;#10;- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender&amp;#10;&amp;#123;&amp;#10;&amp;#160; &amp;#160; //&amp;#30331;&amp;#38470;&amp;#23436;&amp;#25104;&amp;#21518;&amp;#65292;&amp;#21551;&amp;#29992;&amp;#27969;&amp;#31649;&amp;#29702;&amp;#10;&amp;#160; &amp;#160; [_xmppStreamManagement enableStreamManagementWithResumption:YES maxTimeout:0];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;请求流恢复&lt;br&gt;当客户端想要恢复一个流的时候，需要发送&lt;resume&gt;元素以及一个previd值，也就是想要恢复的上一次的流id，当流可以恢复的时候，服务端会返回&lt;resumed&gt;元素，双方都会携带一个h值用于节确认。&lt;/resumed&gt;&lt;/resume&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#23458;&amp;#25143;&amp;#31471;: &amp;#60;resume xmlns=&amp;#39;urn:xmpp:sm:3&amp;#39; h=&amp;#39;&amp;#23458;&amp;#25143;&amp;#31471;&amp;#25509;&amp;#25910;&amp;#30340;h&amp;#20540;&amp;#39; previd=&amp;#39;&amp;#27969;id&amp;#39;/&amp;#62;&amp;#10;&amp;#26381;&amp;#21153;&amp;#31471;: &amp;#60;resumed xmlns=&amp;#39;urn:xmpp:sm:3&amp;#39; h=&amp;#39;&amp;#26381;&amp;#21153;&amp;#31471;&amp;#25509;&amp;#25910;&amp;#30340;h&amp;#20540;&amp;#39; previd=&amp;#39;&amp;#27969;id&amp;#39;/&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;xmppframework将这部分逻辑封装在内部，不过这些h跟流id的值是存储在内存中，当程序退出的时候这些值就没了，也就无法恢复流。所以实际应用的时候需要将这些值保存到本地，比如&lt;a href=&quot;https://github.com/FreeMind-LJ/IMChatDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo&lt;/a&gt;里的XMPPStreamManagementPersistentStorage。&lt;/p&gt;
&lt;h4 id=&quot;xmpp注意点&quot;&gt;&lt;a href=&quot;#xmpp注意点&quot; class=&quot;headerlink&quot; title=&quot;xmpp注意点&quot;&gt;&lt;/a&gt;xmpp注意点&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;文件http上传&lt;br&gt;由于xmpp只支持文本，所以类似音频这种二进制文件需要用base64转成文本形式，但更好的方式是采用http上传文件，消息体保存的是文件对应的URL。&lt;/li&gt;
&lt;li&gt;登陆改进&lt;br&gt;xmpp的登陆涉及到始化流、TLS握手和SASL验证等，步骤比较繁琐，可以根据情况简化流程。&lt;/li&gt;
&lt;li&gt;TLS加密&lt;br&gt;假如我们的im需要加密，可以开启TLS，不过iOS的TLS&lt;a href=&quot;https://dev.ssllabs.com/ssltest/viewClient.html?name=Apple%20ATS&amp;amp;version=9&amp;amp;platform=iOS%209&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;不支持压缩&lt;/a&gt;。&lt;br&gt;GCDAsyncSocket内部已经帮我们封装协商的过程，不过我们可能会收到错误：kCFStreamErrorDomainSSL Code=-9807，这是由于服务器证书并不是正式的证书，所以需要手动去认证：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#35774;&amp;#32622;&amp;#25163;&amp;#21160;&amp;#35748;&amp;#35777;&amp;#35777;&amp;#20070;&amp;#10;NSMutableDictionary *settings = [NSMutableDictionary dictionary];&amp;#10;[settings setObject:@YES forKey:GCDAsyncSocketManuallyEvaluateTrust];&amp;#10;[asyncSocket startTLS:settings];&amp;#10;&amp;#10;- (void)socketDidSecure:(GCDAsyncSocket *)sock&amp;#10;&amp;#123;&amp;#10;     // &amp;#24320;&amp;#22987;&amp;#25509;&amp;#25910;&amp;#25968;&amp;#25454;&amp;#10;     [sock readDataWithTimeout:TIMEOUT_XMPP_READ_STREAM tag:TAG_XMPP_READ_STREAM];&amp;#10;&amp;#125;&amp;#10;&amp;#10;//&amp;#22312;delegate&amp;#26041;&amp;#27861;&amp;#20013;&amp;#65292;&amp;#25163;&amp;#21160;&amp;#20449;&amp;#20219;&amp;#10;-(void)xmppStream:(XMPPStream *)sender didReceiveTrust:(SecTrustRef)trust completionHandler:(void (^)(BOOL))completionHandler&amp;#10;&amp;#123;&amp;#10;&amp;#160; &amp;#160; if (completionHandler)&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; completionHandler(YES);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一个简单的demo工程可以在&lt;a href=&quot;https://github.com/FreeMind-LJ/IMChatDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;找到。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;搭建完&lt;a href=&quot;http://www.jianshu.com/p/f801229de016&quot;&gt;本地服务器&lt;/a&gt;之后，我们便可以着手客户端的工作，这里我们使用&lt;a href=&quot;https://github.com/robbiehanson/XMPPFramework&quot;&gt;XMPPFramework&lt;/a&gt;这个开源库，安卓平台可以使用&lt;a href=&quot;https://github.com/igniterealtime/Smack&quot;&gt;Smack&lt;/a&gt;(最好使用4.1以及之后的版本，支持流管理)，为了简单起见这里只实现登陆、获取好友列表以及聊天等功能，页面如下所示：&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="IM" scheme="http://freemind-lj.github.io/tags/IM/"/>
    
      <category term="XMPP" scheme="http://freemind-lj.github.io/tags/XMPP/"/>
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>IM开发(1)-ejabberd服务器搭建</title>
    <link href="http://freemind-lj.github.io/2015/10/08/IM%E5%BC%80%E5%8F%91-1-ejabberd%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>http://freemind-lj.github.io/2015/10/08/IM开发-1-ejabberd服务器搭建/</id>
    <published>2015-10-08T10:12:50.000Z</published>
    <updated>2016-02-15T03:17:15.000Z</updated>
    
    <content type="html">&lt;p&gt;最近项目中需要集成IM功能，市面上有很多的第三方提供im服务，比如环信、融云等，但都有使用限制的地方，如果不使用第三方可以自己去实现一套IM系统，不过一个IM系统涉及到的东西比较多，开发难度较高。另一种选择是使用xmpp，xmpp的优点是有很多的开源实现，比如服务端的ejabberd、Openfire，iOS以及安卓端都很优秀的开源库可以使用，而且传输安全以及扩展性强等(环信也是基于xmpp)；同时也有一些缺点，比如不能传输二进制数据以及费流量等，有些地方需要去改进。&lt;br&gt;   下面记录如何使用XMPP来简单实现IM功能，在这之前需要先搭建本地服务器用于测试。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;ejabberd服务器搭建&quot;&gt;&lt;a href=&quot;#ejabberd服务器搭建&quot; class=&quot;headerlink&quot; title=&quot;ejabberd服务器搭建&quot;&gt;&lt;/a&gt;ejabberd服务器搭建&lt;/h3&gt;&lt;p&gt;为了实现IM聊天，需要先搭建一个XMPP服务器，这里我们采用ejabberd来作为服务器，ejabbered采用Erlang语言编写，由于语言的特性天生适合高并发的情景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装Erlang&lt;br&gt;在安装ejabbered之前需要先安装Erlang，在控制台输入命令&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;brew install erlang&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等待安装完成即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装ejabbered&lt;br&gt;ejabbered服务器的安装非常简单，下载&lt;a href=&quot;https://www.process-one.net/en/ejabberd/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ejabberd&lt;/a&gt;安装包直接安装即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/ejabbered%E5%AE%89%E8%A3%85%E5%8C%85.png&quot; alt=&quot;ejabbered安装包.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;安装完之后可以在Applications目录先找到：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png&quot; alt=&quot;目录结构.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;由于我们的服务器只是测试用的，比较重要的是bin目录下的start和stop命令，这两个分别用于开启和关闭xmpp服务，设置这两个命令为可执行：&lt;br&gt; &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;chmod 755 stop&amp;#10;chmod 755 start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;现在输入命令 ./start可以看到如下的页面&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E5%90%AF%E5%8A%A8%E9%A1%B5%E9%9D%A2.png&quot; alt=&quot;启动页面.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;添加用户&lt;br&gt;现在我们的服务器只有administrators，我们需要增加几个用户，也方便后面测试，可以输入&lt;a href=&quot;http://localhost:5280/admin/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:5280/admin/&lt;/a&gt; 到ejabberd的后台管理页面：&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2.png&quot; alt=&quot;管理页面.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;点击虚拟主机，选择用户菜单可以看到添加用户的页面如下，我们添加了user1@lujiangbin.local和user2@lujiangbin.local两个用户：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7.png&quot; alt=&quot;添加用户.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;测试服务器&lt;br&gt;现在可以来测试服务器是否能正常运行了。要测试的话我们需要两个支持xmpp协议的客户端，可以使用Mac OSX自带的iMessage(登陆user1)和Adium(登陆user2) ，其中支持xmpp协议的客户端有：&lt;br&gt;&lt;a href=&quot;http://xmpp.org/xmpp-software/clients/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://xmpp.org/xmpp-software/clients/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打开iMessage添加用户&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7user1.png&quot; alt=&quot;添加用户user1.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;iMessage可能会提示服务器的证书需要验证，点击继续即可：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8B%E5%8D%883.34.55.png&quot; alt=&quot;屏幕快照 2015-10-08 下午3.34.55.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;可以看到user1已经登陆成功了。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E7%99%BB%E9%99%86%E6%88%90%E5%8A%9F.png&quot; alt=&quot;登陆成功&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;接着打开Adium添加user2@lujiangbin.local用户，添加过程跟iMessage类似：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B71.png&quot; alt=&quot;添加用户1.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;设置连接服务器为localhost:&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B72.png&quot; alt=&quot;添加用户2.png&quot;&gt;&lt;br&gt;&lt;/center&gt;


&lt;p&gt;由于现在user1和user2还不是好友关系，因此没法进行聊天，点击iMessage添加好友user2@lujiangbin.local：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E6%B7%BB%E5%8A%A0%E5%A5%BD%E5%8F%8B.png&quot; alt=&quot;添加好友&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;在Adium会收到验证请求，点击接受双方互加好友，接着就可以进行im聊天了：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E5%A5%BD%E5%8F%8B%E6%B7%BB%E5%8A%A0.png&quot; alt=&quot;好友添加.png&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E8%81%8A%E5%A4%A9IM.png&quot; alt=&quot;聊天.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;这样我们确认本地的xmpp服务器是可用的，接下来就可以着手客户端的开发了，可以查看&lt;a href=&quot;http://freemind-lj.github.io/2015/10/20/IM%E5%BC%80%E5%8F%91-2-XMPP-iOS%E5%BC%80%E5%8F%91/&quot;&gt;IM开发(2)-iOS客户端&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目中需要集成IM功能，市面上有很多的第三方提供im服务，比如环信、融云等，但都有使用限制的地方，如果不使用第三方可以自己去实现一套IM系统，不过一个IM系统涉及到的东西比较多，开发难度较高。另一种选择是使用xmpp，xmpp的优点是有很多的开源实现，比如服务端的ejabberd、Openfire，iOS以及安卓端都很优秀的开源库可以使用，而且传输安全以及扩展性强等(环信也是基于xmpp)；同时也有一些缺点，比如不能传输二进制数据以及费流量等，有些地方需要去改进。&lt;br&gt;   下面记录如何使用XMPP来简单实现IM功能，在这之前需要先搭建本地服务器用于测试。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="IM" scheme="http://freemind-lj.github.io/tags/IM/"/>
    
      <category term="XMPP" scheme="http://freemind-lj.github.io/tags/XMPP/"/>
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS app性能优化的那些事(二)</title>
    <link href="http://freemind-lj.github.io/2015/09/09/iOS-app%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B-%E4%BA%8C/"/>
    <id>http://freemind-lj.github.io/2015/09/09/iOS-app性能优化的那些事-二/</id>
    <published>2015-09-09T07:16:28.000Z</published>
    <updated>2016-02-15T03:22:15.000Z</updated>
    
    <content type="html">&lt;p&gt;  这次我们来说说iOS app中滑动的那些事。iOS为了提高滑动的流畅感，特意在滑动的时候将runloop模式切换到UITrackingRunLoopMode，在这个过程中专心做跟滑动相关的工作，这也就是在滑动过程中为什么nstimer无法工作的原因，因为两个没在同一mode下面。但我们可能经常会遇到滑动不怎么流畅的情况，比如在项目中碰到在滑动tableview的时候不怎么顺畅，感觉有点不爽，即便是在测试中表现最好的5s(touch之类的感受更直观)。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/tableview%20%E6%BB%91%E5%8A%A8%E4%B8%8D%E6%B5%81%E7%95%85.png&quot; alt=&quot;tableview 滑动不流畅&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;  那碰到这种情况该怎么处理，分析图像动画性能主要用的是Core Animation这个组件，先简单介绍一下里面一些经常用到的选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Color Blended layers&lt;br&gt;标示混合的图层会为红色,不透明的图层为绿色，通常我们希望绿色的区域越多越好。&lt;/li&gt;
&lt;li&gt;Color Hits Green and Misses Red&lt;br&gt;假如我们设置viewlayer的shouldRasterize为YES，那些成功被缓存的layer会标注为绿色，反之为红色，下面会有详细介绍。&lt;/li&gt;
&lt;li&gt;Color copied images&lt;br&gt;标示那些被Core Animation拷贝的图片。这主要是因为该图片的色彩格式不能被GPU直接处理，需要在CPU这边做转换，假如在主线层做这个操作对性能会有一定的影响。&lt;/li&gt;
&lt;li&gt;Color misaligned images&lt;br&gt;被缩放的图片会被标记为黄色,像素不对齐则会标注为紫色。&lt;/li&gt;
&lt;li&gt;Color offscreen-rendered yellow&lt;br&gt;标示哪些layer需要做离屏渲染(offscreen-render)。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;简单介绍完Core Animation的一些东西之后我们回过头来看看哪些问题会影响到图形的性能，下面这张图摘自WWDC2014(&lt;a href=&quot;https://developer.apple.com/videos/wwdc/2014/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Advanced Graphics and Animations for iOS Apps&lt;/a&gt;，这上面的一些分享非常有技术性)&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/performance%20investigation%20mindset.png&quot; alt=&quot;performance investigation mindset.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;当你碰到性能问题的时候，你可以思考一下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#26159;&amp;#21542;&amp;#21463;&amp;#21040;CPU&amp;#25110;&amp;#32773;GPU&amp;#30340;&amp;#38480;&amp;#21046;&amp;#65311;&amp;#10;&amp;#26159;&amp;#21542;&amp;#26377;&amp;#19981;&amp;#24517;&amp;#35201;&amp;#30340;CPU&amp;#28210;&amp;#26579;&amp;#65311;&amp;#10;&amp;#26159;&amp;#21542;&amp;#26377;&amp;#22826;&amp;#22810;&amp;#30340;&amp;#31163;&amp;#23631;&amp;#28210;&amp;#26579;&amp;#25805;&amp;#20316;&amp;#65311;&amp;#10;&amp;#26159;&amp;#21542;&amp;#26377;&amp;#22826;&amp;#22810;&amp;#30340;&amp;#22270;&amp;#23618;&amp;#28151;&amp;#21512;&amp;#25805;&amp;#20316;&amp;#65311;&amp;#10;&amp;#26159;&amp;#21542;&amp;#26377;&amp;#22855;&amp;#24618;&amp;#30340;&amp;#22270;&amp;#29255;&amp;#26684;&amp;#24335;&amp;#25110;&amp;#32773;&amp;#23610;&amp;#23544;&amp;#65311;&amp;#10;&amp;#26159;&amp;#21542;&amp;#28041;&amp;#21450;&amp;#21040;&amp;#26114;&amp;#36149;&amp;#30340;view&amp;#25110;&amp;#32773;&amp;#25928;&amp;#26524;&amp;#65311;&amp;#10;view&amp;#30340;&amp;#23618;&amp;#27425;&amp;#32467;&amp;#26500;&amp;#26159;&amp;#21542;&amp;#21512;&amp;#29702;&amp;#65311;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;那么哪些是你最该开始考虑的方向呢？通常发生图形性能问题的时候，比如列表滑动不顺畅、动画卡顿等，大部分都是由于Offscreen Rendering(离屏渲染)或者blending导致的，因为这在动画的每一帧都会涉及到。&lt;/p&gt;
&lt;h3 id=&quot;offscreen-render&quot;&gt;&lt;a href=&quot;#offscreen-render&quot; class=&quot;headerlink&quot; title=&quot;offscreen-render&quot;&gt;&lt;/a&gt;offscreen-render&lt;/h3&gt;&lt;p&gt;什么是offscreen-render？offscreen-render涉及的内容比较多，有offscreen-render那就有onscreen render，onscreen render指的是GPU在当前用于显示的屏幕缓冲区进行渲染，相反offscreen-render就是不在当前的屏幕缓存区，而在另外的缓冲区进行渲染，offscreen-render有两种形式：&lt;/p&gt;
&lt;h5 id=&quot;CPU的offscreen-render&quot;&gt;&lt;a href=&quot;#CPU的offscreen-render&quot; class=&quot;headerlink&quot; title=&quot;CPU的offscreen-render&quot;&gt;&lt;/a&gt;CPU的offscreen-render&lt;/h5&gt;&lt;p&gt;使用CPU来完成渲染操纵，通常在你使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;drawRect (如果没有自定义绘制的任务就不要在子类中写一个空的drawRect方法，因为只要实现了该方法，就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 contentsScale的值，造成资源浪费)&lt;/li&gt;
&lt;li&gt;使用Core Graphics&lt;br&gt;上面的两种情况使用的就是CPU离屏渲染，首先分配一块内存，然后进行渲染操作生成一份bitmap位图，整个渲染过程会在你的应用中同步的进行，接着再将位图打包发送到iOS里一个单独的进程–render server，理想情况下，render server将内容交给GPU直接显示到屏幕上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;GPU的offscreen-render&quot;&gt;&lt;a href=&quot;#GPU的offscreen-render&quot; class=&quot;headerlink&quot; title=&quot;GPU的offscreen-render&quot;&gt;&lt;/a&gt;GPU的offscreen-render&lt;/h5&gt;&lt;p&gt;使用GPU在当前屏幕缓冲区以外开辟一个新的缓冲区进行绘制，通常发生的情况有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置cornerRadius, masks, shadows,edge antialiasing等&lt;/li&gt;
&lt;li&gt;设置layer.shouldRasterize ＝ YES&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;渲染流程&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;offscreen-render对性能到底有什么影响？通常大家说的离屏渲染指的是GPU这块(当然CPU这块也会有影响，也需要消耗一定的资源)，比如修改了layer的阴影或者圆角，GPU需要做额外的渲染操作。通常GPU在做渲染的时候是很快的，但是涉及到offscreen-render的时候情况就可能有些不同，因为需要额外开辟一个新的缓冲区进行渲染，然后绘制到当前屏幕的过程需要做onscreen跟offscreen上下文之间的切换，这个过程的消耗会比较昂贵，涉及到OpenGL的pipeline跟barrier，而且offscreen-render在每一帧都会涉及到，因此处理不当肯定会对性能产生一定的影响，所以可以的话尽量减少offscreen-render的图层，查看哪些图层需要离屏渲染可以用Instruments的Core Animation工具进行检测，Color Offscreen-Rendered Yellow选项会将对应的图层标记为黄色。&lt;/p&gt;
&lt;h3 id=&quot;Blending&quot;&gt;&lt;a href=&quot;#Blending&quot; class=&quot;headerlink&quot; title=&quot;Blending&quot;&gt;&lt;/a&gt;Blending&lt;/h3&gt;&lt;p&gt;假如最上层的view是不透明的，那直接使用这个view的对应颜色之就可以，但如果view是透明的，在计算像素的颜色值时就需要计算它下面图层，透明的视图越多，计算量就越大，因此也会对图形的性能产生一定的影响，所以可以的话也尽量减少透明图层的数目。&lt;/p&gt;
&lt;h2 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h2&gt;&lt;p&gt;下面给出一个简单&lt;a href=&quot;https://github.com/FreeMind-LJ/OptimiseDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo&lt;/a&gt;的优化过程，这个demo里面涉及到的问题是在实际项目中所碰到的，也就是最上面那张图里列表滑动不流畅情况—由阴影以及圆角导致的offscreen-render。&lt;br&gt;整个页面就是一个简单的tableview，其中头像为圆角，一个label有阴影效果，滑动的时候在iPod上帧率只有可怜的28FPS。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/Color%20Offscreen-Rendered%20Yellow.png&quot; alt=&quot;Color Offscreen-Rendered Yellow&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/28FPS.png&quot; alt=&quot;28FPS.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;其中黄色的区域就是离屏渲染的地方，也就是含有圆角跟阴影的layer。&lt;/p&gt;
&lt;h5 id=&quot;shadowPath&quot;&gt;&lt;a href=&quot;#shadowPath&quot; class=&quot;headerlink&quot; title=&quot;shadowPath&quot;&gt;&lt;/a&gt;shadowPath&lt;/h5&gt;&lt;p&gt;设置label的阴影效果可以通过：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cell.sign.layer.shadowOffset = CGSizeMake(0, 2);&amp;#10;&amp;#160; &amp;#160; cell.sign.layer.shadowOpacity = 0.5;&amp;#10;&amp;#160; &amp;#160; cell.sign.layer.shadowColor = [UIColor blackColor].CGColor;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是你可以发现这会导致离屏渲染，一个简单的不需要离屏渲染的方法就是制定阴影的路径，也就是设置layer的shadowPath属性，通过instruments发现阴影的地方没有黄色了，帧率也提高到了40FPS：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cell.sign.layer.shadowPath = [UIBezierPath&amp;#160; bezierPathWithRect:cell.sign.bounds].CGPath;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E8%AE%BE%E7%BD%AEshadowPath%E6%B6%88%E9%99%A4%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93.png&quot; alt=&quot;设置shadowPath消除离屏渲染.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h5 id=&quot;rasterize&quot;&gt;&lt;a href=&quot;#rasterize&quot; class=&quot;headerlink&quot; title=&quot;rasterize&quot;&gt;&lt;/a&gt;rasterize&lt;/h5&gt;&lt;p&gt;对于圆角这种类似导致的性能问题，最简单的就是在列表中不要使用圆角，假如要使用圆角的话，一种最快提升性能的方式就是设置layer的shouldRasterize为YES：&lt;br&gt; &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#160; &amp;#160; cell.layer.shouldRasterize = YES;&amp;#10;&amp;#160; &amp;#160; cell.layer.rasterizationScale = [UIScreen mainScreen].scale;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;虽然被Rasterize的图层也会引起离屏渲染，如下图所示，整个cell都被标示为黄色：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/shouldRasterize.png&quot; alt=&quot;shouldRasterize.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;layer设置shouldRasterize＝YES之后，会把被光栅化的图层保存成位图并缓存起来，其中圆角或者阴影之类的效果也是直接保存到位图当中，当需要渲染到屏幕上的时候只需要到缓存中去取对应的位图进行显示就行了，加快了整个渲染过程。可以通过勾选instruments core animation中的Color Hits Green and Misses Red选项来查看图层是否被缓存了，如果图层显示为绿色则表示已经被缓存起来了，也就是这个缓冲区的内容被复用了，不用在去重新创建缓冲区，反之则是用红色标示。如下图可以看到设置shouldRasterize之后，cell都被标示为绿色了，如果滑动过程中发现都是红色的证明就有问题了：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/cached.png&quot; alt=&quot;cached.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;再看看现在滑动的帧率：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E4%BC%98%E5%8C%96%E5%90%8E.png&quot; alt=&quot;优化后.png&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;可以发现现在滚动的性能大大提高了，光栅化对于那些有很多子view嵌套在一起、view的层级复杂或者有很复杂特效效果的图层有很明显的提升，因为这些内容都被缓存到位图当中了。但是使用光栅化需要注意一些内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适用于内容基本不变的图层&lt;br&gt;假如图层的内容经常变化，比如cell里面有涉及到动画之类的，那么缓存的内容就无效了，GPU需要重新创建缓存区，导致离屏渲染，这又涉及到OpenGL的上下文环境切换，反而降低性能。&lt;/li&gt;
&lt;li&gt;不要过度使用&lt;br&gt;缓存区的大小被设置为屏幕大小的2.5倍，假如过分使用同样会导致大量的离屏渲染。&lt;/li&gt;
&lt;li&gt;如果缓存的内容超过100ms没有被使用则会被回收。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;tips&quot;&gt;&lt;a href=&quot;#tips&quot; class=&quot;headerlink&quot; title=&quot;tips&quot;&gt;&lt;/a&gt;tips&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对于圆角可以使用一张中间圆形透明的图覆盖在上面，虽然这会引入blending操作，但是大部分情况下性能会比离屏渲染好。&lt;/li&gt;
&lt;li&gt;让你的view层次结构平坦一些，因为OpenGL在渲染layer的时候，在碰到有子层级layer的时候可能需要停下来把两者合成到一个buffer里再接着渲染。（When the OpenGL renderer goes to draw each layer, it may have to stop for some subhierarchies and composite them into a single buffer）.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;延迟加载图片&lt;br&gt;有时候在边滚动边设置图片的时候可能会有一定的影响，因此可以在滚动的时候imageview不执行setimage的操作，滚动停止的时候才加载图片，由于滚动的时候NSRunloop是处于UITrackingRunLoopMode模式下，可以采用如下的方式，将设置图片放到NSDefaultRunLoopMode模式下才进行：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIImage *downloadedImage = ...;&amp;#10;&amp;#160; &amp;#160; [self.avatarImageView performSelector:@selector(setImage:)&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; withObject:downloadedImage&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; afterDelay:0&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; inModes:@[NSDefaultRunLoopMode]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图片加载的极限优化方式：&lt;a href=&quot;https://github.com/path/FastImageCache&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FastImageCache&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;图形性能这块有什么好的想法也可提出来交流一下～～&lt;/p&gt;
&lt;h5 id=&quot;参考：&quot;&gt;&lt;a href=&quot;#参考：&quot; class=&quot;headerlink&quot; title=&quot;参考：&quot;&gt;&lt;/a&gt;参考：&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://lobste.rs/s/ckm4uw/a_performance-minded_take_on_ios_design/comments/itdkfh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://lobste.rs/s/ckm4uw/a_performance-minded_take_on_ios_design/comments/itdkfh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/wwdc/2014/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Advanced Graphics and Animations for iOS Apps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://iosinjordan.tumblr.com/post/56778173518/help-my-tables-dont-scroll-smoothly&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://iosinjordan.tumblr.com/post/56778173518/help-my-tables-dont-scroll-smoothly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  这次我们来说说iOS app中滑动的那些事。iOS为了提高滑动的流畅感，特意在滑动的时候将runloop模式切换到UITrackingRunLoopMode，在这个过程中专心做跟滑动相关的工作，这也就是在滑动过程中为什么nstimer无法工作的原因，因为两个没在同一mode下面。但我们可能经常会遇到滑动不怎么流畅的情况，比如在项目中碰到在滑动tableview的时候不怎么顺畅，感觉有点不爽，即便是在测试中表现最好的5s(touch之类的感受更直观)。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/tableview%20%E6%BB%91%E5%8A%A8%E4%B8%8D%E6%B5%81%E7%95%85.png&quot; alt=&quot;tableview 滑动不流畅&quot;&gt;&lt;br&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="性能优化" scheme="http://freemind-lj.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS app性能优化的那些事</title>
    <link href="http://freemind-lj.github.io/2015/09/05/iOS-app%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://freemind-lj.github.io/2015/09/05/iOS-app性能优化的那些事/</id>
    <published>2015-09-05T09:18:33.000Z</published>
    <updated>2016-02-15T03:23:48.000Z</updated>
    
    <content type="html">&lt;p&gt;  iPhone上面的应用一直都是以流畅的操作体验而著称，但是由于之前开发人员把注意力更多的放在开发功能上面，比较少去考虑性能的问题，可能这其中涉及到objective－c,c++跟lua，优化起来相对复杂一些，导致应用在比如touch等较低端的产品上，光从启动到进入页面就花了将近一分钟的时间，页面之间的切换没有那种很流畅的感觉，内存也居高不下，比较影响应用的用户体验，所以很有必要进行一些优化，下面记录一下我在优化的过程中的一些心得：&lt;/p&gt;
&lt;h3 id=&quot;1-instruments&quot;&gt;&lt;a href=&quot;#1-instruments&quot; class=&quot;headerlink&quot; title=&quot;1 instruments&quot;&gt;&lt;/a&gt;1 instruments&lt;/h3&gt;&lt;p&gt;  在iOS上进行性能分析的时候，首先考虑借助instruments这个利器分析出问题出在哪，不要凭空想象，不然你可能把精力花在了1%的问题上，最后发现其实啥都没优化，比如要查看程序哪些部分最耗时，可以使用Time Profiler，要查看内存是否泄漏了，可以使用Leaks等。关于instruments网上有很多资料，作为一个合格iOS开发者，熟悉这个工具还是很有必要的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;2-不要阻塞主线程&quot;&gt;&lt;a href=&quot;#2-不要阻塞主线程&quot; class=&quot;headerlink&quot; title=&quot;2 不要阻塞主线程&quot;&gt;&lt;/a&gt;2 不要阻塞主线程&lt;/h3&gt;&lt;p&gt;  在iOS里关于UIKit的操作都是放在主线程，因此如果主线程被阻塞住了，你的UI可能无法及时响应事件，给人一种卡顿的感觉。大多数阻塞主线程的情况是在主线程做IO操作，比如文件的读写，包含数据库、图片、json文本或者log日志等，尽量将这些操作放放到子线程(如果数据库有一次有较多的操作，记得采用事务来处理，性能相差还是挺大的)，或者在后台建立对应的dispatch queue来做这些操作，比如一个低级别的serial queue来负责log文件的记录等等。程序中如果你的代码逻辑是按照同步的逻辑来写的，尽量修改逻辑代码吧。。。&lt;/p&gt;
&lt;h3 id=&quot;3-使用cache&quot;&gt;&lt;a href=&quot;#3-使用cache&quot; class=&quot;headerlink&quot; title=&quot;3 使用cache&quot;&gt;&lt;/a&gt;3 使用cache&lt;/h3&gt;&lt;p&gt;  一般为了提升用户体验，都会在应用中使用缓存，比如对于图片资源可以使用SDWebImage这个开源库，里面就实现了一个图片缓存的功能。参考SDWebImage的代码自己也可以实现缓存功能:&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/cache%E7%AE%80%E5%8D%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png&quot; alt=&quot;cache简单示意图&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;业务层根据资源的url向resourcemanager获取对应的资源，resourcemanager首先会到memorycache这边去获取资源，memorycache可以利用NSCache实现，因为NSCache首先是线程安全的，而且在收到内存警告的时候会自己释放对应的内存；如果memorycache没有对应的资源再去disk查找，disk也没有的话再去internet获取，获取到的话会更新到memorycache和disk中，具体可以去参考一下SDWebimage的实现细节。&lt;/p&gt;
&lt;h3 id=&quot;4-减少程序启动过程中的任务&quot;&gt;&lt;a href=&quot;#4-减少程序启动过程中的任务&quot; class=&quot;headerlink&quot; title=&quot;4 减少程序启动过程中的任务&quot;&gt;&lt;/a&gt;4 减少程序启动过程中的任务&lt;/h3&gt;&lt;p&gt;当用户点击app的图标之后，程序应该尽可能快的进入到主页面，尽可能减少用户的等待时间，比如我们的应用程序在启动的时候会去做3d模型的渲染操作，完成之后在进入首页面展示，但其实我们可以先进入到主页面，将渲染3d的任务放到子线程去完成，缩短用户需要等待的时间。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/3d.png&quot; alt=&quot;3d&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;5-使用合适的数据结构&quot;&gt;&lt;a href=&quot;#5-使用合适的数据结构&quot; class=&quot;headerlink&quot; title=&quot;5 使用合适的数据结构&quot;&gt;&lt;/a&gt;5 使用合适的数据结构&lt;/h3&gt;&lt;p&gt;根据不同的业务场景来选择合适的数据结构，可能在数据量比较少的时候看不出什么区别，但是假如你存储的数据量比较大且数据结构比较复杂的话，这有可能会影响到你的程序性能。一般用的比较多的数据结构就是array，但我们知道它的查找复杂度是O(n)，因此假如需要快速的查找某个元素，可以使用map。可以参考下&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Collections/Collections.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; &lt;a href=&quot;https://developer.apple.com/library/ios/#documentation/cocoa/conceptual/collections/Collections.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple Collections Programming Topics&lt;/a&gt; &lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;6-内存&quot;&gt;&lt;a href=&quot;#6-内存&quot; class=&quot;headerlink&quot; title=&quot;6 内存&quot;&gt;&lt;/a&gt;6 内存&lt;/h3&gt;&lt;p&gt;一般开发都使用的ARC，不太需要开发者去关注内存的创建和释放这块，但假如你使用的是MRC，并且跟其它语言混杂在一起(比如c++和lua)等的时候，如何确保内存正确释放就是你需要考虑的问题了。有时候一些内存泄漏instruments可能无法准确的分析出来，那么就需要自己去排查了，可以使用&lt;a href=&quot;http://www.jianshu.com/p/be1ddd8c699f&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;method swizzling&lt;/a&gt;方法来辅助我们排查内存泄漏的问题，确保程序的正确运行。&lt;/p&gt;
&lt;h3 id=&quot;7-懒加载view&quot;&gt;&lt;a href=&quot;#7-懒加载view&quot; class=&quot;headerlink&quot; title=&quot;7 懒加载view&quot;&gt;&lt;/a&gt;7 懒加载view&lt;/h3&gt;&lt;p&gt;不要在cell里面嵌套太多的view，这会很影响滑动的流畅感，而且更多的view也需要花费更多的CPU跟内存。假如由于view太多而导致了滑动不流畅，那就不要在一次就把所有的view都创建出来，把部分view放到需要显示cell的时候再去创建。&lt;/p&gt;
&lt;h3 id=&quot;8-lua优化&quot;&gt;&lt;a href=&quot;#8-lua优化&quot; class=&quot;headerlink&quot; title=&quot;8 lua优化&quot;&gt;&lt;/a&gt;8 lua优化&lt;/h3&gt;&lt;p&gt;由于项目的业务是以及部分框架是用lua语言实现的，因此也顺便说一下lua这块遇到的问题。lua号称是最快的脚本语言，一般性能上不会有什么问题，如果lua代码要优化的话，网上也有很多这块优化的&lt;a href=&quot;http://www.cnblogs.com/gdev/archive/2012/08/22/lua-performance-tips-1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;注意点&lt;/a&gt;，这次我主要说个可能影响性能的点—lua的垃圾回收。垃圾回收是一个比较耗时的操作，假如垃圾回收的操作太过于频繁势必会影响到这个程序的运行，比如在iPod在利用lua_cjson解析一份4.7M的json文件是花了3.43s的时间，后来发现跟垃圾回收这块有关。一般内存的使用量适中的话，可以不用去理他，让lua的incremental模式自己去处理，正常情况这个会工作的比较好；假如想要自己去控制gc的运行，可以设置gc的参数，这些参数可能会跟项目有一定的关系，可以自己多试验取最优值。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//gc &amp;#30340;&amp;#21442;&amp;#25968;&amp;#35774;&amp;#32622;&amp;#65292;&amp;#26681;&amp;#25454;&amp;#24773;&amp;#20917;&amp;#21462;&amp;#26368;&amp;#20248;&amp;#20540;&amp;#10;collectgarbage(&amp;#34;setpause&amp;#34;, 150)&amp;#10;collectgarbage(&amp;#34;setstepmul&amp;#34;, 200)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  iPhone上面的应用一直都是以流畅的操作体验而著称，但是由于之前开发人员把注意力更多的放在开发功能上面，比较少去考虑性能的问题，可能这其中涉及到objective－c,c++跟lua，优化起来相对复杂一些，导致应用在比如touch等较低端的产品上，光从启动到进入页面就花了将近一分钟的时间，页面之间的切换没有那种很流畅的感觉，内存也居高不下，比较影响应用的用户体验，所以很有必要进行一些优化，下面记录一下我在优化的过程中的一些心得：&lt;/p&gt;
&lt;h3 id=&quot;1-instruments&quot;&gt;&lt;a href=&quot;#1-instruments&quot; class=&quot;headerlink&quot; title=&quot;1 instruments&quot;&gt;&lt;/a&gt;1 instruments&lt;/h3&gt;&lt;p&gt;  在iOS上进行性能分析的时候，首先考虑借助instruments这个利器分析出问题出在哪，不要凭空想象，不然你可能把精力花在了1%的问题上，最后发现其实啥都没优化，比如要查看程序哪些部分最耗时，可以使用Time Profiler，要查看内存是否泄漏了，可以使用Leaks等。关于instruments网上有很多资料，作为一个合格iOS开发者，熟悉这个工具还是很有必要的。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="性能优化" scheme="http://freemind-lj.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ogre3D在Mac平台的编译</title>
    <link href="http://freemind-lj.github.io/2015/08/26/ogre3D%E5%9C%A8Mac%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%BC%96%E8%AF%91/"/>
    <id>http://freemind-lj.github.io/2015/08/26/ogre3D在Mac平台的编译/</id>
    <published>2015-08-26T11:25:10.000Z</published>
    <updated>2016-02-15T03:43:02.000Z</updated>
    
    <content type="html">&lt;p&gt;  本文主要介绍如何在Mac平台下编译一份可以在iOS上运行的ogre3d引擎的sdk，&lt;a href=&quot;http://www.ogre3d.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OGRE&lt;/a&gt;简单来说就是一个图形引擎，并且也只是一个图形引擎，不像cocos2dx之类的游戏引擎，包括网络，声音和物理碰撞等组件，OGRE只专注于图形渲染这块，不过可以方便的结合其它组件来组成一个游戏引擎，具体可以自己去了解。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;编译OGRE3d&quot;&gt;&lt;a href=&quot;#编译OGRE3d&quot; class=&quot;headerlink&quot; title=&quot;编译OGRE3d&quot;&gt;&lt;/a&gt;编译OGRE3d&lt;/h4&gt;&lt;p&gt;首先创建一个文件夹用于放置OGRE3D项目，这个可以随便指定，比如放置在桌面:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir /Users/LJ/Desktop/OGREBuild&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载Ogre3d依赖&lt;br&gt;编译ogre需要首先下载相关的依赖库，由于我们想要编译的是运行在iOS上面的，所以选择现在iOS相关的依赖库,下载地址：&lt;a href=&quot;http://sourceforge.net/projects/ogre/files/ogre-dependencies-mac/1.9/Ogre_iOS_7.0_Dependencies_20140315.dmg/download&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOSDependencies&lt;/a&gt;，打开dmg将里面的文件夹拖到OGREBuild文件夹里面；&lt;/li&gt;
&lt;li&gt;下载ogre3d源码&lt;br&gt;这里我使用的是1.9版本的代码，可以使用下面的命令克隆对应的源码(要先安装Mercurial)：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hg clone https://bitbucket.org/sinbad/ogre ogre3d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后面是指定下载的文件夹名字，文件大小500M左右，下载过程比较缓慢，可以到网盘里面下载：&lt;a href=&quot;http://pan.baidu.com/s/1hqyE8tu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ogre3d&lt;/a&gt;，同样把该文件夹放到OGREBuild里面；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMake安装&lt;br&gt;首先要先安装cmake，安装方法可以参考网上的信息，打开控制台，在ogre3d里面创建一个build文件夹，然后运行cmake命令：&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;lujbdeAir:ogre LJ$ mkdir build&amp;#10;lujbdeAir:ogre LJ$ cd build&amp;#10;lujbdeAir:build LJ$&amp;#160;cmake -DCMAKE_CXX_FLAGS=&amp;#34;$&amp;#123;CMAKE_CXX_FLAGS&amp;#125; -v -stdlib=libc++ -std=c++11&amp;#34;&amp;#10; -D BOOST_ROOT=/Users/LJ/Desktop/OGREBuild/iOSDependencies/include/boost &amp;#10; -D BOOST_INCLUDEDIR=/Users/LJ/Desktop/OGREBuild/iOSDependencies/include/boost &amp;#10; -D BOOST_LIBRARYDIR=/Users/LJ/Desktop/OGREBuild/iOSDependencies/lib&amp;#10; -D OGRE_DEPENDENCIES_DIR=/Users/LJ/Desktop/OGREBuild/iOSDependencies -D OGRE_STATIC=1&amp;#10; -D OGRE_BUILD_SAMPLES=0 -D OGRE_BUILD_PLATFORM_APPLE_IOS=1 -G Xcode ..&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;简单介绍一下cmake里面的参数：&lt;br&gt;DCMAKE_CXX_FLAGS的值表示支持c++11；BOOST_ROOT，BOOST_INCLUDEDIR，BOOST_LIBRARYDIR，OGRE_DEPENDENCIES_DIR分别对应boost库和依赖库的路径；OGRE_STATIC=1表示我们构建的是静态库，OGRE_BUILD_SAMPLES表示是否需要构建sample工程，由于我们只想要build对应的sdk，所以将该值设为0表示不构建sample；同时我们的目标是构建iOS版本的sdk，所以需要设置OGRE_BUILD_PLATFORM_APPLE_IOS＝1。&lt;br&gt;  运行完之后能看到在build文件夹下有个OGRE工程，点击OGRE.xcodeproj就可以开始编译我们的sdk了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译sdk&lt;br&gt;  在运行ogre工程之前，需要配置一些选项，点击Product → Scheme → Edit Scheme，分别设置ALL_BUILD和install target的Build Configuration选项为release，然后设置选择的target为ALL_BUILD。接下来就command+B开始编译，这个过程可能也需要花点时间；build成功之后，在选择install target，同样command＋B编译，完成之后你应该能发现有一个sdk目录，别忘了还需要把build目下的lib文件夹内容拷贝到sdk的lib文件夹下，这里面包含的是iOS运行时需要用到的一些静态库:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/sdk%E7%9B%AE%E5%BD%95.png&quot; alt=&quot;sdk目录&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建iOS demo工程&lt;br&gt;  编译完sdk之后，我们就可以开始构建我们的iOS工程了，为了方便建立ogre工程，我们可以下载一个&lt;a href=&quot;http://sourceforge.net/projects/ogre/files/ogre-dependencies-mac/1.9/Ogre_Xcode4_Templates_20140408.pkg.zip/download&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ogre_Xcode4_Templates&lt;/a&gt;，安装完之后能看到在创建Xcode工程时多了一个选项：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-08-26%20%E4%B8%8B%E5%8D%887.32.51.p.png&quot; alt=&quot;屏幕快照 2015-08-26 下午7.32.51.png&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;点击next便可以创建一个iOS的ogre工程了,可以看到模版帮我们创建了好些文件，包括OgreFramework和demoAPP等，想要运行还需要些配置。&lt;br&gt;打开Build Settings选择”+” add User-Defined Setting，新建OGRE_SDK_ROOT为sdk的路径：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/OGRE_SDK_ROOT%E8%B7%AF%E5%BE%84.png&quot; alt=&quot;OGRE_SDK_ROOT路径&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;设置Header Search Paths:&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/Header%20Search%20Paths.png&quot; alt=&quot;Header Search Paths&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;设置Library Search Paths:&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/Library%20Search%20Paths.png&quot; alt=&quot;Library Search Paths&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;配置完这些内容后，点击运行应该就能看到在iPhone上出现了ogre3d的经典模型画面：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/ogre.png&quot; alt=&quot;ogre&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;接下来就可以开始ogre引擎的研究之旅了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  本文主要介绍如何在Mac平台下编译一份可以在iOS上运行的ogre3d引擎的sdk，&lt;a href=&quot;http://www.ogre3d.org/&quot;&gt;OGRE&lt;/a&gt;简单来说就是一个图形引擎，并且也只是一个图形引擎，不像cocos2dx之类的游戏引擎，包括网络，声音和物理碰撞等组件，OGRE只专注于图形渲染这块，不过可以方便的结合其它组件来组成一个游戏引擎，具体可以自己去了解。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;编译OGRE3d&quot;&gt;&lt;a href=&quot;#编译OGRE3d&quot; class=&quot;headerlink&quot; title=&quot;编译OGRE3d&quot;&gt;&lt;/a&gt;编译OGRE3d&lt;/h4&gt;&lt;p&gt;首先创建一个文件夹用于放置OGRE3D项目，这个可以随便指定，比如放置在桌面:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir /Users/LJ/Desktop/OGREBuild&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载Ogre3d依赖&lt;br&gt;编译ogre需要首先下载相关的依赖库，由于我们想要编译的是运行在iOS上面的，所以选择现在iOS相关的依赖库,下载地址：&lt;a href=&quot;http://sourceforge.net/projects/ogre/files/ogre-dependencies-mac/1.9/Ogre_iOS_7.0_Dependencies_20140315.dmg/download&quot;&gt;iOSDependencies&lt;/a&gt;，打开dmg将里面的文件夹拖到OGREBuild文件夹里面；&lt;/li&gt;
&lt;li&gt;下载ogre3d源码&lt;br&gt;这里我使用的是1.9版本的代码，可以使用下面的命令克隆对应的源码(要先安装Mercurial)：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hg clone https://bitbucket.org/sinbad/ogre ogre3d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后面是指定下载的文件夹名字，文件大小500M左右，下载过程比较缓慢，可以到网盘里面下载：&lt;a href=&quot;http://pan.baidu.com/s/1hqyE8tu&quot;&gt;ogre3d&lt;/a&gt;，同样把该文件夹放到OGREBuild里面；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMake安装&lt;br&gt;首先要先安装cmake，安装方法可以参考网上的信息，打开控制台，在ogre3d里面创建一个build文件夹，然后运行cmake命令：&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="others" scheme="http://freemind-lj.github.io/categories/others/"/>
    
    
      <category term="OGRE" scheme="http://freemind-lj.github.io/tags/OGRE/"/>
    
  </entry>
  
  <entry>
    <title>git遇到的一些问题解决</title>
    <link href="http://freemind-lj.github.io/2015/07/21/git%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://freemind-lj.github.io/2015/07/21/git遇到的一些问题解决/</id>
    <published>2015-07-21T07:27:01.000Z</published>
    <updated>2016-02-15T03:41:27.000Z</updated>
    
    <content type="html">&lt;p&gt;  最近在使用git clone代码的时候遇到了一些问题，现在记录一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只拉取最新版本&lt;br&gt;因为要clone的代码多达4、5个G，在加上里面的分支以及历史太多，因此直接用git clone 命令去克隆的时候经常导致服务端内存爆满，clone不下来。如果不需要去关注以前的版本，可以只clone最新的版本，使用如下命令：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone --depth=1 git://serverRepo myRepo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样就只拉取默认分支的最新版本。如果想获取某个具体的分支，可以使用branch 命令，拉取某个分支的最新版本代码，比如要获取release/1.6.0分支的代码 :&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone -b release/1.6.0 --depth=1 git://serverRepo myRepo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;fatal: The remote end hung up unexpectedly&lt;br&gt;在clone分支的时候可能会失败，比如early EOF：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/clone%E5%A4%B1%E8%B4%A5.png&quot; alt=&quot;clone失败&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;解决的办法是使用ssh协议去clone，而不是http协议。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  最近在使用git clone代码的时候遇到了一些问题，现在记录一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只拉取最新版本&lt;br&gt;因为要clone的代码多达4、5个G，在加上里面的分支以及历史太多，因此直接用git clone 命令去克隆的时候经常导致服务端内存爆满，clone不下
    
    </summary>
    
      <category term="others" scheme="http://freemind-lj.github.io/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS开发之－－ DNS解析(网络切换的问题解决)</title>
    <link href="http://freemind-lj.github.io/2015/06/18/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%EF%BC%8D%EF%BC%8D-DNS%E8%A7%A3%E6%9E%90-%E7%BD%91%E7%BB%9C%E5%88%87%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://freemind-lj.github.io/2015/06/18/iOS开发之－－-DNS解析-网络切换的问题解决/</id>
    <published>2015-06-18T08:28:20.000Z</published>
    <updated>2016-02-15T01:44:19.000Z</updated>
    
    <content type="html">&lt;p&gt;  上次提到过由于电信的问题需要自己手动去解析dns，&lt;a href=&quot;http://www.jianshu.com/p/7c89b8c5482a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;介绍的是如何拦截&lt;br&gt;每一个请求做解析，但是没有说具体的解析方法，下面简单的记录一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;res_query方法&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int res_query(char *domain_name, int class, int type, char *answer_buffer, int answer_buffer_length)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是比较常见的系统调用，使用该方法的时候需要在Xcode中添加libresolv.dylib，然后包含resolv.h头文件即可，具体代码如下：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;unsigned char res[512];&amp;#10;int nBytesRead = 0;&amp;#10;&amp;#10;//&amp;#35843;&amp;#29992;&amp;#31995;&amp;#32479;&amp;#26041;&amp;#27861;&amp;#10;nBytesRead = res_query(&amp;#34;www.baidu.com&amp;#34;, ns_c_in, ns_t_a, res, sizeof(res));&amp;#10;&amp;#10;ns_msg handle;&amp;#10;ns_initparse(res, nBytesRead, &amp;#38;handle);&amp;#10;&amp;#10;NSMutableArray *ipList = nil;&amp;#10;int msg_count = ns_msg_count(handle, ns_s_an);&amp;#10;if (msg_count &amp;#62; 0) &amp;#123;&amp;#10;    ipList = [[NSMutableArray alloc] initWithCapacity:msg_count];&amp;#10;    for(int rrnum = 0; rrnum &amp;#60; msg_count; rrnum++) &amp;#123;&amp;#10;        ns_rr rr;&amp;#10;        &amp;#10;        //&amp;#35299;&amp;#26512;&amp;#32467;&amp;#26524;&amp;#10;        if(ns_parserr(&amp;#38;handle, ns_s_an, rrnum, &amp;#38;rr) == 0) &amp;#123;&amp;#10;            char ip1[16];&amp;#10;            strcpy(ip1, inet_ntoa(*(struct in_addr *)ns_rr_rdata(rr)));&amp;#10;            NSString *ipString = [[NSString alloc] initWithCString:ip1 encoding:NSASCIIStringEncoding];&amp;#10;            if (![ipString isEqualToString:@&amp;#34;&amp;#34;]) &amp;#123;&amp;#10;                &amp;#10;                //&amp;#23558;&amp;#25552;&amp;#21462;&amp;#21040;&amp;#30340;IP&amp;#22320;&amp;#22336;&amp;#25918;&amp;#21040;&amp;#25968;&amp;#32452;&amp;#20013;&amp;#10;                [ipList addObject:ipString];&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而该方法有一个问题，在网络从2/3G和WI-FI之间切换的时候，该方法经常不能正常工作，或者需要等待较长的时间，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gethostbyname&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct hostent *gethostbyname(const char *hostName);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 具体代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct hostent *host = gethostbyname(&amp;#34;www.google.com.hk&amp;#34;);&amp;#10;&amp;#10;struct in_addr **list = (struct in_addr **)host-&amp;#62;h_addr_list;&amp;#10;&amp;#10;//&amp;#33719;&amp;#21462;IP&amp;#22320;&amp;#22336;&amp;#10;NSString *ip= [NSString stringWithCString:inet_ntoa(*list[0]) encoding:NSUTF8StringEncoding];&amp;#10;&amp;#10;NSLog(@&amp;#34;ip address is : %@&amp;#34;,ip);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;该方法在碰到切换网络的时候，出现失败的情况比上面的方法好多了，但偶尔也还是会出现，是时候采用苹果自己的方法了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CFHostStartInfoResolution&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Boolean CFHostStartInfoResolution (CFHostRef theHost, CFHostInfoType info, CFStreamError *error);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;具体实现方法如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Boolean result,bResolved;&amp;#10;CFHostRef hostRef;&amp;#10;CFArrayRef addresses = NULL;&amp;#10;&amp;#10;CFStringRef hostNameRef = CFStringCreateWithCString(kCFAllocatorDefault, &amp;#34;www.google.com.hk&amp;#34;, kCFStringEncodingASCII);&amp;#10;&amp;#10;hostRef = CFHostCreateWithName(kCFAllocatorDefault, hostNameRef);&amp;#10;if (hostRef) &amp;#123;&amp;#10;    result = CFHostStartInfoResolution(hostRef, kCFHostAddresses, NULL);&amp;#10;    if (result == TRUE) &amp;#123;&amp;#10;        addresses = CFHostGetAddressing(hostRef, &amp;#38;result);&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&amp;#10;bResolved = result == TRUE ? true : false;&amp;#10;&amp;#10;if(bResolved)&amp;#10;&amp;#123;&amp;#10;    struct sockaddr_in* remoteAddr;&amp;#10;    for(int i = 0; i &amp;#60; CFArrayGetCount(addresses); i++)&amp;#10;    &amp;#123;&amp;#10;        CFDataRef saData = (CFDataRef)CFArrayGetValueAtIndex(addresses, i);&amp;#10;        remoteAddr = (struct sockaddr_in*)CFDataGetBytePtr(saData);&amp;#10;        &amp;#10;        if(remoteAddr != NULL)&amp;#10;        &amp;#123;&amp;#10;            //&amp;#33719;&amp;#21462;IP&amp;#22320;&amp;#22336;&amp;#10;            char ip[16];&amp;#10;            strcpy(ip, inet_ntoa(remoteAddr-&amp;#62;sin_addr));&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&amp;#10;CFRelease(hostNameRef);&amp;#10;CFRelease(hostRef);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;具体的demo可以到&lt;a href=&quot;https://github.com/FreeMind-LJ/DNSTest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;看看&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  上次提到过由于电信的问题需要自己手动去解析dns，&lt;a href=&quot;http://www.jianshu.com/p/7c89b8c5482a&quot;&gt;这里&lt;/a&gt;介绍的是如何拦截&lt;br&gt;每一个请求做解析，但是没有说具体的解析方法，下面简单的记录一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;res_query方法&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int res_query(char *domain_name, int class, int type, char *answer_buffer, int answer_buffer_length)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是比较常见的系统调用，使用该方法的时候需要在Xcode中添加libresolv.dylib，然后包含resolv.h头文件即可，具体代码如下：&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发之--- NSURLProtocol</title>
    <link href="http://freemind-lj.github.io/2015/06/16/iOS%E5%BC%80%E5%8F%91%E4%B9%8B-NSURLProtocol/"/>
    <id>http://freemind-lj.github.io/2015/06/16/iOS开发之-NSURLProtocol/</id>
    <published>2015-06-16T03:29:55.000Z</published>
    <updated>2016-02-15T03:40:22.000Z</updated>
    
    <content type="html">&lt;p&gt;  最近在项目里由于电信那边发生dns发生域名劫持，因此需要手动将URL请求的域名重定向到指定的IP地址，但是由于请求可能是通过NSURLConnection,NSURLSession或者AFNetworking等方式，因此要想统一进行处理，一开始是想通过Method Swizzling去hook cfnetworking底层方法，后来发现其实有个更好的方法–NSURLProtocol。&lt;/p&gt;
&lt;h2 id=&quot;NSURLProtocol&quot;&gt;&lt;a href=&quot;#NSURLProtocol&quot; class=&quot;headerlink&quot; title=&quot;NSURLProtocol&quot;&gt;&lt;/a&gt;NSURLProtocol&lt;/h2&gt;&lt;p&gt;  NSURLProtocol能够让你去重新定义苹果的&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165-BCICJDHA&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;URL加载系统&lt;/a&gt; (URL Loading System)的行为，URL Loading System里有许多类用于处理URL请求，比如NSURL，NSURLRequest，NSURLConnection和NSURLSession等，当URL Loading System使用NSURLRequest去获取资源的时候，它会创建一个NSURLProtocol子类的实例，你不应该直接实例化一个NSURLProtocol，NSURLProtocol看起来像是一个协议，但其实这是一个类，而且必须使用该类的子类，并且需要被注册。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;  不管你是通过UIWebView, NSURLConnection 或者第三方库 (AFNetworking, MKNetworkKit等)，他们都是基于NSURLConnection或者 NSURLSession实现的，因此你可以通过NSURLProtocol做自定义的操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重定向网络请求&lt;/li&gt;
&lt;li&gt;忽略网络请求，使用本地缓存&lt;/li&gt;
&lt;li&gt;自定义网络请求的返回结果&lt;/li&gt;
&lt;li&gt;一些全局的网络请求设置&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;拦截网络请求&quot;&gt;&lt;a href=&quot;#拦截网络请求&quot; class=&quot;headerlink&quot; title=&quot;拦截网络请求&quot;&gt;&lt;/a&gt;拦截网络请求&lt;/h2&gt;&lt;h4 id=&quot;子类化NSURLProtocol并注册&quot;&gt;&lt;a href=&quot;#子类化NSURLProtocol并注册&quot; class=&quot;headerlink&quot; title=&quot;子类化NSURLProtocol并注册&quot;&gt;&lt;/a&gt;子类化NSURLProtocol并注册&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface CustomURLProtocol : NSURLProtocol&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在application:didFinishLaunchingWithOptions:方法中注册该CustomURLProtocol，一旦注册完毕后，它就有机会来处理所有交付给URL Loading system的网络请求。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &amp;#123;&amp;#10;    //&amp;#27880;&amp;#20876;protocol&amp;#10;    [NSURLProtocol registerClass:[CustomURLProtocol class]];&amp;#10;    return YES;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;实现CustomURLProtocol&quot;&gt;&lt;a href=&quot;#实现CustomURLProtocol&quot; class=&quot;headerlink&quot; title=&quot;实现CustomURLProtocol&quot;&gt;&lt;/a&gt;实现CustomURLProtocol&lt;/h4&gt;&lt;p&gt;注册好了之后，现在可以开始实现NSURLProtocol的一些方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;+canInitWithRequest:&lt;br&gt;这个方法主要是说明你是否打算处理对应的request，如果不打算处理，返回NO，URL Loading System会使用系统默认的行为去处理；如果打算处理，返回YES，然后你就需要处理该请求的所有东西，包括获取请求数据并返回给 URL Loading System。网络数据可以简单的通过NSURLConnection去获取，而且每个NSURLProtocol对象都有一个NSURLProtocolClient实例，可以通过该client将获取到的数据返回给URL Loading System。&lt;br&gt;这里有个需要注意的地方，想象一下，当你去加载一个URL资源的时候，URL Loading System会询问CustomURLProtocol是否能处理该请求，你返回YES，然后URL Loading System会创建一个CustomURLProtocol实例然后调用NSURLConnection去获取数据，然而这也会调用URL Loading System，而你在+canInitWithRequest:中又总是返回YES，这样URL Loading System又会创建一个CustomURLProtocol实例导致无限循环。我们应该保证每个request只被处理一次，可以通过+setProperty:forKey:inRequest:标示那些已经处理过的request，然后在+canInitWithRequest:中查询该request是否已经处理过了，如果是则返回NO。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (BOOL)canInitWithRequest:(NSURLRequest *)request&amp;#10;&amp;#123;&amp;#10;  //&amp;#21482;&amp;#22788;&amp;#29702;http&amp;#21644;https&amp;#35831;&amp;#27714;&amp;#10;    NSString *scheme = [[request URL] scheme];&amp;#10;    if ( ([scheme caseInsensitiveCompare:@&amp;#34;http&amp;#34;] == NSOrderedSame ||&amp;#10;     [scheme caseInsensitiveCompare:@&amp;#34;https&amp;#34;] == NSOrderedSame))&amp;#10;    &amp;#123;&amp;#10;        //&amp;#30475;&amp;#30475;&amp;#26159;&amp;#21542;&amp;#24050;&amp;#32463;&amp;#22788;&amp;#29702;&amp;#36807;&amp;#20102;&amp;#65292;&amp;#38450;&amp;#27490;&amp;#26080;&amp;#38480;&amp;#24490;&amp;#29615;&amp;#10;        if ([NSURLProtocol propertyForKey:URLProtocolHandledKey inRequest:request]) &amp;#123;&amp;#10;            return NO;&amp;#10;        &amp;#125;&amp;#10;        &amp;#10;        return YES;&amp;#10;    &amp;#125;&amp;#10;    return NO;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;+canonicalRequestForRequest:&lt;br&gt;通常该方法你可以简单的直接返回request，但也可以在这里修改request，比如添加header，修改host等，并返回一个新的request，这是一个抽象方法，子类必须实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (NSURLRequest *) canonicalRequestForRequest:(NSURLRequest *)request &amp;#123;&amp;#10;    NSMutableURLRequest *mutableReqeust = [request mutableCopy];&amp;#10;    mutableReqeust = [self redirectHostInRequset:mutableReqeust];&amp;#10;    return mutableReqeust;&amp;#10;&amp;#125;&amp;#10;&amp;#10;+(NSMutableURLRequest*)redirectHostInRequset:(NSMutableURLRequest*)request&amp;#10;&amp;#123;&amp;#10;    if ([request.URL host].length == 0) &amp;#123;&amp;#10;        return request;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    NSString *originUrlString = [request.URL absoluteString];&amp;#10;    NSString *originHostString = [request.URL host];&amp;#10;    NSRange hostRange = [originUrlString rangeOfString:originHostString];&amp;#10;    if (hostRange.location == NSNotFound) &amp;#123;&amp;#10;        return request;&amp;#10;    &amp;#125;&amp;#10;    //&amp;#23450;&amp;#21521;&amp;#21040;bing&amp;#25628;&amp;#32034;&amp;#20027;&amp;#39029;&amp;#10;    NSString *ip = @&amp;#34;cn.bing.com&amp;#34;;&amp;#10;    &amp;#10;    // &amp;#26367;&amp;#25442;&amp;#22495;&amp;#21517;&amp;#10;    NSString *urlString = [originUrlString stringByReplacingCharactersInRange:hostRange withString:ip];&amp;#10;    NSURL *url = [NSURL URLWithString:urlString];&amp;#10;    request.URL = url;&amp;#10;&amp;#10;    return request;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;+requestIsCacheEquivalent:toRequest:&lt;br&gt;主要判断两个request是否相同，如果相同的话可以使用缓存数据，通常只需要调用父类的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b&amp;#10;&amp;#123;&amp;#10;    return [super requestIsCacheEquivalent:a toRequest:b];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;-startLoading  -stopLoading&lt;br&gt;这两个方法主要是开始和取消相应的request，而且需要标示那些已经处理过的request。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)startLoading&amp;#10;&amp;#123;&amp;#10;    NSMutableURLRequest *mutableReqeust = [[self request] mutableCopy];&amp;#10;    //&amp;#26631;&amp;#31034;&amp;#25913;request&amp;#24050;&amp;#32463;&amp;#22788;&amp;#29702;&amp;#36807;&amp;#20102;&amp;#65292;&amp;#38450;&amp;#27490;&amp;#26080;&amp;#38480;&amp;#24490;&amp;#29615;&amp;#10;    [NSURLProtocol setProperty:@YES forKey:URLProtocolHandledKey inRequest:mutableReqeust];&amp;#10;    self.connection = [NSURLConnection connectionWithRequest:mutableReqeust delegate:self];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)stopLoading&amp;#10;&amp;#123;&amp;#10;    [self.connection cancel];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;NSURLConnectionDataDelegate方法&lt;br&gt;在处理网络请求的时候会调用到该代理方法，我们需要将收到的消息通过client返回给URL Loading System。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void) connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &amp;#123;&amp;#10;    [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void) connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &amp;#123;&amp;#10;    [self.client URLProtocol:self didLoadData:data];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void) connectionDidFinishLoading:(NSURLConnection *)connection &amp;#123;&amp;#10;    [self.client URLProtocolDidFinishLoading:self];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error &amp;#123;&amp;#10;    [self.client URLProtocol:self didFailWithError:error];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在你已经可以截取request并做你想做的事了，这里有个&lt;a href=&quot;https://github.com/FreeMind-LJ/NSURLProtocolExample&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo&lt;/a&gt;可以参考一下，截取request并重新定向到新的地址，具体dns解析方法可以参看&lt;a href=&quot;http://freemind-lj.github.io/2015/06/18/iOS开发之－－-DNS解析-网络切换的问题解决/&quot;&gt;DNS解析)&lt;/a&gt; ，如有不对，欢迎指正，哈～&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  最近在项目里由于电信那边发生dns发生域名劫持，因此需要手动将URL请求的域名重定向到指定的IP地址，但是由于请求可能是通过NSURLConnection,NSURLSession或者AFNetworking等方式，因此要想统一进行处理，一开始是想通过Method Swizzling去hook cfnetworking底层方法，后来发现其实有个更好的方法–NSURLProtocol。&lt;/p&gt;
&lt;h2 id=&quot;NSURLProtocol&quot;&gt;&lt;a href=&quot;#NSURLProtocol&quot; class=&quot;headerlink&quot; title=&quot;NSURLProtocol&quot;&gt;&lt;/a&gt;NSURLProtocol&lt;/h2&gt;&lt;p&gt;  NSURLProtocol能够让你去重新定义苹果的&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165-BCICJDHA&quot;&gt;URL加载系统&lt;/a&gt; (URL Loading System)的行为，URL Loading System里有许多类用于处理URL请求，比如NSURL，NSURLRequest，NSURLConnection和NSURLSession等，当URL Loading System使用NSURLRequest去获取资源的时候，它会创建一个NSURLProtocol子类的实例，你不应该直接实例化一个NSURLProtocol，NSURLProtocol看起来像是一个协议，但其实这是一个类，而且必须使用该类的子类，并且需要被注册。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;  不管你是通过UIWebView, NSURLConnection 或者第三方库 (AFNetworking, MKNetworkKit等)，他们都是基于NSURLConnection或者 NSURLSession实现的，因此你可以通过NSURLProtocol做自定义的操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重定向网络请求&lt;/li&gt;
&lt;li&gt;忽略网络请求，使用本地缓存&lt;/li&gt;
&lt;li&gt;自定义网络请求的返回结果&lt;/li&gt;
&lt;li&gt;一些全局的网络请求设置&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Xcode中统计代码覆盖率</title>
    <link href="http://freemind-lj.github.io/2015/06/11/Xcode%E4%B8%AD%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <id>http://freemind-lj.github.io/2015/06/11/Xcode中统计代码覆盖率/</id>
    <published>2015-06-11T11:31:20.000Z</published>
    <updated>2016-02-15T03:30:28.000Z</updated>
    
    <content type="html">&lt;p&gt;  最近在项目里需要在单元测试时统计一下&lt;a href=&quot;http://www.cnblogs.com/coderzh/archive/2009/03/29/1424344.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;代码覆盖率&lt;/a&gt;，其实就是被用来作为测量单元测试的指标，看看测试的代码覆盖到多广的范围，下面介绍一下如何统计单元测试的代码覆盖率：&lt;/p&gt;
&lt;h4 id=&quot;下载工具&quot;&gt;&lt;a href=&quot;#下载工具&quot; class=&quot;headerlink&quot; title=&quot;下载工具&quot;&gt;&lt;/a&gt;下载工具&lt;/h4&gt;&lt;p&gt;  主要采用&lt;a href=&quot;https://github.com/jonreid/XcodeCoverage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XcodeCoverage&lt;/a&gt;工具，它可以将代码覆盖的结果以html的形式展现，方便我们查看，可以采用pod的方式安装:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;#39;XcodeCoverage&amp;#39;, &amp;#39;~&amp;#62;1.0&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;工程配置&quot;&gt;&lt;a href=&quot;#工程配置&quot; class=&quot;headerlink&quot; title=&quot;工程配置&quot;&gt;&lt;/a&gt;工程配置&lt;/h4&gt;&lt;p&gt;pod安装后需要配置工程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置 Build Settings&lt;br&gt;需要设置两个地方，找到 “Generate Test Coverage Files”和“Instrument Program Flow”两个选项，分别设置Debug下为YES：&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;![&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-06-11%20.jpeg&quot; alt=&quot;屏幕快照 2015-06-11 下午5.47.01.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;](&lt;a href=&quot;http://upload-images.jianshu.io/upload_images/458529-ad6665fef33cbe69.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://upload-images.jianshu.io/upload_images/458529-ad6665fef33cbe69.png&lt;/a&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置 Build Phases&lt;br&gt;点击New Run Script Phase，编辑使其运行Pods/XcodeCoverage/exportenv.sh脚本：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E6%B7%BB%E5%8A%A0%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC.jpeg&quot; alt=&quot;添加运行脚本&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;RUN&quot;&gt;&lt;a href=&quot;#RUN&quot; class=&quot;headerlink&quot; title=&quot;RUN&quot;&gt;&lt;/a&gt;RUN&lt;/h4&gt;&lt;p&gt;工程配置完后，开始跑单元测试例。跑完测试例后，打开终端，cd进入到XcodeCoverage目录，运行如下脚本：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;./getcov --show&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后你就可以在浏览器中查看你的代码覆盖率结果。&lt;/p&gt;
&lt;h4 id=&quot;example&quot;&gt;&lt;a href=&quot;#example&quot; class=&quot;headerlink&quot; title=&quot;example&quot;&gt;&lt;/a&gt;example&lt;/h4&gt;&lt;p&gt;下面假设你要测试一个getMaxNumber功能，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@implementation MaxNumber&amp;#10;&amp;#10;+(int)getMaxNumber:(int)a b:(int)b c:(int)c&amp;#10;&amp;#123;&amp;#10;    if(a &amp;#62; b)&amp;#123;&amp;#10;        if(a &amp;#62; c)&amp;#123;&amp;#10;            return a;&amp;#10;        &amp;#125;else&amp;#123;&amp;#10;            return c;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;else&amp;#123;&amp;#10;        if(b &amp;#62; c)&amp;#123;&amp;#10;            return b;&amp;#10;        &amp;#125;else&amp;#123;&amp;#10;            return c;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&amp;#10;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先添加一个单元测试：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(void)testGetMax&amp;#10;&amp;#123;&amp;#10;    XCTAssertEqual(3, [MaxNumber getMaxNumber:1 b:2 c:3]);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行完该测试例后，运行脚本./getcov –show，便可以看到如下结果：&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%A6%86%E7%9B%96.jpeg&quot; alt=&quot;不完全覆盖&quot;&gt;&lt;br&gt;其中的红色表示测试例没有覆盖到的地方。下面增加三个测试例&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(void)testGetMax&amp;#10;&amp;#123;&amp;#10;    XCTAssertEqual(3, [MaxNumber getMaxNumber:1 b:2 c:3]);&amp;#10;    XCTAssertEqual(3, [MaxNumber getMaxNumber:2 b:1 c:3]);&amp;#10;    XCTAssertEqual(3, [MaxNumber getMaxNumber:3 b:2 c:1]);&amp;#10;    XCTAssertEqual(3, [MaxNumber getMaxNumber:1 b:3 c:2]);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;测试例修改之后，需要先运行cleancov脚本(如果工程里面的代码修改了，需要clean product)，然后再运行脚本./getcov –show查看结果：&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E5%AE%8C%E5%85%A8%E8%A6%86%E7%9B%96.jpeg&quot; alt=&quot;完全覆盖&quot;&gt;&lt;br&gt;可以看出现在的测试代码已经覆盖到了该函数的所有代码。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  最近在项目里需要在单元测试时统计一下&lt;a href=&quot;http://www.cnblogs.com/coderzh/archive/2009/03/29/1424344.html&quot;&gt;代码覆盖率&lt;/a&gt;，其实就是被用来作为测量单元测试的指标，看看测试的代码覆盖到多广的范围，下面介绍一下如何统计单元测试的代码覆盖率：&lt;/p&gt;
&lt;h4 id=&quot;下载工具&quot;&gt;&lt;a href=&quot;#下载工具&quot; class=&quot;headerlink&quot; title=&quot;下载工具&quot;&gt;&lt;/a&gt;下载工具&lt;/h4&gt;&lt;p&gt;  主要采用&lt;a href=&quot;https://github.com/jonreid/XcodeCoverage&quot;&gt;XcodeCoverage&lt;/a&gt;工具，它可以将代码覆盖的结果以html的形式展现，方便我们查看，可以采用pod的方式安装:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;#39;XcodeCoverage&amp;#39;, &amp;#39;~&amp;#62;1.0&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;工程配置&quot;&gt;&lt;a href=&quot;#工程配置&quot; class=&quot;headerlink&quot; title=&quot;工程配置&quot;&gt;&lt;/a&gt;工程配置&lt;/h4&gt;&lt;p&gt;pod安装后需要配置工程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置 Build Settings&lt;br&gt;需要设置两个地方，找到 “Generate Test Coverage Files”和“Instrument Program Flow”两个选项，分别设置Debug下为YES：&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="others" scheme="http://freemind-lj.github.io/categories/others/"/>
    
    
      <category term="测试" scheme="http://freemind-lj.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ios runtime浅析(三)：Method Swizzling</title>
    <link href="http://freemind-lj.github.io/2015/06/05/ios-runtime%E6%B5%85%E6%9E%90-%E4%B8%89-%EF%BC%9AMethod-Swizzling/"/>
    <id>http://freemind-lj.github.io/2015/06/05/ios-runtime浅析-三-：Method-Swizzling/</id>
    <published>2015-06-05T15:33:10.000Z</published>
    <updated>2016-02-15T01:34:25.000Z</updated>
    
    <content type="html">&lt;p&gt;  看到nshipster 的&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Method Swizzling&lt;/a&gt;这篇不错的文章还没翻译，就补充一下，没有逐字翻译，关于&lt;a href=&quot;http://nshipster.cn/associated-objects/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;associated objects&lt;/a&gt;已经有翻译了，大家也可以去了解一下。&lt;br&gt;  method swizzling也许是runtime中最有争议的技术，它的作用就是改变已经存在selector的实现，之所以可以这样是因为方法调用可以在运行时改变：通过改变类的分发表( dispatch table，该表包含selector的名称及对应实现函数的地址)里selector和实现之间的对应关系。&lt;br&gt;  举个例子，比如你想记录一个iOS应用里每个view controller显示的次数：可以在每个view controller添加记录的代码，但这会导致大量的重复代码；通过继承也是一个方法，但需要同时创建UIViewController, UITableViewController, UINavigationController及其它中view controller的子类，同样也会产生许多重复的代码出现。&lt;br&gt;  幸运的是，在UIViewController的category使用method swizzling：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#60;objc/runtime.h&amp;#62;&amp;#10;&amp;#10;@implementation UIViewController (Tracking)&amp;#10;&amp;#10;+ (void)load &amp;#123;&amp;#10;    static dispatch_once_t onceToken;&amp;#10;    dispatch_once(&amp;#38;onceToken, ^&amp;#123;&amp;#10;        Class class = [self class];&amp;#10;&amp;#10;        SEL originalSelector = @selector(viewWillAppear:);&amp;#10;        SEL swizzledSelector = @selector(xxx_viewWillAppear:);&amp;#10;&amp;#10;        Method originalMethod = class_getInstanceMethod(class, originalSelector);&amp;#10;        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);&amp;#10;&amp;#10;        // &amp;#22914;&amp;#26524; swizzling &amp;#30340;&amp;#26159;&amp;#31867;&amp;#26041;&amp;#27861;, &amp;#37319;&amp;#29992;&amp;#22914;&amp;#19979;&amp;#30340;&amp;#26041;&amp;#24335;:&amp;#10;        // Class class = object_getClass((id)self);&amp;#10;        // ...&amp;#10;        // Method originalMethod = class_getClassMethod(class, originalSelector);&amp;#10;        // Method swizzledMethod = class_getClassMethod(class, swizzledSelector);&amp;#10;        &amp;#10;        //&amp;#20132;&amp;#25442;&amp;#23454;&amp;#29616;&amp;#10;        method_exchangeImplementations(originalMethod, swizzledMethod);&amp;#10;    &amp;#125;);&amp;#10;&amp;#125;&amp;#10;&amp;#10;#pragma mark - Method Swizzling&amp;#10;&amp;#10;- (void)xxx_viewWillAppear:(BOOL)animated &amp;#123;&amp;#10;    [self xxx_viewWillAppear:animated];&amp;#10;    NSLog(@&amp;#34;viewWillAppear: %@&amp;#34;, self);&amp;#10;&amp;#125;&amp;#10;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  现在，当一个UIViewController或者其子类的实例调用viewWillAppear:方法时，就会打印出一条记录。假如要在在view controller的生命周期，view的绘制或者Foundation的网络协议栈注入一些自定的行为，method swizzling也许是你应该考虑的一个方向。&lt;/p&gt;
&lt;p&gt;下面是使用method swizzling应该注意的点：&lt;/p&gt;
&lt;h3 id=&quot;load-vs-initialize&quot;&gt;&lt;a href=&quot;#load-vs-initialize&quot; class=&quot;headerlink&quot; title=&quot;+load vs. +initialize&quot;&gt;&lt;/a&gt;+load vs. +initialize&lt;/h3&gt;&lt;h6 id=&quot;Swizzling应该只在load方法中使用&quot;&gt;&lt;a href=&quot;#Swizzling应该只在load方法中使用&quot; class=&quot;headerlink&quot; title=&quot;Swizzling应该只在load方法中使用&quot;&gt;&lt;/a&gt;Swizzling应该只在load方法中使用&lt;/h6&gt;&lt;p&gt;oc会在运行时自动调用每个类的两个方法，+load 会在类初始化加载的时候调用；+initialize方法会在程序调用类的第一个实例或者类方法的时候调用。这两个方法都是可选的，只会在实现的时候才去调用。由于method swizzling会影响到全局的状态，因此最小化竞争条件的出现变得很重要，+load方法能够确保在类的初始化时候调用，这能够保证改变应用行为的一致性，而+initialize在执行时并不提供这种保证，实际上，如果没有直接给这个类发送消息，该方法可能都不会调用到。&lt;/p&gt;
&lt;h3 id=&quot;dispatch-once&quot;&gt;&lt;a href=&quot;#dispatch-once&quot; class=&quot;headerlink&quot; title=&quot;dispatch_once&quot;&gt;&lt;/a&gt;dispatch_once&lt;/h3&gt;&lt;h4 id=&quot;Swizzling应该只在dispatch-once中完成&quot;&gt;&lt;a href=&quot;#Swizzling应该只在dispatch-once中完成&quot; class=&quot;headerlink&quot; title=&quot;Swizzling应该只在dispatch_once中完成&quot;&gt;&lt;/a&gt;Swizzling应该只在dispatch_once中完成&lt;/h4&gt;&lt;p&gt;如上，由于swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是其中的一种预防措施，因为它能保证不管有多少个线程，代码只会执行一次。GCD的dispatch_once 能够满足这种需求，因此在method swizzling应该将其作为最佳的实践方式。&lt;/p&gt;
&lt;h3 id=&quot;选择器，方法和实现&quot;&gt;&lt;a href=&quot;#选择器，方法和实现&quot; class=&quot;headerlink&quot; title=&quot;选择器，方法和实现&quot;&gt;&lt;/a&gt;选择器，方法和实现&lt;/h3&gt;&lt;p&gt;在oc中，选择器、方法和实现是运行时的特殊方面，虽然在一般情况下，这些术语是用在消息发送的过程中。&lt;br&gt;下面是Apple对它们的几个描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择器(Selector-typedef struct objc_selector *SEL )：用于在运行时表示一个方法的名称，一个方法选择器就是一个C字符串，在运行时会被注册或者映射，选择器是由编译器生成的，并在类被加载的时候由运行时自动进行映射。&lt;/li&gt;
&lt;li&gt;方法(Method-typedef struct objc_method *Method)：在类的定义中代表一个方法的类型。&lt;/li&gt;
&lt;li&gt;实现(Implementation- typedef id (*IMP)(id, SEL, …))：这是一个指向方法实现函数起始地址的指针，这个函数的第一个参数是指向self的指针，第二个参数是方法选择器，然后是方法的参数。&lt;br&gt;理解它们之间关系的最好方式是：一个类维护着一张分发表(dispatch table)，用来解析运行时发来的消息；该表的每个入口是一个方法(Method)，其中的key就是选择器(SEL)，对应一个实现(IMP)，即一个指向底层c函数的指针。&lt;br&gt;swizzle 一个方法就是改变类的分发表，使它在解析消息的时候，将一个选择器selector对应到别的实现，并且将该选择器对应的原始实现关联到新的选择器中。&lt;h3 id=&quot;调用-cmd&quot;&gt;&lt;a href=&quot;#调用-cmd&quot; class=&quot;headerlink&quot; title=&quot;调用 _cmd&quot;&gt;&lt;/a&gt;调用 _cmd&lt;/h3&gt;看起来下面的代码可能导致无限循环：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)xxx_viewWillAppear:(BOOL)animated &amp;#123;&amp;#10;    [self xxx_viewWillAppear:animated];&amp;#10;    NSLog(@&amp;#34;viewWillAppear: %@&amp;#34;, NSStringFromClass([self class]));&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可奇怪的是，它并不会。在swizzling的过程中，xxx_viewWillAppear:已经被重新指向UIViewController 的原始实现-viewWillAppear:，但是如果我们在这个方法中调用viewWillAppear:则会导致无限循环。&lt;/p&gt;
&lt;h3 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h3&gt;&lt;p&gt;通常认为Swizzling是一个比较危险的技术，容易产生不可预料的行为和无法预见的后果，但只要遵循以下几个注意事项，其实method swizzlin还是相对安全的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总是调用一个方法的原始实现(除非你有足够好的理由不这么做):API提供了输入和输出的约定，但其中的实现却是黑盒。Swizzling 一个方法但不去调用其原始实现，可能造成私有状态的底层假设被打破，影响程序的其它部分。&lt;/li&gt;
&lt;li&gt;避免冲突: 给category方法加前缀，确保不会跟其它依赖的代码产生冲突。&lt;/li&gt;
&lt;li&gt;知道到底发生啥了：简单的复制粘贴swizzling 代码，而不清楚其如何工作不仅非常危险，而且浪费了好多深入学习objective-c运行时的机会，可以通过查看 &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/c/func/method_getImplementation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Objective-C Runtime Reference&lt;/a&gt; 和&lt;objc runtime.h=&quot;&quot;&gt;头文件了解其中的一些来龙去脉。&lt;/objc&gt;&lt;/li&gt;
&lt;li&gt;小心的处理：不管你在swizzling Foundation、UIKit或者其它内建framework方法时多么的充满自信，必须清楚在下一个版本这些可能都改变了，所以为了不出差错，还是需要多花点心思的。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  看到nshipster 的&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/&quot;&gt;Method Swizzling&lt;/a&gt;这篇不错的文章还没翻译，就补充一下，没有逐字翻译，关于&lt;a href=&quot;http://nshipster.cn/associated-objects/&quot;&gt;associated objects&lt;/a&gt;已经有翻译了，大家也可以去了解一下。&lt;br&gt;  method swizzling也许是runtime中最有争议的技术，它的作用就是改变已经存在selector的实现，之所以可以这样是因为方法调用可以在运行时改变：通过改变类的分发表( dispatch table，该表包含selector的名称及对应实现函数的地址)里selector和实现之间的对应关系。&lt;br&gt;  举个例子，比如你想记录一个iOS应用里每个view controller显示的次数：可以在每个view controller添加记录的代码，但这会导致大量的重复代码；通过继承也是一个方法，但需要同时创建UIViewController, UITableViewController, UINavigationController及其它中view controller的子类，同样也会产生许多重复的代码出现。&lt;br&gt;  幸运的是，在UIViewController的category使用method swizzling：&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="runtime" scheme="http://freemind-lj.github.io/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>ios runtime浅析(二)：消息转发</title>
    <link href="http://freemind-lj.github.io/2015/06/02/ios-runtime%E6%B5%85%E6%9E%90-%E4%BA%8C-%EF%BC%9A%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>http://freemind-lj.github.io/2015/06/02/ios-runtime浅析-二-：消息转发/</id>
    <published>2015-06-02T06:34:48.000Z</published>
    <updated>2016-02-15T03:38:24.000Z</updated>
    
    <content type="html">&lt;p&gt;  如果你给一个对象发送它不认识的消息时，系统会抛出一个错误，但在错误抛出之前，运行时会给改对象发送forwardInvocation:消息，同时传递一个NSInvocation对象作为该消息的参数，NSInvocation对象包封装原始消息和对应的参数。你可以实现forwardInvocation:方法来对不能处理的消息做一些默认的处理，以避免程序崩溃，但正如该函数的名字一样，这个函数主要是用来将消息转发给其它对象。每一个对象都从NSObject类继承了forwardInvocation:方法，但在NSObject中，该方法只是简单的调用doesNotRecognizeSelector:，通过重写该方法你就可以利用forwardInvocation:将消息转发给其它对象。&lt;br&gt;  为了转发一个消息，forwardInvocation:需要做的事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定消息该往哪发&lt;/li&gt;
&lt;li&gt;同时发送对应的原始参数&lt;br&gt;消息可以通过invokeWithTarget:方法发送：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation&amp;#10;&amp;#123;&amp;#10;    if ([someOtherObject respondsToSelector:[anInvocation selector]])&amp;#10;        [anInvocation invokeWithTarget:someOtherObject];&amp;#10;    else&amp;#10;       [super forwardInvocation:anInvocation];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;forwardInvocation:方法可以作为无法认识的消息的分发中心，将它们打包发给不同的接受者，或者作为一个中转站将所有消息发往同一个目的地。它可以将一个消息转换成另外的一个消息，或者只是单纯的把消息“吞下”，不对外响应和抛出错误，forwardInvocation:做什么取决于实现者。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;转发和多继承&quot;&gt;&lt;a href=&quot;#转发和多继承&quot; class=&quot;headerlink&quot; title=&quot;转发和多继承&quot;&gt;&lt;/a&gt;转发和多继承&lt;/h3&gt;&lt;p&gt;  转发有点像模仿继承，一个对象通过转发响应一个消息，看起来像是继承了其它类实现的方法。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E8%BD%AC%E5%8F%91.jpeg&quot; alt=&quot;转发&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;如上图所示，一个Warrior类的实例转发一条negotiate消息到Diplomat类的实例，使得Warrior看起来能够像Diplomat一样进行negotiate。&lt;br&gt;通过转发消息的对象从而从两个继承体系分支“继承”了方法：原本的继承分支和通过响应消息。在上面的例子中，Warrior看起来好像继承自Diplomat和它的父类。然而转发跟继承有一个重要的区别：继承将不同的功能集合到一个对象；而转发是将不同的功能分配给不同的对象，它将一个问题分解成小的对象，然后通过一种对消息发送者透明的方式把这些对象关联起来。&lt;br&gt;虽然转发能够模仿继承，但是NSObject类不会因为这两个困惑，类似 respondsToSelector: 和 isKindOfClass: 方法只会查看它的继承体系，不会去查看转发链，比如下面查看Warrior能否响应negotiate消息：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if ( [aWarrior respondsToSelector:@selector(negotiate)] )&amp;#10;    ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;答案永远是NO，即便它能够通过将该消息转发给Diplomat而响应该消息且不会抛出错误。&lt;br&gt;  同时在调用forwardInvocation:之前，需要先调用methodSignatureForSelector:获取指定selector的方法签名：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector&amp;#10;&amp;#123;&amp;#10;    NSMethodSignature* signature = [super methodSignatureForSelector:selector];&amp;#10;    if (!signature) &amp;#123;&amp;#10;       signature = [surrogate methodSignatureForSelector:selector];&amp;#10;    &amp;#125;&amp;#10;    return signature;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface ForwardClass : NSObject &amp;#10;-(void)doSomethingElse;&amp;#10;@end&amp;#10;&amp;#10;@implementation ForwardClass&amp;#10;&amp;#10;-(void)doSomethingElse&amp;#10; &amp;#123;&amp;#10;    NSLog(@&amp;#34;doSomething was called on %@&amp;#34;, [self class]);&amp;#10;&amp;#125;&amp;#10;@end&amp;#10;&amp;#10;@interface SomeClass : NSObject &amp;#10;&amp;#123;&amp;#10;    id forwardClass;&amp;#10;&amp;#125;&amp;#10;&amp;#10;-(void)doSomething;&amp;#10;&amp;#10;@end&amp;#10;&amp;#10;@implementation SomeClass&amp;#10;&amp;#10;-(id)init&amp;#10; &amp;#123;&amp;#10;    if (self = [super init]) &amp;#123;&amp;#10;        forwardClass = [ForwardClass new];&amp;#10;    &amp;#125;&amp;#10;    return self;&amp;#10;&amp;#125;&amp;#10;&amp;#10;-(void)doSomething&amp;#10; &amp;#123;&amp;#10;    NSLog(@&amp;#34;doSomething was called on %@&amp;#34;, [self class]);&amp;#10;&amp;#125;&amp;#10;&amp;#10;-(void)forwardInvocation:(NSInvocation *)invocation&amp;#10; &amp;#123;&amp;#10;    if (! forwardClass) &amp;#123;&amp;#10;        [self doesNotRecognizeSelector: [invocation selector]];&amp;#10;    &amp;#125;&amp;#10;    [invocation invokeWithTarget: forwardClass];&amp;#10;&amp;#125;&amp;#10;&amp;#10;-(NSMethodSignature*)methodSignatureForSelector:(SEL)selector&amp;#10; &amp;#123;&amp;#10;    NSMethodSignature *signature = [super methodSignatureForSelector:selector];&amp;#10;    if (! signature) &amp;#123;&amp;#10;        //&amp;#29983;&amp;#25104;&amp;#26041;&amp;#27861;&amp;#31614;&amp;#21517;&amp;#10;        signature = [forwardClass methodSignatureForSelector:selector];&amp;#10;    &amp;#125;&amp;#10;    return signature;&amp;#10;&amp;#125;&amp;#10;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;现在给SomeClass对象发送doSomethingElse消息后程序不会crash了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;id someClass = [SomeClass new];&amp;#10;[someClass doSomething];//ForwardTest[1291:56187] doSomething was called on SomeClass&amp;#10;[someClass doSomethingElse];// ForwardTest[1291:56187] doSomething was called on ForwardClass&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;消息转发有很多的用途，比如： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个对象负责把消息转发给一个由其它对象组成的响应链，代理对象会在这个有其它对象组成的集合里寻找能够处理该消息的对象；&lt;/li&gt;
&lt;li&gt;把一个对象包在一个logger对象里，用来拦截或者纪录一些有趣的消息调用；&lt;/li&gt;
&lt;li&gt;比如声明类的属性为dynamic，使用自定义的方法来截取和取代由系统自动生成的getter和setter方法。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  如果你给一个对象发送它不认识的消息时，系统会抛出一个错误，但在错误抛出之前，运行时会给改对象发送forwardInvocation:消息，同时传递一个NSInvocation对象作为该消息的参数，NSInvocation对象包封装原始消息和对应的参数。你可以实现forwardInvocation:方法来对不能处理的消息做一些默认的处理，以避免程序崩溃，但正如该函数的名字一样，这个函数主要是用来将消息转发给其它对象。每一个对象都从NSObject类继承了forwardInvocation:方法，但在NSObject中，该方法只是简单的调用doesNotRecognizeSelector:，通过重写该方法你就可以利用forwardInvocation:将消息转发给其它对象。&lt;br&gt;  为了转发一个消息，forwardInvocation:需要做的事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定消息该往哪发&lt;/li&gt;
&lt;li&gt;同时发送对应的原始参数&lt;br&gt;消息可以通过invokeWithTarget:方法发送：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation&amp;#10;&amp;#123;&amp;#10;    if ([someOtherObject respondsToSelector:[anInvocation selector]])&amp;#10;        [anInvocation invokeWithTarget:someOtherObject];&amp;#10;    else&amp;#10;       [super forwardInvocation:anInvocation];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;forwardInvocation:方法可以作为无法认识的消息的分发中心，将它们打包发给不同的接受者，或者作为一个中转站将所有消息发往同一个目的地。它可以将一个消息转换成另外的一个消息，或者只是单纯的把消息“吞下”，不对外响应和抛出错误，forwardInvocation:做什么取决于实现者。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="runtime" scheme="http://freemind-lj.github.io/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>利用Charles分析iOS app的网络通信</title>
    <link href="http://freemind-lj.github.io/2015/05/29/%E5%88%A9%E7%94%A8Charles%E5%88%86%E6%9E%90iOS-app%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    <id>http://freemind-lj.github.io/2015/05/29/利用Charles分析iOS-app的网络通信/</id>
    <published>2015-05-29T06:36:11.000Z</published>
    <updated>2016-02-15T03:37:46.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://www.charlesproxy.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Charles&lt;/a&gt;，一个非常方便的抓包工具，这次主要介绍一下如何利用Charles分析iOS应用的网络通信，以iOS应用NASA为例（最近对universe有点感兴趣），下面为app的模样：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-05-29%20%E4%B8%8B%E5%8D%88.jpeg&quot; alt=&quot;屏幕快照 2015-05-29 下午2.38.34.png&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;里面可以查看一些跟太空相关的图片，分析一下如何获取这些图片，但需要手机连接到Mac共享的Wi-Fi上。&lt;br&gt;&lt;em&gt; 查看Mac的IP地址，比如我机器上的为：192.168.56.160;
&lt;/em&gt; 打开iPhone设置，选择连接的Wi-Fi，设置HTTP代理，选择手动，并设置服务器的Mac的IP地址，端口设为8090;&lt;br&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E6%89%8B%E6%9C%BA%E8%AE%BE%E7%BD%AE.jpeg&quot; alt=&quot;手机设置&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;打开Charles应用，选择菜单“Proxy”-&amp;gt;”Proxy Settings”，设置端口号8090，同时勾选”Enable transparent HTTP proxying” &lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/Charles%E8%AE%BE%E7%BD%AE.jpeg&quot; alt=&quot;Charles设置&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;* 打开NASA应用，Charles开始记录，进入app的Images选项：&lt;br&gt;&lt;br&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/Charles%E7%BA%AA%E5%BD%95%E7%BB%93%E6%9E%9C.jpeg&quot; alt=&quot;Charles纪录结果&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://7xpjm0.com1.z0.glb.clouddn.com/%E6%89%8B%E6%9C%BA%E7%95%8C%E9%9D%A2.jpeg&quot; alt=&quot;手机界面&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;通过Charles可以看出获取这张图片请求方式为：&lt;br&gt;&lt;a href=&quot;http://mobile.arc.nasa.gov/public/iexplore/images/useradded/320/norfolk_ast_2009316.jpg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://mobile.arc.nasa.gov/public/iexplore/images/useradded/320/norfolk_ast_2009316.jpg&lt;/a&gt; ，其它的请求信息都可以在Charles中查看。所以假如你自己的应用想要显示NASA的一些图片，你就可以使用这些请求方式了，分析其它应用方法类似。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.charlesproxy.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Charles&lt;/a&gt;，一个非常方便的抓包工具，这次主要介绍一下如何利用Charles分析iOS应用的网络通信，以iOS应用NASA为
    
    </summary>
    
      <category term="tech" scheme="http://freemind-lj.github.io/categories/tech/"/>
    
    
      <category term="charles" scheme="http://freemind-lj.github.io/tags/charles/"/>
    
      <category term="iOS开发" scheme="http://freemind-lj.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
